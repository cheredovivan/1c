#Область ПрограммныйИнтерфейс

#Область СрокиИсполнения

// Возвращает график работы исполнителя.
//
// Параметры:
//  Исполнитель - СправочникСсылка.Сотрудники, СправочникСсылка.Пользователи
//
Функция ГрафикРаботыИсполнителя(Исполнитель) Экспорт
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьГрафикиРаботы") Тогда
		Возврат Справочники.ГрафикиРаботы.ПустаяСсылка();
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Исполнитель) Тогда
		Возврат ОбщегоНазначенияДокументооборотПовтИсп.ПолучитьОсновнойГрафикРаботы();
	КонецЕсли;
	
	Возврат ОбщегоНазначенияДокументооборотПовтИсп.ГрафикРаботыУчастника(Исполнитель);
	
КонецФункции

// Изменять срок (точную дату или относительный срок) по предствлению
//
// Параметры:
//  Дата - Дата - срок исполнения датой (точный срок).
//  Дни - Число - относительный срок, дни.
//  Часы - Число - относительный срок, часы.
//  Минуты - Число - относительный срок, минуты.
//  ВариантУстановкиСрока - ПеречислениеСсылка.ВариантыУстановкиСрокаИсполнения - 
//                          вариант установки срока.
//  Представление - Строка - представление срока строкой.
//  ДопПараметры - Структура - структура вспомогательных параметров.
//   * ТекстСообщенияПредупреждения - Строка - возвращаемый текст сообщения/предупреждения в
//                                             случае ошибки.
//   * ВПредставленииМожетБытьДата - Булево - признак того, что в представлении может быть дата.
//   * Исполнитель - СправочникСсылка.Пользователи,
//                   СправочникСсылка.РолиИсполнителей,
//                   СправочникСсылка.Сотрудники - исполнитель срок которого изменяется.
//
// Возвращаемое значение:
//  Булево
//
Функция ИзменитьСрокИсполненияПоПредставлению(
	Дата, Дни, Часы, Минуты, ВариантУстановкиСрока, Представление, ДопПараметры) Экспорт
	
	// Если представление пустое, то очищаем все поля сроков
	Если Не ЗначениеЗаполнено(Представление) Тогда
		Дата = Дата(1,1,1);
		Дни = 0;
		Часы = 0;
		Минуты = 0;
		
		Возврат Истина;
	КонецЕсли;
	
	ТекстСообщенияОбОшибке = НСтр("ru = 'Срок задан некорректно.'");
	
	ВариантыУстановкиСрока = 
		ОбщегоНазначенияДокументооборотКлиентСервер.ВариантыУстановкиСрокаИсполнения();
	
	// Если есть разделитель даты и длительности, тогда разделяем представление на
	// длительность (ПредставлениеДлительности) и дату (ПредставлениеДаты), иначе
	// пытаемся обработать целиком представление и как длительность и как дату.
	Представление = СтрЗаменить(Представление, ")", "");
	ПредставлениеДлительности = Представление;
	ПредставлениеДаты = Представление;
	Если ДопПараметры.ВПредставленииМожетБытьДата Тогда
		Разделитель = "(";
		
		Если СтрНайти(Представление, Разделитель) Тогда
			ЧастиПредставления = СтрРазделить(Представление, Разделитель);
			КоличествоЧастейПредствления = ЧастиПредставления.Количество();
			Если КоличествоЧастейПредствления <> 2 Тогда
				ДопПараметры.ТекстСообщенияПредупреждения = ТекстСообщенияОбОшибке;
				Возврат Ложь;
			КонецЕсли;
			
			Если ВариантУстановкиСрока = ВариантыУстановкиСрока.ТочныйСрок Тогда
				ПредставлениеДлительности = СокрЛП(ЧастиПредставления[1]);
				ПредставлениеДаты = СокрЛП(ЧастиПредставления[0]);
			Иначе
				ПредставлениеДлительности = СокрЛП(ЧастиПредставления[0]);
				ПредставлениеДаты = СокрЛП(ЧастиПредставления[1]);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	// Определяем дату по представлению.
	НоваяДата = Дата(1,1,1);
	Если ДопПараметры.ВПредставленииМожетБытьДата Тогда
		НоваяДата = ОбщегоНазначенияДокументооборотКлиентСервер.ДатаПоПредставлению(
			ПредставлениеДаты);
	КонецЕсли;
	
	// Определяем длительность по представлению.
	Длительность = ОбщегоНазначенияДокументооборотКлиентСервер.ДлительностьПоПредставлению(
		ПредставлениеДлительности);
	
	// Если по представлению не удалось определить ни длительность
	// ни дату, то выводим сообщение об ошибке.
	Если Не ЗначениеЗаполнено(Длительность) И Не ЗначениеЗаполнено(НоваяДата) Тогда
		ДопПараметры.ТекстСообщенияПредупреждения = ТекстСообщенияОбОшибке;
		Возврат Ложь;
	КонецЕсли;
	
	// Если удалось определить и длительность и дату,
	// и они все отличаются от предыдущих значений, тогда выводим ошибку.
	// Измененным может быть либо длительность, либо дата.
	Если ЗначениеЗаполнено(Длительность)
		И (Дни <> Длительность.Дни Или Часы <> Длительность.Часы Или Минуты <> Длительность.Минуты)
		И ЗначениеЗаполнено(НоваяДата)
		И Дата <> НоваяДата Тогда
		
		ДопПараметры.ТекстСообщенияПредупреждения = ТекстСообщенияОбОшибке;
		Возврат Ложь;
	КонецЕсли;
	
	ИспользоватьДатуИВремяВСрокахЗадач = 
		ПолучитьФункциональнуюОпцию("ИспользоватьДатуИВремяВСрокахЗадач");
	
	// Установка срока исполнения по новой дате
	Если ЗначениеЗаполнено(НоваяДата) И Дата <> НоваяДата Тогда
		
		ВариантУстановкиСрока = ВариантыУстановкиСрока.ТочныйСрок;
		
		Если ИспользоватьДатуИВремяВСрокахЗадач Тогда
			Дата = НоваяДата;
		Иначе
			Дата = Дата(Год(НоваяДата), Месяц(НоваяДата), День(НоваяДата));
			Дата = КонецДня(Дата);
		КонецЕсли;
		
		// Корректировка указанной даты по графику работ.
		Если ПолучитьФункциональнуюОпцию("ИспользоватьГрафикиРаботы") Тогда
			
			ГрафикРаботы = ГрафикРаботыИсполнителя(ДопПараметры.Исполнитель);
			
			ЭтоРабочееВремя = Истина;
			Если ИспользоватьДатуИВремяВСрокахЗадач Тогда
				ЭтоРабочееВремя = ГрафикиРаботы.ЭтоРабочаяДатаВремя(ГрафикРаботы, Дата);
			Иначе
				ЭтоРабочееВремя = ГрафикиРаботы.ЭтоРабочийДень(Дата, ГрафикРаботы);
			КонецЕсли;
			
			Если Не ЭтоРабочееВремя Тогда
				ДопПараметры.ТекстСообщенияПредупреждения = 
					НСтр("ru = 'Выбранный срок не соответствует графику работы исполнителя.
						|Задача может быть просрочена.'");
			КонецЕсли;
			
		КонецЕсли;
		
		Дни = 0;
		Часы = 0;
		Минуты = 0;
		
	// Установка срока исполнения по новой длительности
	ИначеЕсли ЗначениеЗаполнено(Длительность)
		И (Длительность.Дни <> Дни
			Или Длительность.Часы <> Часы
			Или Длительность.Минуты <> Минуты) Тогда
		
		ВариантУстановкиСрока = ВариантыУстановкиСрока.ОтносительныйСрок;
		
		Дни = Длительность.Дни;
		Часы = Длительность.Часы;
		Минуты = Длительность.Минуты;
		
		Если Не ИспользоватьДатуИВремяВСрокахЗадач Тогда
			Часы = 0;
			Минуты = 0;
		КонецЕсли;
		
		Дата = Дата(1,1,1);
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

// Метаданные доступны по правам и функциональным опциям.
// 
// Параметры:
//  ПроверяемыеМетаданные - ОбъектМетаданных.
// 
// Возвращаемое значение:
//  Булево - Метаданные доступны по правам и функциональным опциям.
//
Функция МетаданныеДоступны(ПроверяемыеМетаданные) Экспорт
	
	// Права доступа.
	ДоступенПоПравам = ПравоДоступа("Просмотр", ПроверяемыеМетаданные);
	Если Не ДоступенПоПравам Тогда
		МетаданныеДоступны = Ложь;
		Возврат МетаданныеДоступны;
	КонецЕсли;
	
	// Функциональные опции.
	ДанныеФункциональныхОпций = ОбщегоНазначенияДокументооборотПовтИсп.ДанныеФункциональныхОпций();
	ПараметрыОтбора = Новый Структура("Объект", ПроверяемыеМетаданные.ПолноеИмя());
	ФункциональныеОпцииИсточника = ДанныеФункциональныхОпций.НайтиСтроки(ПараметрыОтбора);
	
	НРегИсточник = НРег(ПроверяемыеМетаданные.ПолноеИмя());
	Если СтрНайти(НРегИсточник, ".команда.") <> 0
		Или СтрНайти(НРегИсточник, "общаякоманда") <> 0 Тогда
		МетаданныеРодителяИсточника = ПроверяемыеМетаданные.Родитель();
		ПараметрыОтбора = Новый Структура("Объект", МетаданныеРодителяИсточника.ПолноеИмя());
		ФункциональныеОпцииРодителяИсточника = ДанныеФункциональныхОпций.НайтиСтроки(ПараметрыОтбора);
	Иначе
		ФункциональныеОпцииРодителяИсточника = Новый Массив;
	КонецЕсли;
	
	ЕстьФункциональныеОпцииИсточника = ФункциональныеОпцииИсточника.Количество() <> 0
		Или ФункциональныеОпцииРодителяИсточника.Количество() <> 0;
	ЕстьВключенныеФункциональныеОпцииИсточника = Ложь;
	Если ЕстьФункциональныеОпцииИсточника Тогда
		Для Каждого ДанныеФункциональнойОпции Из ФункциональныеОпцииИсточника Цикл
			Если ПолучитьФункциональнуюОпцию(ДанныеФункциональнойОпции.Имя, Новый Структура("Пользователи", Пользователи.ТекущийПользователь())) Тогда
				ЕстьВключенныеФункциональныеОпцииИсточника = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Не ЕстьВключенныеФункциональныеОпцииИсточника Тогда
			Для Каждого ДанныеФункциональнойОпции Из ФункциональныеОпцииРодителяИсточника Цикл
				Если ПолучитьФункциональнуюОпцию(ДанныеФункциональнойОпции.Имя) Тогда
					ЕстьВключенныеФункциональныеОпцииИсточника = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	МетаданныеДоступны = Не ЕстьФункциональныеОпцииИсточника
		Или ЕстьВключенныеФункциональныеОпцииИсточника;
	
	Возврат МетаданныеДоступны;
	
КонецФункции

// Обертка, подменяющая отбор по полю в запросе и сразу устанавливающая нужный параметр, или если нет параметра, то
// убирающая отбор. Для однотипных подмен при сборке запроса по кускам.
// 
// Параметры:
//  Запрос - Запрос - В котором надо подменить отборы и установить параметр.
//  ЧтоПодменить - Строка - Строка из запроса, которую подменяем. Должна быть "похожа" на параметр запроса,
//							чтобы исходный запрос формально был верным, например &ОтборПравообладателей.
//  ПутьКПолю - Строка - Путь к имени поля таблицы, на которое делается отбор. Вида "ПсевдонимТаблицы.ИмяПоля", т.е.
//  					 через точку, как в запросе. Или просто "ИмяПоля", если не нужен псевдоним (одна таблица в
//  					 запросе).
//  ИмяПараметра - Строка - Имя параметра запроса без "&" впереди, который необходимо установить.
//  ЗначениеПараметра - Массив Из ЛюбаяСсылка - Значения для отбора. Если значение одно, то ставится равенство.
//					  - Неопределено - Не указан, отбор устанавливать не надо, в запросе подменится на "ИСТИНА".
Процедура ПодменитьОтборПоПолюВЗапросе(
	Запрос, ЧтоПодменить, ПутьКПолю, ИмяПараметра, ЗначениеПараметра) Экспорт
	
	НаЧтоПодменить = "ИСТИНА";
	Если ЗначениеПараметра = Неопределено Тогда
		// Нет отбора.
	ИначеЕсли ЗначениеПараметра.Количество() = 1 Тогда
		НаЧтоПодменить = СтрШаблон("%1 = &%2", ПутьКПолю, ИмяПараметра);
		Запрос.УстановитьПараметр(ИмяПараметра, ЗначениеПараметра[0]);
	Иначе
		НаЧтоПодменить = СтрШаблон("%1 В (&%2)", ПутьКПолю, ИмяПараметра);
		Запрос.УстановитьПараметр(ИмяПараметра, ЗначениеПараметра);
	КонецЕсли;
	Запрос.Текст = СтрЗаменить(Запрос.Текст, ЧтоПодменить, НаЧтоПодменить);
	
КонецПроцедуры

// Обертка. Возвращает структуру из результата запроса, который ожидается, что вернет 1 строку, или не вернет ничего. 
// Если больше, то учитывается только первая строка.
// 
// Параметры:
//  РезультатЗапроса - РезультатЗапроса
// 
// Возвращаемое значение:
//  Структура - Структура из полей результата запроса, если результат пустой, то все поля = Неопределено.
Функция РезультатЗапросаВСтруктуру(РезультатЗапроса) Экспорт
	
	Данные = Новый Структура();
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		Данные.Вставить(Колонка.Имя, Неопределено);
	КонецЦикла;
	
	Выборка = РезультатЗапроса.Выбрать();
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Данные, Выборка);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Возвращает строку, не превышающую допустимую длину.
// Если строка превышает допустимую длину, то лишние символы справа вырезаются
// и вместо них вставляется MD5 хеш-сумма строки.
//
// Параметры:
//  ИсходнаяСтрока  - Строка - Исходная строка.
//  ДопустимаяДлина - Число  - Максимальная допустимая длина строки. Не может быть меньше 32 символов.
// 
// Возвращаемое значение:
//  Строка - Строка, не превышающая допустимую длину.
//
Функция СтрХеш(ИсходнаяСтрока, ДопустимаяДлина) Экспорт
	
	Если ДопустимаяДлина < 32 Тогда
		ВызватьИсключение НСтр("ru = 'Допустимая длина не может быть меньше 32 символов.'");
	КонецЕсли;
	
	Если СтрДлина(ИсходнаяСтрока) <= ДопустимаяДлина Тогда
		Возврат ИсходнаяСтрока;
	КонецЕсли;
	
	ДлинаХешаMD5 = 32;
	СохраняемаяЧастьСтроки = Лев(ИсходнаяСтрока, ДопустимаяДлина - ДлинаХешаMD5);
	ВырезаемаяЧастьСтроки = Сред(ИсходнаяСтрока, ДопустимаяДлина - ДлинаХешаMD5 + 1);
	
	ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
	ХешированиеДанных.Добавить(ВырезаемаяЧастьСтроки);
	ХешВырезаемойЧастиИмениФормы = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	СокращеннаяСтрока = СохраняемаяЧастьСтроки + ХешВырезаемойЧастиИмениФормы;
	
	Возврат СокращеннаяСтрока;
	
КонецФункции

// Возвращает таблицу значений из макета.
//
// Параметры:
//  ДанныеМакета - ТабличныйДокумент - Данные макета.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица значений, хранящаяся в макете.
//
Функция ТаблицаЗначенийИзМакета(ДанныеМакета) Экспорт
	
	НомерПоследнейКолонки = 0;
	ТекущийНомерКолонки = 1;
	ИмяКолонкиЗаполнено = Истина;
	Пока ИмяКолонкиЗаполнено Цикл
		
		ТекстЯчейки = ДанныеМакета.Область(1, ТекущийНомерКолонки).Текст;
		ИмяКолонкиЗаполнено = ЗначениеЗаполнено(ТекстЯчейки);
		Если ИмяКолонкиЗаполнено Тогда
			НомерПоследнейКолонки = ТекущийНомерКолонки;
		КонецЕсли;
		
		ТекущийНомерКолонки = ТекущийНомерКолонки + 1;
		
	КонецЦикла;
	Если НомерПоследнейКолонки = 0 Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	
	ОбластьЗаголовков = ДанныеМакета.Область(0, 1, 0, НомерПоследнейКолонки);
	
	Построитель = Новый ПостроительЗапроса;
	Построитель.ИсточникДанных = Новый ОписаниеИсточникаДанных(ОбластьЗаголовков);
	Построитель.Выполнить();
	
	Возврат Построитель.Результат.Выгрузить();
	
КонецФункции

// Возвращает таблицу значений по метаданным табличной части.
// 
// Пример:
//  ТаблицаЭтапы = ТаблицаЗначенийПоМетаданнымТабличнойЧасти(
//  	Метаданные.БизнесПроцессы.КомплексныйПроцесс.ТабличныеЧасти.Этапы);
// 
// Параметры:
//  МетаданныеТаблицы - метаданные табличной части.  
// 
// Возвращаемое значение:
//  ТаблицаЗначений
//   * Наименования и типы реквизитов соответствуют метаданным табличной части.
//  
Функция ТаблицаЗначенийПоМетаданнымТабличнойЧасти(МетаданныеТаблицы) Экспорт
	
	ТаблицаЗначений = Новый ТаблицаЗначений();
	
	Для Каждого РеквизитТаблицы Из МетаданныеТаблицы.Реквизиты Цикл
		ТаблицаЗначений.Колонки.Добавить(РеквизитТаблицы.Имя, РеквизитТаблицы.Тип);			
	КонецЦикла;
	
	Возврат ТаблицаЗначений;
	
КонецФункции

// Считывает предыдущие значения из базы данных. Для пустой ссылки возвращает значения реквизитов по умолчанию.
//
// Параметры:
//  Ссылка                 - ЛюбаяСсылка - Ссылка, для которой необходимо получить предыдущие значения реквизитов.
//  ОтслеживаемыеРеквизиты - Строка      - Отслеживаемые реквизиты, через запятую.
// 
// Возвращаемое значение:
//  Структура - Предыдущие значения реквизитов.
//
Функция ПредыдущиеЗначенияРеквизитов(Ссылка, ОтслеживаемыеРеквизиты) Экспорт
	
	ПредыдущиеЗначенияРеквизитов = Новый Структура;
	Если Не ЗначениеЗаполнено(ОтслеживаемыеРеквизиты) Тогда
		Возврат ПредыдущиеЗначенияРеквизитов;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ЗначениеЗаполнено(Ссылка) Тогда
		
		ПредыдущиеЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, ОтслеживаемыеРеквизиты);
		Для Каждого КлючИЗначение Из ПредыдущиеЗначенияРеквизитов Цикл
			Если ТипЗнч(КлючИЗначение.Значение) = Тип("РезультатЗапроса") Тогда
				ПредыдущиеЗначенияРеквизитов[КлючИЗначение.Ключ] = КлючИЗначение.Значение.Выгрузить();
				ПредыдущиеЗначенияРеквизитов[КлючИЗначение.Ключ].Сортировать("НомерСтроки Возр");
				ПредыдущиеЗначенияРеквизитов[КлючИЗначение.Ключ].Колонки.Удалить("Ссылка");
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		ОбъектМетаданныхСсылки = Ссылка.Метаданные();
		
		ОписанияТиповРеквизитов = Новый Соответствие;
		Для Каждого ОбъектМетаданныхРеквизита Из ОбъектМетаданныхСсылки.Реквизиты Цикл
			ОписанияТиповРеквизитов.Вставить(ОбъектМетаданныхРеквизита.Имя, ОбъектМетаданныхРеквизита.Тип);
		КонецЦикла;
		Для Каждого ОбъектМетаданныхРеквизита Из ОбъектМетаданныхСсылки.СтандартныеРеквизиты Цикл
			ОписанияТиповРеквизитов.Вставить(ОбъектМетаданныхРеквизита.Имя, ОбъектМетаданныхРеквизита.Тип);
		КонецЦикла;
		Если ОбщегоНазначения.ЭтоЗадача(ОбъектМетаданныхСсылки) Тогда
			
			Для Каждого ОбъектМетаданныхРеквизита Из ОбъектМетаданныхСсылки.РеквизитыАдресации Цикл
				ОписанияТиповРеквизитов.Вставить(ОбъектМетаданныхРеквизита.Имя, ОбъектМетаданныхРеквизита.Тип);
			КонецЦикла;
			
		КонецЕсли;
		
		ПредыдущиеЗначенияРеквизитов = Новый Структура;
		Для Каждого ОтслеживаемыйРеквизит Из СтрРазделить(ОтслеживаемыеРеквизиты, ",") Цикл
			
			ОтслеживаемыйРеквизит = СокрЛП(ОтслеживаемыйРеквизит);
			
			ОписаниеТипаРеквизита = ОписанияТиповРеквизитов[ОтслеживаемыйРеквизит];
			Если ОписаниеТипаРеквизита <> Неопределено Тогда
				ЗначениеРеквизитаПоУмолчанию = ОписаниеТипаРеквизита.ПривестиЗначение(Неопределено);
			Иначе
				
				// Описание типа реквизита не найдено. Возможно это табличная часть.
				ЗначениеРеквизитаПоУмолчанию = Неопределено;
				Для Каждого ОбъектМетаданныхТабличнойЧасти Из ОбъектМетаданныхСсылки.ТабличныеЧасти Цикл
					
					Если ОбъектМетаданныхТабличнойЧасти.Имя <> ОтслеживаемыйРеквизит Тогда
						Продолжить;
					КонецЕсли;
					
					ЗначениеРеквизитаПоУмолчанию = Новый ТаблицаЗначений;
					ЗначениеРеквизитаПоУмолчанию.Колонки.Добавить(
						ОбъектМетаданныхСсылки.СтандартныеРеквизиты.Ссылка.Имя,
						ОбъектМетаданныхСсылки.СтандартныеРеквизиты.Ссылка.Тип);
					
					Для Каждого ОбъектМетаданныхРеквизита Из ОбъектМетаданныхТабличнойЧасти.Реквизиты Цикл
						ЗначениеРеквизитаПоУмолчанию.Колонки.Добавить(
							ОбъектМетаданныхРеквизита.Имя,
							ОбъектМетаданныхРеквизита.Тип);
					КонецЦикла;
					Для Каждого ОбъектМетаданныхРеквизита Из ОбъектМетаданныхТабличнойЧасти.СтандартныеРеквизиты Цикл
						ЗначениеРеквизитаПоУмолчанию.Колонки.Добавить(
							ОбъектМетаданныхРеквизита.Имя,
							ОбъектМетаданныхРеквизита.Тип);
					КонецЦикла;
					
				КонецЦикла;
				Если ЗначениеРеквизитаПоУмолчанию = Неопределено Тогда
					ТекстОшибки = СтрШаблон(
						НСтр("ru = 'Не найден отслеживаемый реквизит:
							|Метаданные: %1
							|Реквизит: %2'"),
						ОбъектМетаданныхСсылки.ПолноеИмя(),
						ОтслеживаемыйРеквизит);
					ВызватьИсключение ТекстОшибки;
				КонецЕсли;
				
			КонецЕсли;
			
			ПредыдущиеЗначенияРеквизитов.Вставить(ОтслеживаемыйРеквизит, ЗначениеРеквизитаПоУмолчанию);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ПредыдущиеЗначенияРеквизитов;
	
КонецФункции

// Формирует структуру данных объекта.
//
// Параметры:
//  Объект - Любой объект - Объект.
// 
// Возвращаемое значение:
//  Структура - Данные объекта.
//
Функция ДанныеОбъекта(Объект) Экспорт
	
	ДанныеОбъекта = Новый Структура;
	МетаданныеОбъекта = Объект.Метаданные();
	
	Для Каждого СтандартныйРеквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		ДанныеОбъекта.Вставить(СтандартныйРеквизит.Имя, Объект[СтандартныйРеквизит.Имя]);
	КонецЦикла;
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		ДанныеОбъекта.Вставить(Реквизит.Имя, Объект[Реквизит.Имя]);
	КонецЦикла;
	
	Если ОбщегоНазначения.ЭтоЗадача(МетаданныеОбъекта) Тогда
		Для Каждого РеквизитАдресации Из МетаданныеОбъекта.РеквизитыАдресации Цикл
			ДанныеОбъекта.Вставить(РеквизитАдресации.Имя, Объект[РеквизитАдресации.Имя]);
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
		ДанныеОбъекта.Вставить(ТабличнаяЧасть.Имя, Объект[ТабличнаяЧасть.Имя].Выгрузить());
	КонецЦикла;
	
	Возврат ДанныеОбъекта;
	
КонецФункции

// Формирует представление даты. Даты этого года отображаются без года. Даты других лет отображаются с годом.
//
// Параметры:
//  Дата - Дата - Дата.
// 
// Возвращаемое значение:
//  Строка - Представление даты.
//
Функция ПредставлениеДаты(Дата) Экспорт
	
	Если Не ЗначениеЗаполнено(Дата) Тогда
		Возврат "";
	КонецЕсли;
	
	ФорматДаты = ?(НачалоГода(Дата) = НачалоГода(ТекущаяДатаСеанса()),
		НСтр("ru = 'ДФ=dd.MM'"),
		НСтр("ru = 'ДФ=dd.MM.yyyy'"));
	
	ПредставлениеДаты = Формат(Дата, ФорматДаты);
	
	Возврат ПредставлениеДаты;
	
КонецФункции

// Дополняет отслеживаемые реквизиты.
//
// Параметры:
//  Приемник - Строка - Отслеживаемые реквизиты, в которые необходимо добавить значения.
//  Источник - Строка - Отслеживаемые реквизиты, которые необходимо добавить.
//
Процедура ДополнитьОтслеживаемыеРеквизиты(Приемник, Источник) Экспорт
	
	МассивПриемник = МассивРеквизитов(Приемник);
	МассивИсточник = МассивРеквизитов(Источник);
	
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(МассивПриемник, МассивИсточник, Истина);
	
	Приемник = СтрокаРеквизитов(МассивПриемник);
	
КонецПроцедуры

// Меняет форму начальной страницы.
//
// Параметры:
//  ПрежнееИмяФормы - Строка - Прежнее имя формы.
//  НовоеИмяФормы - Строка - Новое имя формы.
// 
// Возвращаемое значение:
//  Булево - Форма начальной страницы заменена.
//
Функция ЗаменитьФормуНачальнойСтраницы(ПрежнееИмяФормы, НовоеИмяФормы) Экспорт
	
	ФормаНачальнойСтраницыЗаменена = Ложь;
	
	НастройкиНачальнойСтраницы = ХранилищеСистемныхНастроек.Загрузить("Общее/НастройкиНачальнойСтраницы");
	Если НастройкиНачальнойСтраницы = Неопределено Тогда
		Возврат ФормаНачальнойСтраницыЗаменена;
	КонецЕсли;
	
	СоставФорм = НастройкиНачальнойСтраницы.ПолучитьСоставФорм();
	
	Для Индекс = 0 По СоставФорм.ЛеваяКолонка.ВГраница() Цикл
		
		Если СоставФорм.ЛеваяКолонка[Индекс] <> ПрежнееИмяФормы Тогда
			Продолжить;
		КонецЕсли;
		
		СоставФорм.ЛеваяКолонка[Индекс] = НовоеИмяФормы;
		
		ФормаНачальнойСтраницыЗаменена = Истина;
		
	КонецЦикла;
	
	Для Индекс = 0 По СоставФорм.ПраваяКолонка.ВГраница() Цикл
		
		Если СоставФорм.ПраваяКолонка[Индекс] <> ПрежнееИмяФормы Тогда
			Продолжить;
		КонецЕсли;
		
		СоставФорм.ПраваяКолонка[Индекс] = НовоеИмяФормы;
		
		ФормаНачальнойСтраницыЗаменена = Истина;
		
	КонецЦикла;
	
	НастройкиНачальнойСтраницы.УстановитьСоставФорм(СоставФорм);
	
	ХранилищеСистемныхНастроек.Сохранить(
		"Общее/НастройкиНачальнойСтраницы",,
		НастройкиНачальнойСтраницы);
	
	Возврат ФормаНачальнойСтраницыЗаменена;
	
КонецФункции

// Преобразует массив в таблицу значений. Элементами массив должны быть структуры.
//
// Параметры:
//  Массив - Массив из Структура.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица значений из массив.
//
Функция МассивСтруктурВТаблицуЗначений(Массив) Экспорт
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	Для Каждого ЭлементМассива Из Массив Цикл
		
		Если ТипЗнч(ЭлементМассива) <> Тип("Структура") Тогда
			ВызватьИсключение СтрШаблон(
				НСтр("ru = 'Неожиданный элемент массива %1 (%2)'"),
				ЭлементМассива,
				ТипЗнч(ЭлементМассива));
		КонецЕсли;
		
		СтрокаТаблицы = ТаблицаЗначений.Добавить();
		Для Каждого КлючИЗначение Из ЭлементМассива Цикл
			
			ИмяСвойства = КлючИЗначение.Ключ;
			ЗначениеСвойства = КлючИЗначение.Значение;
			
			Если ТаблицаЗначений.Колонки.Найти(ИмяСвойства) = Неопределено Тогда
				ТаблицаЗначений.Колонки.Добавить(ИмяСвойства);
			КонецЕсли;
			
			СтрокаТаблицы[ИмяСвойства] = ЗначениеСвойства;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ТаблицаЗначений;

КонецФункции

// Возвращает подчиненные элементы по иерархии, которые не являются группами и не помечены на удаление.
//
// Параметры:
//  Родитель - СправочникСсылка.
//  ИмяРеквизитаЭтоГруппа - Строка.
// 
// Возвращаемое значение:
//  Массив из СправочникСсылка - Все подчиненные элементы родителя, не являющиеся группой и не помеченные на удаление.
//
Функция ПодчиненныеЭлементы(Родитель, ИмяРеквизитаЭтоГруппа = "ЭтоГруппа") Экспорт
	
	ПодчиненныеЭлементы = Новый Массив;
	Если Не ЗначениеЗаполнено(Родитель) Тогда
		Возврат ПодчиненныеЭлементы;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка КАК Ссылка
		|ИЗ
		|	&Таблица КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка В ИЕРАРХИИ(&Родитель)
		|	И ПсевдонимЗаданнойТаблицы.ПометкаУдаления = ЛОЖЬ
		|	И &ИмяРеквизитаЭтоГруппа = ЛОЖЬ";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Таблица", Родитель.Метаданные().ПолноеИмя());
	Запрос.Текст = СтрЗаменить(
		Запрос.Текст, "&ИмяРеквизитаЭтоГруппа", "ПсевдонимЗаданнойТаблицы." + ИмяРеквизитаЭтоГруппа);
	
	Запрос.УстановитьПараметр("Родитель", Родитель);
	
	ПодчиненныеЭлементы = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
	Возврат ПодчиненныеЭлементы;
	
КонецФункции

// Определяет, изменилось ли значение реквизита, по сравнению с предыдущим значением.
//
// Параметры:
//  Объект - Любой объект - Объект.
//  ПроверяемыеРеквизиты - Строка - Проверяемые реквизиты, через запятую.
//  ИсключаемыеКолонки - Строка.
// 
// Возвращаемое значение:
//  Булево - Изменилось значение реквизитов.
//
Функция ИзменилосьЗначениеРеквизитов(Объект, ПроверяемыеРеквизиты, ИсключаемыеКолонки = "") Экспорт
	
	Если Не Объект.ДополнительныеСвойства.Свойство("ПредыдущиеЗначенияРеквизитов") Тогда
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Предыдущие значения реквизитов объекта %1 (%2) не инициализированы.
				|Для инициализации необходимо вызвать процедуру УстановитьДополнительноеСвойствоПредыдущиеЗначенияРеквизитов.'"),
			Объект,
			ТипЗнч(Объект));
	КонецЕсли;
	
	ПредыдущиеЗначенияРеквизитов = Объект.ДополнительныеСвойства.ПредыдущиеЗначенияРеквизитов;
	
	ИзменилосьЗначениеРеквизитов = Ложь;
	Для Каждого ПроверяемыйРеквизит Из СтрРазделить(ПроверяемыеРеквизиты, ",") Цикл
		
		ПроверяемыйРеквизит = СокрЛП(ПроверяемыйРеквизит);
		
		Если Не ПредыдущиеЗначенияРеквизитов.Свойство(ПроверяемыйРеквизит) Тогда
			ВызватьИсключение СтрШаблон(
				НСтр("ru = 'Невозможно проверить изменение реквизита %1 для объекта %2, т.к. данный реквизит не отслеживается.
					|Укажите данный реквизит в функции ОтслеживаемыеРеквизиты.'"),
				ПроверяемыйРеквизит,
				ТипЗнч(Объект));
		КонецЕсли;
		
		ТекущееЗначение = Объект[ПроверяемыйРеквизит];
		ПредыдущееЗначение = ПредыдущиеЗначенияРеквизитов[ПроверяемыйРеквизит];
		
		Если ТипЗнч(ПредыдущееЗначение) = Тип("ТаблицаЗначений")
			И Не ТаблицыЗначенийИдентичны(ТекущееЗначение.Выгрузить(), ПредыдущееЗначение, ИсключаемыеКолонки) Тогда
			
			ИзменилосьЗначениеРеквизитов = Истина;
			Прервать;
			
		ИначеЕсли ТипЗнч(ПредыдущееЗначение) <> Тип("ТаблицаЗначений")
			И ТекущееЗначение <> ПредыдущееЗначение Тогда
			
			ИзменилосьЗначениеРеквизитов = Истина;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ИзменилосьЗначениеРеквизитов;
	
КонецФункции

// Возвращает Истину, если клиентское приложение является веб клиентом,
// иначе Ложь.
//
Функция ПриложениеЯвляетсяВебКлиентом() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	Возврат ЗначениеЗаполнено(СистемнаяИнформация.ИнформацияПрограммыПросмотра);
	
КонецФункции

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект. Выполняется в привилегированном режиме.
// 
Функция ЗначенияРеквизитовОбъектаВПривилегированномРежиме(Ссылка, Реквизиты, ВыбратьРазрешенные = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты, ВыбратьРазрешенные);
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// Выполняется в привилегированном режиме.
//
Функция ЗначениеРеквизитаОбъектаВПривилегированномРежиме(Ссылка, ИмяРеквизита, ВыбратьРазрешенные = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные);
	
КонецФункции 

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы
// для нескольких объектов. Выполняется в привилегированном режиме.
// 
Функция ЗначенияРеквизитовОбъектовВПривилегированномРежиме(МассивСсылок, ИменаРеквизитов, ВыбратьРазрешенные = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат ОбщегоНазначения.ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов, ВыбратьРазрешенные);
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// Выполняется в привилегированном режиме.
//
Функция ЗначениеРеквизитаОбъектовВПривилегированномРежиме(МассивСсылок, ИмяРеквизита, ВыбратьРазрешенные = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита, ВыбратьРазрешенные = Ложь);
	
КонецФункции

// Получает текущую дату в миллисекундах
//  
// Параметры:
//  ДатаВремя - Дата - преобразуемая дата
//
// Возвращаемое значение:
//  Число - количество миллисекунд, прошедших от 01.01.0001 00:00:00 до текущей даты
// 
Функция ТекущаяДатаВМиллисекундах() Экспорт

	Возврат ТекущаяУниверсальнаяДатаВМиллисекундах() + (ТекущаяДата() - ТекущаяУниверсальнаяДата()) * 1000;
			
КонецФункции

// Получает дату в миллисекундах
//
// Параметры:
//  ДатаВремя - Дата - преобразуемая дата
//
// Возвращаемое значение:
//  Число - количество миллисекунд, прошедших от 01.01.0001 00:00:00 до переданной даты (на начало секунды)
// 
Функция ДатаВМиллисекундах(ДатаВремя) Экспорт
	
	ПустаяДата = Дата('00010101000000');
	Результат = (ДатаВремя - ПустаяДата) * 1000;
	
	Возврат Результат;
	
КонецФункции

// Преобразует дату в миллисекундах в дату
//
// Параметры:
//  ДатаВМиллисекундах - количество миллисекунд начиная с 01.01.0001 00:00:00
//
// Возвращаемое значение:
//  Дата
// 
Функция ПреобразоватьМиллисекундыВДату(ДатаВМиллисекундах) Экспорт
	
	ПустаяДата = Дата('00010101000000');
	Результат = ПустаяДата + ДатаВМиллисекундах / 1000;
	
	Возврат Результат;
	
КонецФункции

// Возвращает массив результататов запроса. 
// Каждый результат содержит выборку по одной из временных таблиц с именем, входящим в массив ИменаТаблиц.
// 
// Индексы результатов соответствуют индексам имен ВТ в массиве ИменаТаблиц.
// Если временная таблица не была найдена в запросе, 
// то по соответствующем индексу будет возвращено Неопределено вместо результата запроса.
// 
Функция ДанныеИзВременныхТаблицЗапроса(БазовыйЗапрос, ИменаТаблиц) Экспорт
	
	Данные = Новый Массив;
	
	// Формирование запроса, который выберет информацию из нужных временных таблиц
	МВТ = Новый МенеджерВременныхТаблиц;
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МВТ;
	
	НомерПодзапроса = 0;
	НомераПодзапросов = Новый Соответствие;
	
	Для Каждого ИмяТаблицы Из ИменаТаблиц Цикл
		
		Данные.Добавить(Неопределено);
		
		Если Найти(БазовыйЗапрос.Текст, "ПОМЕСТИТЬ " + ИмяТаблицы) = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Запрос.Текст = Запрос.Текст + ?(Запрос.Текст = "", "", "
		|;
		|////////////////////////////////////////////////////////////////////////////////
		|")
		+ "ВЫБРАТЬ * ИЗ " + ИмяТаблицы;
		
		НомераПодзапросов.Вставить(ИмяТаблицы, НомерПодзапроса);
		НомерПодзапроса = НомерПодзапроса + 1;
		
	КонецЦикла;
	
	Если Не ЗначениеЗаполнено(Запрос.Текст) Тогда
		Возврат Данные;
	КонецЕсли;
	
	// Выполнение запроса для заполнения временных таблиц
	БазовыйЗапрос.МенеджерВременныхТаблиц = МВТ;
	БазовыйЗапрос.Выполнить();
	
	// Формирование результата
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	Для Сч = 0 По ИменаТаблиц.Количество() - 1 Цикл
		
		ИмяТаблицы = ИменаТаблиц[Сч];
		НомерПодзапроса = НомераПодзапросов.Получить(ИмяТаблицы);
		
		Если НомерПодзапроса <> Неопределено Тогда
			Данные[Сч] = РезультатыЗапросов[НомерПодзапроса];
		КонецЕсли;
		
	КонецЦикла;
	
	МВТ.Закрыть();
	
	Возврат Данные;
	
КонецФункции

// Устаналивает стандартные цвета диаграмм отчета.
//
// Параметры:
//   ДокументРезультат - ТабличныйДокумент - оформляемый результат отчета.
//
Процедура УстановитьЦветаДиаграмм(ДокументРезультат) Экспорт
	
	Для Каждого Рисунок из ДокументРезультат.Рисунки Цикл
		Если Рисунок.ТипРисунка = ТипРисункаТабличногоДокумента.Диаграмма Тогда
			УстановитьЦветаДиаграммы(Рисунок.Объект);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, загружается ли объект из узла РИБ. Предназначена для вызова из обработчиков событий
// ПередЗаписью и ПриЗаписи модулей объектов, а также в обработчиках подписок на события. Объект,
// загружаемый не из узла РИБ, требует обновления связанных данных. Объект, загружаемый из узла
// РИБ, загружается вместе со связанными данными, заполненными при его записи в узле-источнике.
//
// Параметры:
//   Объект - Произвольный - записываемый объект.
//
// Возвращаемое значение:
//   Булево - Истина, если объект загружается из узла РИБ, и Ложь в противном случае.
//
Функция ЭтоЗагрузкаИзУзлаРИБ(Объект) Экспорт
	
	Возврат Ложь;
	
КонецФункции

// Проверяет наличие метода менеджера объекта.
// Для проверки используется дополнительный метод "ЕстьМетод<ИмяМетода>".
//
// Параметры:
//  МенеджерОбъекта - СправочникМенеджер, ДокументМенеджер и т.п.
//  ИмяМетода - Строка - имя метода, наличие которого нужно проверить.
//
// Возвращаемое значение:
//  Булево - Истина, если есть метод, Ложь в противном случае.
//
Функция ЕстьМетодМенеджера(МенеджерОбъекта, ИмяМетода) Экспорт
	
	ПолноеИмя = МенеджерОбъекта.ПустаяСсылка().Метаданные().ПолноеИмя();
	
	Возврат ОбщегоНазначенияДокументооборотПовтИсп.ЕстьМетодМенеджера(ПолноеИмя, ИмяМетода);
	
КонецФункции

// Устанавливает дополнительное свойство ЭтоНовый.
//
// Параметры:
//  Объект - Любой объект - Объект.
//
Процедура УстановитьДополнительноеСвойствоЭтоНовый(Объект) Экспорт
	
	Объект.ДополнительныеСвойства.Вставить("ЭтоНовый", Объект.ЭтоНовый());
	
КонецПроцедуры

// Устанавливает дополнительное свойство ПредыдущиеЗначенияРеквизитов.
//
// Параметры:
//  Объект - Любой объект - Объект.
//
Процедура УстановитьДополнительноеСвойствоПредыдущиеЗначенияРеквизитов(Объект) Экспорт
	
	УстановитьДополнительноеСвойствоЭтоНовый(Объект);
	
	Если Объект.ДополнительныеСвойства.Свойство("ВерсияДанныхПредыдущихЗначенийРеквизитов")
		И Объект.ВерсияДанных = Объект.ДополнительныеСвойства.ВерсияДанныхПредыдущихЗначенийРеквизитов Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
	ОтслеживаемыеРеквизиты = МенеджерОбъекта.ОтслеживаемыеРеквизиты();
	ПредыдущиеЗначенияРеквизитов = ПредыдущиеЗначенияРеквизитов(Объект.Ссылка, ОтслеживаемыеРеквизиты);
	
	Объект.ДополнительныеСвойства.Вставить("ПредыдущиеЗначенияРеквизитов", ПредыдущиеЗначенияРеквизитов);
	Объект.ДополнительныеСвойства.Вставить("ВерсияДанныхПредыдущихЗначенийРеквизитов", Объект.ВерсияДанных);
	
КонецПроцедуры

// Возвращает массив всех родителей переданного элемента.
// 
// Параметры:
//  Ссылка - СправочникСсылка - ссылка на элемент иерархического справочника.
//
// Возвращаемое значение:
//  Массив - массив родителей элемента по всей иерархии, отсортированный по старшинству в порядке возрастания.
//  Если родителей нет, то пустой массив.
//
Функция ВсеРодителиЭлемента(Ссылка) Экспорт
	
	Результат = Новый Массив;
	
	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		Возврат Результат;
	КонецЕсли;
	
	ТекстЗапроса =
		"ВЫБРАТЬ
		|	ТаблицаСправочника.Родитель КАК Родитель1,
		|	ТаблицаСправочника.Родитель.Родитель КАК Родитель2,
		|	ТаблицаСправочника.Родитель.Родитель.Родитель КАК Родитель3
		|ИЗ
		|	&ТаблицаСправочника КАК ТаблицаСправочника
		|ГДЕ
		|	ТаблицаСправочника.Ссылка = &Ссылка";
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "&ТаблицаСправочника", Ссылка.Метаданные().ПолноеИмя());
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	ПрекратитьОбработку = Ложь;
	Пока Не ПрекратитьОбработку Цикл
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			
			Если ЗначениеЗаполнено(Выборка.Родитель1) Тогда
				Результат.Добавить(Выборка.Родитель1);
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Выборка.Родитель2) Тогда
				Результат.Добавить(Выборка.Родитель2);
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Выборка.Родитель3) Тогда
				Результат.Добавить(Выборка.Родитель3);
				Запрос.УстановитьПараметр("Ссылка", Выборка.Родитель3);
			Иначе
				ПрекратитьОбработку = Истина;
			КонецЕсли;
		Иначе
			ПрекратитьОбработку = Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Помещает выделенные строки табличной части в буфер обмена.
// Параметры:
//  ТабличнаяЧасть   - ДанныеФормыКоллекция - Табличная часть, строки которой
//                     необходимо поместить в буфер обмена.
//  ВыделенныеСтроки - Массив - Массив идентификаторов выделенных строк.
//  Источник         - Строка - Имя объекта, строки табличной части которого
//                     помещаются в буфер обмена.
//
Процедура СкопироватьФайлыВБуферОбменаИзТаблицыФайлы(ТабличнаяЧасть, ВыделенныеСтроки, Источник = Неопределено) Экспорт
	
	Если ВыделенныеСтроки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МассивФайлов = Новый Массив;
	
	Для Каждого ИдентификаторСтроки Из ВыделенныеСтроки Цикл
		КопируемаяСтрока = ТабличнаяЧасть.НайтиПоИдентификатору(ИдентификаторСтроки);
		МассивФайлов.Добавить(КопируемаяСтрока.Ссылка);


	КонецЦикла;
	
	ТекущийБуферОбмена = ПараметрыСеанса.БуферОбмена;
	
	Если ЗначениеЗаполнено(ТекущийБуферОбмена.Данные) Тогда
		Адрес = ТекущийБуферОбмена.Данные;
	Иначе
		Адрес = Новый УникальныйИдентификатор;
	КонецЕсли;
	
	ДанныеВХранилище = ПоместитьВоВременноеХранилище(МассивФайлов, Адрес);
	
	СтруктураБуфераОбмена = Новый Структура;
	СтруктураБуфераОбмена.Вставить("Источник", Источник);
	СтруктураБуфераОбмена.Вставить("Данные", ДанныеВХранилище);
	
	ПараметрыСеанса.БуферОбмена = Новый ФиксированнаяСтруктура(СтруктураБуфераОбмена);
	
КонецПроцедуры

// Помещает выделенные строки табличной части в буфер обмена.
// Параметры:
//  ТабличнаяЧасть   - ДанныеФормыКоллекция - Табличная часть, строки которой
//                     необходимо поместить в буфер обмена.
//  ВыделенныеСтроки - Массив - Массив идентификаторов выделенных строк.
//  Источник         - Строка - Имя объекта, строки табличной части которого
//                     помещаются в буфер обмена.
//
Процедура СкопироватьФайлыВБуферОбменаИзСпискаФайлов(ВыделенныеСтроки, Источник = Неопределено) Экспорт
	
	Если ВыделенныеСтроки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МассивФайлов = Новый Массив;
	
	Для Каждого СсылкаФайла Из ВыделенныеСтроки Цикл
		МассивФайлов.Добавить(СсылкаФайла);
	КонецЦикла;
	
	ТекущийБуферОбмена = ПараметрыСеанса.БуферОбмена;
	
	Если ЗначениеЗаполнено(ТекущийБуферОбмена.Данные) Тогда
		Адрес = ТекущийБуферОбмена.Данные;
	Иначе
		Адрес = Новый УникальныйИдентификатор;
	КонецЕсли;
	
	ДанныеВХранилище = ПоместитьВоВременноеХранилище(МассивФайлов, Адрес);
	
	СтруктураБуфераОбмена = Новый Структура;
	СтруктураБуфераОбмена.Вставить("Источник", Источник);
	СтруктураБуфераОбмена.Вставить("Данные", ДанныеВХранилище);
	
	ПараметрыСеанса.БуферОбмена = Новый ФиксированнаяСтруктура(СтруктураБуфераОбмена);
	
КонецПроцедуры

// Выдялет слова поиска в представлении данных.
//
// Параметры:
//  Данные - СписокЗначений - Данные.
//  СловаПоиска - Массив - Слова поиска.
//
// Возвращаемое значение:
//  СписокЗначений - Данные с выделенными словами поиска.
//
Функция ВыделитьСловаПоиска(Данные, СловаПоиска) Экспорт
	
	ВыделенныеДанные = Новый СписокЗначений;
	Если СловаПоиска.Количество() = 0 Тогда
		Возврат ВыделенныеДанные;
	КонецЕсли;
	
	Для Каждого ЭлементДанных Из Данные Цикл
		Представление = ФорматированныйРезультатПоиска(ЭлементДанных.Представление, СловаПоиска);
		ВыделенныеДанные.Добавить(ЭлементДанных.Значение, Представление);
	КонецЦикла;
	
	Возврат ВыделенныеДанные;
	
КонецФункции

// Формирует форматированный результат поиска по словам.
//
// Параметры:
//  РезультатПоиска - Строка - Строка результат поиска.
//  СловаПоиска - Массив - Слова поиска.
// 
// Возвращаемое значение:
//  ФорматированнаяСтрока - Форматированная строка результат поиска.
//
Функция ФорматированныйРезультатПоиска(РезультатПоиска, СловаПоиска) Экспорт
	
	Представление = Новый Массив;
	Представление.Добавить(РезультатПоиска);
	Для Каждого СловоПоиска Из СловаПоиска Цикл
		ДлинаСловаПоиска = СтрДлина(СловоПоиска);
		НовоеПредставление = Новый Массив;
		Для Каждого СловоПредставления Из Представление Цикл
			Если ТипЗнч(СловоПредставления) = Тип("ФорматированнаяСтрока") Тогда
				НовоеПредставление.Добавить(СловоПредставления);
				Продолжить;
			КонецЕсли;
			ПозицияСловаПоиска = СтрНайти(НРег(СловоПредставления), НРег(СловоПоиска));
			Если ПозицияСловаПоиска = 0 Тогда
				НовоеПредставление.Добавить(СловоПредставления);
				Продолжить;
			КонецЕсли;
			НовоеПредставление.Добавить(Лев(СловоПредставления, ПозицияСловаПоиска - 1));
			НовоеПредставление.Добавить(Новый ФорматированнаяСтрока(
				Сред(СловоПредставления, ПозицияСловаПоиска, ДлинаСловаПоиска),
				ШрифтыСтиля.ВыделениеТекстаВСпискеВыбораШрифт,
				ЦветаСтиля.ВыделениеТекстаВСпискеВыбораЦвет));
			НовоеПредставление.Добавить(Сред(СловоПредставления, ПозицияСловаПоиска + ДлинаСловаПоиска));
		КонецЦикла;
		Представление = НовоеПредставление;
	КонецЦикла;
	ФорматированныйРезультатПоиска = Новый ФорматированнаяСтрока(Представление);
	
	Возврат ФорматированныйРезультатПоиска;
	
КонецФункции

// Разбивает строку поиска по словам.
//
// Параметры:
//  СтрокаПоиска - Строка - Строка поиска.
// 
// Возвращаемое значение:
//  Массив - Слова поиска.
//
Функция СловаПоиска(СтрокаПоиска) Экспорт
	
	СловаПоиска = СтрРазделить(СтрокаПоиска, " ", Ложь);
	КоличествоЭлементов = СловаПоиска.Количество();
	Для Индекс = 0 По КоличествоЭлементов - 1 Цикл
		СловаПоиска[Индекс] = НРег(СловаПоиска[Индекс]);
	КонецЦикла;
	Для Индекс = 1 По КоличествоЭлементов Цикл
		ПроверяемоеСловоПоиска = СловаПоиска[КоличествоЭлементов - Индекс];
		ЯвляетсяПодстрокойДругогоСлова = Ложь;
		Индекс2 = 0;
		Для Каждого СловоПоиска Из СловаПоиска Цикл
			Если Индекс2 = (КоличествоЭлементов - Индекс) Тогда
				Индекс2 = Индекс2 + 1;
				Продолжить;
			КонецЕсли;
			Если СтрНайти(СловоПоиска, ПроверяемоеСловоПоиска) <> 0 Тогда
				ЯвляетсяПодстрокойДругогоСлова = Истина;
				Прервать;
			КонецЕсли;
			Индекс2 = Индекс2 + 1;
		КонецЦикла;
		Если ЯвляетсяПодстрокойДругогоСлова Тогда
			СловаПоиска.Удалить(КоличествоЭлементов - Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СловаПоиска;
	
КонецФункции

// Находит данные, содержащие слова поиска.
//
// Параметры:
//  Данные - СписокЗначений - Данные.
//  СловаПоиска - Массив - Слова поиска.
// 
// Возвращаемое значение:
//  СписокЗначений - Найденные данные.
//
Функция НайтиПоСловамПоиска(Данные, СловаПоиска) Экспорт
	
	НайденныеДанные = Новый СписокЗначений;
	Если СловаПоиска.Количество() = 0 Тогда
		Возврат НайденныеДанные;
	КонецЕсли;
	
	Для Каждого ЭлементДанных Из Данные Цикл
		
		НайденыВсеСловаПоиска = Истина;
		Для Каждого СловоПоиска Из СловаПоиска Цикл
			Если Не СтрНайти(НРег(ЭлементДанных), СловоПоиска) Тогда
				НайденыВсеСловаПоиска = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если НайденыВсеСловаПоиска Тогда
			НайденныеДанные.Добавить(ЭлементДанных, ЭлементДанных);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НайденныеДанные;
	
КонецФункции

// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
//
// Параметры:
//   Отбор - Структура - содержит значения элементов отбора.
//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором:
//						Ключ - Строка - имя свойства элемента метаданных;
//						Значение - Массив - множество значений для отбора.
//
// Пример инициализации переменной "Отбор":
//
// Массив = Новый Массив;
// Массив.Добавить("Константа.ИспользоватьСинхронизациюДанных");
// Массив.Добавить("Справочник.Валюты");
// Массив.Добавить("Справочник.Организации");
// Отбор = Новый Структура;
// Отбор.Вставить("ПолноеИмя", Массив);
// 
//  Возвращаемое значение:
//   ДеревоЗначений - дерево описания метаданных конфигурации.
//
Функция ДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               НСтр("ru = 'Константы'"),                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             НСтр("ru = 'Справочники'"),               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               НСтр("ru = 'Документы'"),                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", НСтр("ru = 'Планы видов характеристик'"), БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             НСтр("ru = 'Планы счетов'"),              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       НСтр("ru = 'Планы видов расчета'"),       БиблиотекаКартинок.ПланВидовРасчета,       БиблиотекаКартинок.ПланВидовРасчетаОбъект,       КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        НСтр("ru = 'Регистры сведений'"),         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      НСтр("ru = 'Регистры накопления'"),       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     НСтр("ru = 'Регистры бухгалтерии'"),      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         НСтр("ru = 'Регистры расчета'"),          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          НСтр("ru = 'Бизнес-процессы'"),           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  НСтр("ru = 'Задачи'"),                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// Возвращаемое значение функции.
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						ОбъектПрошелФильтр = Ложь;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Удаляем строки без подчиненных элементов.
	Если ИспользоватьОтбор Тогда
		
		// Используем обратный порядок обхода дерева значений.
		КоличествоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КоличествоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КоличествоЭлементовКоллекции - ОбратныйИндекс;
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
	
КонецФункции

// Возвращает имя пользователя ИБ.
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - Пользователь.
//  ДополнительныеПараметры - Структура
//                          - Неопределено
// 
// Возвращаемое значение:
//  Строка, Неопределено - Имя пользователя ИБ.
//
Функция ИмяПользователяИБ(Пользователь, ДополнительныеПараметры = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(Пользователь) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ИдентификаторПользователяИБ = Неопределено;
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура")
		И ДополнительныеПараметры.Свойство("ИдентификаторыПользователейИБ") Тогда
		ИдентификаторПользователяИБ = ДополнительныеПараметры.ИдентификаторыПользователейИБ[Пользователь];
	КонецЕсли;
	Если ИдентификаторПользователяИБ = Неопределено Тогда
		ИдентификаторПользователяИБ =
			ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Пользователь, "ИдентификаторПользователяИБ");
	КонецЕсли;
	ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(ИдентификаторПользователяИБ);
	Если ПользовательИБ = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПользовательИБ.Имя;
	
КонецФункции

// Заполняет имя клиентского приложения (User-Agent), используемое при формировании веб-запросов.
// 
// Возвращаемое значение:
//  Строка - Имя клиентского приложения (User-Agent), используемое при формировании веб-запросов.
//
Функция ИмяКлиентскогоПриложения() Экспорт
	
	Возврат РедакцииКонфигурацииКлиентСервер.ИдентификаторКонфигурации();
	
КонецФункции

// Заполняет данные клиентского приложения, используемые для авторизации в Google.
//
Функция ИдентификацияПриложенияДляGoogle() Экспорт
	
	ИдентификаторПриложения = Новый Структура;
	ИдентификаторПриложения.Вставить("client_id", "");
	ИдентификаторПриложения.Вставить("client_secret", "");
	ИдентификаторПриложения.Вставить("redirect_uri", "http://localhost");
	ИдентификаторПриложения.Вставить("auth_uri", "https://accounts.google.com/o/oauth2/auth");
	ИдентификаторПриложения.Вставить("token_uri", "https://accounts.google.com/o/oauth2/token");
	
	УстановитьПривилегированныйРежим(Истина);
	ИдентификаторПриложения.client_id = Константы.ИдентификаторПриложенияGoogleClientID.Получить();
	ИдентификаторПриложения.client_secret = Константы.ИдентификаторПриложенияGoogleClientSecret.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Если Не ЗначениеЗаполнено(ИдентификаторПриложения.client_id)
		Или Не ЗначениеЗаполнено(ИдентификаторПриложения.client_secret) Тогда
		ИдентификаторПриложения.client_id = "566135723419-pn0f4ps4t4d445udjjks848jaibcubo1.apps.googleusercontent.com";
		ИдентификаторПриложения.client_secret = "8zLIPVs-5TOkP4WkMjbzQ7Ve";
	КонецЕсли;
	
	Возврат ИдентификаторПриложения;
	
КонецФункции

// Проверяет, является ли переданный объект помеченным на удаление.
//
// Параметры:
//  СсылкаНаОбъект - ЛюбаяСсылка - Ссылка на объект.
// 
// Возвращаемое значение:
//  Булево - Переданный объект помечен на удаление.
//
Функция ЭтоПомеченныйНаУдалениеОбъект(СсылкаНаОбъект) Экспорт
	
	СсылкиНаОбъекты = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(СсылкаНаОбъект);
	
	Возврат ЕстьПомеченныеНаУдалениеОбъекты(СсылкиНаОбъекты);
	
КонецФункции

// Проверяет, есть ли среди переданных объектов помеченные на удаление.
//
// Параметры:
//  СсылкиНаОбъекты - Массив - Массив ссылок на объект.
// 
// Возвращаемое значение:
//  Булево - Среди переданных объектов есть помеченные на удаление.
//
Функция ЕстьПомеченныеНаУдалениеОбъекты(СсылкиНаОбъекты) Экспорт
	
	ЕстьПомеченныеНаУдалениеОбъекты = Ложь;
	
	СсылкиНаОбъектыПоТипам =
		ОбщегоНазначенияДокументооборотКлиентСервер.СоответствиеПоТипам(СсылкиНаОбъекты);
	Для Каждого СсылкиНаОбъектыТипа Из
			ОбщегоНазначенияДокументооборотКлиентСервер.ЗначенияСоответствия(СсылкиНаОбъектыПоТипам) Цикл
		
		ПометкиУдаленияОбъектов =
			ОбщегоНазначения.ЗначениеРеквизитаОбъектов(СсылкиНаОбъектыТипа, "ПометкаУдаления");
		Для Каждого ПометкаУдаленияОбъекта Из
				ОбщегоНазначенияДокументооборотКлиентСервер.ЗначенияСоответствия(ПометкиУдаленияОбъектов) Цикл
			
			Если ПометкаУдаленияОбъекта = Истина Тогда
				ЕстьПомеченныеНаУдалениеОбъекты = Истина;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ЕстьПомеченныеНаУдалениеОбъекты;
	
КонецФункции

// Устанавливает стандартное условное оформление списка. Показывает помеченные на удаление зачеркнутым.
//
// Параметры:
//  УсловноеОформление - УсловноеОформлениеКомпоновкиДанных - Содержит настройки условного оформления формы.
//
Процедура УстановитьУсловноеОформлениеСписка(УсловноеОформление, ОсновноеПоле = Неопределено) Экспорт
	
	// Помеченные на удаление элементы.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	Если ЗначениеЗаполнено(ОсновноеПоле) Тогда
		Элемент.Поля.Элементы.Добавить().Поле = Новый ПолеКомпоновкиДанных(ОсновноеПоле);
	КонецЕсли;
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ПометкаУдаления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Истина;
	
	Элемент.Оформление.УстановитьЗначениеПараметра(
		"Шрифт", Новый Шрифт(ШрифтыСтиля.ОбычныйШрифтТекста, , , , , , Истина));
	
КонецПроцедуры

// Устанавливает условное оформление недействительных элементов списка.
//
// Параметры:
//  УсловноеОформление - УсловноеОформлениеКомпоновкиДанных.
//  ОсновноеПоле - Строка.
//
Процедура УстановитьУсловноеОформлениеНедействительных(УсловноеОформление, ОсновноеПоле = Неопределено) Экспорт
	
	// Недействительные элементы.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	Если ЗначениеЗаполнено(ОсновноеПоле) Тогда
		Элемент.Поля.Элементы.Добавить().Поле = Новый ПолеКомпоновкиДанных(ОсновноеПоле);
	КонецЕсли;
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Недействителен");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Истина;
	
	Элемент.Оформление.УстановитьЗначениеПараметра(
		"ЦветТекста",
		ЦветаСтиля.ТекстЗапрещеннойЯчейкиЦвет);
	
КонецПроцедуры

// Шлет письмо по легкой почте и делает запись в журнал регистрации
//
// Параметры
//  КраткоеНаименование - Строка - наименование (Тема письма)
//  ПолноеОписание - Строка - подробное описание (тело письма). К описанию будет добавлен адрес базы
//  ИмяЗаписиЖурналаРегистрации  - Строка - для имени события в журнале регистрации
//
Процедура ЗафиксироватьПроблему(КраткоеНаименование, ПолноеОписание, ИмяЗаписиЖурналаРегистрации) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	АдресПубликацииНаВебСервере = Константы.АдресПубликацииНаВебСервере.Получить();
	
	ПредставлениеБазы = СтрШаблон("%1 / %2",
		ПолучитьПредставлениеИнформационнойБазы(),
		Метаданные.Версия);
	
	ОписаниеПолноеБаза = ПолноеОписание + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '. База: %2.  %3'"),
		АдресПубликацииНаВебСервере, ПредставлениеБазы);
	
	УведомитьОтветственныхОПроблеме(КраткоеНаименование, ОписаниеПолноеБаза, ИмяЗаписиЖурналаРегистрации);
	
КонецПроцедуры	

// Сравнивает данные сложной структуры с учетом вложенности.
// Используется для корректного сравнения данных между собой с учетом форматированных документов.
// Если переданы не форматированные документы то используется стандартная функция БСП: 
// ОбщегоНазначения.ДанныеСовпадают()
//
// Параметры:
//  Данные1 - Структура,    ФиксированнаяСтруктура,
//            Соответствие, ФиксированноеСоответствие,
//            Массив,       ФиксированныйМассив,
//            ХранилищеЗначения, ТаблицаЗначений,
//            Строка, Число, Булево - сравниваемые данные.
//
//  Данные2 - Произвольный - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево - Истина, если совпадают.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
	 ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
			 ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
			
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ФорматированныйДокумент") Тогда

		HTML1 = "";
		HTML2 = "";
		Картинки1 = Новый Структура;
		Картинки2 = Новый Структура;

		Данные1.ПолучитьHTML(HTML1, Картинки1);
		Данные2.ПолучитьHTML(HTML2, Картинки2);

		Возврат ДанныеСовпадают(HTML1, HTML2) И ДанныеСовпадают(Картинки1, Картинки2);
		
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции

// Проверяет актуальность переданной версии данных для ссылки
// 
// Параметры:
//  Ссылка - ЛюбаяСсылка
//  ВерсияДанных -Строка - Версия данных, которую нужно проверить на актуальность
// 
// Возвращаемое значение:
//  Булево - Версия данных актуальна
Функция ВерсияДанныхАктуальна(Ссылка, ВерсияДанных) Экспорт
	
	ВерсияДанныхВБазе = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "ВерсияДанных");
	ВерсияДанныхАктуальна = ВерсияДанныхВБазе = ВерсияДанных;
	
	Возврат ВерсияДанныхАктуальна;
	
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка - представление информационной базы.
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name.
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;
		
	// Прибавить к имени сервера имя пути информационной базы.
	ПозицияПоиска = СтрНайти(ВРег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = СтрНайти(ВРег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
	Возврат ПутьКБД;
	
КонецФункции

// Преобразует (сериализует) сериализуемое значение в JSON-строку.
// Могут быть сериализованы объекты, поддерживаемые СериализаторXDTO.ЗаписатьJSON (см. синтакс-помощник).
//
// Параметры:
//	Значение - Произвольный - Значение, которое необходимо сериализовать в JSON.
//
// Возвращаемое значение:
//	Строка - Cериализованное значение.
//
Функция ЗначениеВСтрокуJSON(Значение) Экспорт
	
	ЗаписьJS = Новый ЗаписьJSON;
	ЗаписьJS.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJS, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьJS.Закрыть();
	
КонецФункции

// Преобразует (десериализует) JSON-строку в значение.
// Могут быть десериализованы объекты подерживаемые СериализаторXDTO.ЗаписатьJSON (см. синтаксис-помощник).
//
// Параметры:
//	СериализованнаяСтрока - Строка - JSON-строка, содержащая сериализованное значение.
//
// Возвращаемое значение:
//	Произвольный - Десериализованное значение.
//
Функция ЗначениеИзСтрокиJSON(СериализованнаяСтрока) Экспорт
	
	ЧтениеJS = Новый ЧтениеJSON;
	ЧтениеJS.УстановитьСтроку(СериализованнаяСтрока);
	Данные = СериализаторXDTO.ПрочитатьJSON(ЧтениеJS);
	
	Возврат Данные;
	
КонецФункции

// Определяет ссылку нового объекта.
//
// Параметры:
//  Объект - СправочникОбъект, ДокументОбъект - Новый объект.
// 
// Возвращаемое значение:
//  СправочникСсылка, ДокументСсылка - Ссылка на новый объекта.
//
Функция СсылкаНовогоОбъекта(Объект) Экспорт
	
	СсылкаНовогоОбъекта = Объект.Ссылка;
	Если Не ЗначениеЗаполнено(СсылкаНовогоОбъекта) Тогда
		
		СсылкаНовогоОбъекта = Объект.ПолучитьСсылкуНового();
		Если Не ЗначениеЗаполнено(СсылкаНовогоОбъекта) Тогда
			
			МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
			СсылкаНового = МенеджерОбъекта.ПолучитьСсылку();
			Объект.УстановитьСсылкуНового(СсылкаНового);
			
			СсылкаНовогоОбъекта = СсылкаНового;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СсылкаНовогоОбъекта;
	
КонецФункции

// Проверяет наличие записи в информационной базе данных о переданном значении ссылки
// с учетом прав доступа
//
// Параметры:
//  ПроверяемаяСсылка - ЛюбаяСсылка - значение любой ссылки информационной базы данных.
//  ПривилегированныйРежим - Булево - Истина, если ищем в привилегированном режиме
// 
// Возвращаемое значение:
//  Булево - Истина, если существует.
//
Функция СсылкаСуществует(ПроверяемаяСсылка, ПривилегированныйРежим = Ложь) Экспорт
	
	ТекстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	1 КАК Поле1
		|ИЗ
		|	&ИмяТаблицы КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицы", ОбщегоНазначения.ИмяТаблицыПоСсылке(
		ПроверяемаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ПроверяемаяСсылка);
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Возвращает массив с именами табличных частей переданного объекта
// 
// Параметры:
//  Объект - ЛюбаяСсылка - Объект, табличные части которого необходимо получить
// 
// Возвращаемое значение:
//  Массив Из Строка - Табличные части объекта
Функция ИменаТабличныхЧастейОбъекта(Объект) Экспорт
	
	Результат = Новый Массив;
	
	ТабличныеЧасти = Объект.Метаданные().ТабличныеЧасти;
	
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		Результат.Добавить(ТабличнаяЧасть.Имя);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Показывает или скрывает группу с информацией о пометке удаления объекта.
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - форма объекта.
//  ПометкаУдаления - Булево - текущая пометка удаления объекта 
//  ИмяГруппы  - Строка - группа, которую мы скрываем или показываем.
//
Процедура ПоказатьНадписьПометкиУдаления(Форма, ПометкаУдаления, ИмяГруппы = "") Экспорт
	
	#Если Не ВнешнееСоединение Тогда
	
	Элементы = Форма.Элементы;
	Если Не ЗначениеЗаполнено(ИмяГруппы) Тогда
		ИмяГруппы = "ГруппаПометкаУдаления";
	КонецЕсли;
	
	Если Элементы.Найти(ИмяГруппы) = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Элементы[ИмяГруппы].Видимость = ПометкаУдаления;
	
	#КонецЕсли
	
КонецПроцедуры

// Возвращает Истина, если текущая конфигурация является конфигурацией Документооборот Холдинга.
//
// Возвращаемое значение:
//	Булево - Истина - Если текущая конфигурация является конфигурацией Документооборот Холдинга.
//
Функция ЭтоДокументооборотХолдинга() Экспорт
	

	Возврат Ложь;
	
КонецФункции

// Проверяет, является ли этот узел центральным.
// 
// Возвращаемое значение:
//  Булево - Это центральный узел
//
Функция ЭтоЦентральныйУзел() Экспорт
	

	ЭтоЦентральныйУзел = Истина;
	
	Возврат ЭтоЦентральныйУзел;
	
КонецФункции

// Проверяет, что изменение объекта выполняется процессе загрузки.
//
// Параметры:
//	Объект - КонстантаМенеджерЗначения -
//		   - СправочникОбъект -
//		   - ДокументОбъект -
//		   - БизнесПроцессОбъект -
//		   - ЗадачаОбъект -
//		   - ПланВидовХарактеристикОбъект -
//		   - РегистрСведенийНаборЗаписей -
//		   - РегистрНакопленияНаборЗаписей - Объект, который необходимо проверить.
//
// Возвращаемое значение:
//	Булево - Истина, если выполняется загрузка объекта.
//
Функция ЭтоЗагрузкаОбъекта(Объект) Экспорт
	
	ЭтоЗагрузкаОбъекта = Ложь;

	Возврат ЭтоЗагрузкаОбъекта;
	
КонецФункции

// Увеличивает версию данных.
// 
// Параметры:
//  СтараяВерсияДанных - Число.
// 
// Возвращаемое значение:
//  Число - Новая версия данных.
//
Функция УвеличитьВерсиюДанных(СтараяВерсияДанных) Экспорт
	

	НоваяВерсияДанных = СтараяВерсияДанных + 1000;
	
	Возврат НоваяВерсияДанных;
	
КонецФункции

// Проверяет, принадлежит ли объект этому узлу.
// 
// Параметры:
//  Объект - СправочникОбъект,
//			 ДокументОбъект,
//			 БизнесПроцессОбъект,
//			 ЗадачаОбъект - Объект, который необходимо проверить.
// 
// Возвращаемое значение:
//  Булево - Объект принадлежит этому узлу.
//
	
Функция ОбъектЭтогоУзла(Объект) Экспорт
	ОбъектЭтогоУзла = Истина;

	Возврат ОбъектЭтогоУзла;
	
КонецФункции

// Получает ссылку по навигационной ссылке.
// 
// Параметры:
//  НавигационнаяСсылка - Строка.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка, Неопределено - Полученная ссылка.
//
Функция СсылкаПоНавигационной(НавигационнаяСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ИД = Прав(СокрЛП(НавигационнаяСсылка), 32);
	ИД = Сред(ИД, 25, 8)
		+ "-" + Сред(ИД, 21, 4)
		+ "-" + Сред(ИД, 17, 4)
		+ "-" + Сред(ИД, 1, 4)
		+ "-" + Сред(ИД, 5, 12);
		
	Имя = Сред(НавигационнаяСсылка, СтрНайти(НавигационнаяСсылка, "/", НаправлениеПоиска.СКонца) + 1);
	Имя = Лев(Имя, СтрНайти(Имя, "?") - 1);
	
	Попытка
		Возврат ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(Имя).ПолучитьСсылку(Новый УникальныйИдентификатор(ИД));
	Исключение
		Возврат Неопределено;
	КонецПопытки;

КонецФункции

// Аналог СтрСоединить, но с учетом ограниченной длины итоговой Массив и более наглядный: Если текст не умещается, то
// обрезать его и написать "и др., всего NNN". Для красивого и понятного представления.
// Для заведомо больших списков не рекомендуется пользоваться, т.к. используется массовая конкатенация строк.
// Для большого количества лучше генерировать строку через объект ЗаписьТекста.
// 
// Параметры:
//  Массив - Массив Из Произвольный - Массив любых строк или объектов, которые можно преобразовать к строке-представлнию
//  МаксимальнаяДлина - Число -  Максимальная длина итоговой Массив. Должна быть как минимум 30-40, чтобы уместилось
//  							 заведомо хотя бы 2-3 элемента с учетом дописывания "и др..."
//  Разделитель - Строка - Разделитель между элементами
//  ИДругие - Строка - Фраза вида " и другие, всего %1". Именно с %1, т.к. выводится через СтрШаблон
//  		- Неопределено - Если не указано, то по умолчанию: "и др., всего %1"
// 
// Возвращаемое значение:
//  Строка -
Функция СтрСоединитьОграниченноеКолво(
	Массив, МаксимальнаяДлина = 9999, Разделитель = ", ", Знач ИДругие = Неопределено) Экспорт
	
	Если ИДругие = Неопределено Тогда
		ИДругие = НСтр("ru = ' и др., всего %1'");
	КонецЕсли;
	
	Счетчик = 0;
	Заполненные = Новый Массив();
	Для Каждого Элемент Из Массив Цикл
		Если ЗначениеЗаполнено(Элемент) Тогда
			Заполненные.Добавить(Элемент);
			Счетчик = Счетчик + 1;
		КонецЕсли;
	КонецЦикла;
	
	ВозможнаяКонцовка = СтрШаблон(ИДругие, Формат(Счетчик, "ЧГ=0;"));
	ДлинаКонцовки = СтрДлина(ВозможнаяКонцовка);
	Результат = "";
	Для Каждого Элемент Из Заполненные Цикл
		ЭлементСтрокой = СокрЛП(Строка(Элемент));
		Если СтрДлина(Результат) + СтрДлина(ЭлементСтрокой) + ДлинаКонцовки + 2 <= МаксимальнаяДлина Тогда
			Результат = Результат + ?(Результат = "", "", Разделитель) + ЭлементСтрокой;
		Иначе
			Результат = Результат + ВозможнаяКонцовка;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Пустая структура с полями из колонок объекта
// 
// Параметры:
//  ОбъектСКолонками - РезультатЗапроса,ТаблицаЗначений - Или любой другой объект, у которого есть 
//  													стандартное свойство "Колонки".
// 
// Возвращаемое значение:
//  Структура - Структура из колонок объекта, все поля = Неопределено.
Функция НовыйСтруктураИзКолонокОбъекта(ОбъектСКолонками) Экспорт
	
	Данные = Новый Структура();
	Для Каждого Колонка Из ОбъектСКолонками.Колонки Цикл
		Данные.Вставить(Колонка.Имя, Неопределено);
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

// Вычисляет контрольную сумму для произвольных данных по указанному алгоритму.
// 
// Параметры:
//  Данные - Произвольный - любое сериализуемое значение.
//  Алгоритм - ХешФункция - алгоритм расчета контрольной суммы. По умолчанию, MD5.
//  ФорматСтроки - Строка - Формат строки
// 
// Возвращаемое значение:
//  Строка - контрольная сумма строкой без пробелов (например 32 символа).
Функция КонтрольнаяСуммаСтрокой(Знач Данные, Знач Алгоритм = Неопределено, Знач ФорматСтроки = "xml") Экспорт
	
	Результат = "";
	
	Если Алгоритм = Неопределено Тогда
		Алгоритм = ХешФункция.MD5;
	КонецЕсли;
	
	Если ТипЗнч(Данные) <> Тип("Строка") И ТипЗнч(Данные) <> Тип("ДвоичныеДанные") Тогда
		ФорматСтроки = НРег(ФорматСтроки);
		Если ФорматСтроки = "xml" Тогда
			Данные = ОбщегоНазначения.ЗначениеВСтрокуXML(Данные);
		ИначеЕсли ФорматСтроки = "json" Тогда
			Данные = ЗначениеВСтрокуJSON(Данные);
		Иначе
			ЗаписьЖурналаРегистрации("Ошибка при вычислении контрольной суммы", УровеньЖурналаРегистрации.Ошибка, , ,
				СтрШаблон(НСтр("ru = 'Формат строки не поддерживается:%1'"), ФорматСтроки));
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	ХешированиеДанных = Новый ХешированиеДанных(Алгоритм);
	ХешированиеДанных.Добавить(Данные);
	
	Если ТипЗнч(ХешированиеДанных.ХешСумма) = Тип("ДвоичныеДанные") Тогда 
		Результат = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	ИначеЕсли ТипЗнч(ХешированиеДанных.ХешСумма) = Тип("Число") Тогда
		Результат = Формат(ХешированиеДанных.ХешСумма, "ЧГ=");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Определяет, идентичны ли таблицы значений, с учётом порядка.
// Не поддерживает проверку, если таблица значений содержит хранилище значений - будет вызвано исключение.
//
// Параметры:
//  ТекущееЗначение - ТаблицаЗначений.
//  ПредыдущееЗначение -ТаблицаЗначений.
//  ИсключаемыеКолонки - Строка.
// 
// Возвращаемое значение:
//  Булево - Таблицы значений идентичны.
//
Функция ТаблицыЗначенийИдентичны(ТекущееЗначение, ПредыдущееЗначение, ИсключаемыеКолонки = "") Экспорт
	
	ТаблицыЗначенийИдентичны = Истина;
	
	// Проверяем что количество строк совпадает.
	ПредыдущееКоличествоСтрок = ПредыдущееЗначение.Количество();
	ТекущееКоличествоСтрок = ТекущееЗначение.Количество();
	Если ПредыдущееКоличествоСтрок <> ТекущееКоличествоСтрок Тогда
		ТаблицыЗначенийИдентичны = Ложь;
		Возврат ТаблицыЗначенийИдентичны;
	КонецЕсли;
	
	// Проверяем что количество колонок совпадает.
	ПредыдущееКоличествоКолонок = ПредыдущееЗначение.Колонки.Количество();
	ТекущееКоличествоКолонок = ТекущееЗначение.Колонки.Количество();
	Если ПредыдущееКоличествоКолонок <> ТекущееКоличествоКолонок Тогда
		ТаблицыЗначенийИдентичны = Ложь;
		Возврат ТаблицыЗначенийИдентичны;
	КонецЕсли;
	
	// Определим какие колонки проверять не надо.
	НепроверяемыеКолонки = Новый Соответствие;
	Для Каждого ИсключаемаяКолонка Из СтрРазделить(ИсключаемыеКолонки, ",", Ложь) Цикл
		ИсключаемаяКолонка = СокрЛП(ИсключаемаяКолонка);
		НепроверяемыеКолонки[ИсключаемаяКолонка] = Истина;
	КонецЦикла;
	
	// Проверяем что состав колонок совпадает.
	Для Каждого ПредыдущаяКолонка Из ПредыдущееЗначение.Колонки Цикл
		
		Если НепроверяемыеКолонки[ПредыдущаяКолонка.Имя] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ТекущаяКолонка = ТекущееЗначение.Колонки.Найти(ПредыдущаяКолонка.Имя);
		Если ТекущаяКолонка = Неопределено Тогда
			ТаблицыЗначенийИдентичны = Ложь;
			Возврат ТаблицыЗначенийИдентичны;
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверяем что состав строк совпадает.
	Для НомерСтроки = 1 По ТекущееКоличествоСтрок Цикл
		
		ИндексСтроки = НомерСтроки - 1;
		
		ПредыдущаяСтрока = ПредыдущееЗначение.Получить(ИндексСтроки);
		ТекущаяСтрока = ТекущееЗначение.Получить(ИндексСтроки);
		
		Для Каждого Колонка Из ТекущееЗначение.Колонки Цикл
			
			Если НепроверяемыеКолонки[Колонка.Имя] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ПредыдущееЗначениеКолонкиВСтроке = ПредыдущаяСтрока[Колонка.Имя];
			ТекущееЗначениеКолонкиВСтроке = ТекущаяСтрока[Колонка.Имя];
			
			Если ТипЗнч(ТекущееЗначениеКолонкиВСтроке) = Тип("ХранилищеЗначения") Тогда
				ВызватьИсключение НСтр("ru = 'Функция ТаблицыЗначенийИдентичны не поддерживает значения типа Хранилище значения'");
			КонецЕсли;
			
			Если ПредыдущееЗначениеКолонкиВСтроке <> ТекущееЗначениеКолонкиВСтроке Тогда
				ТаблицыЗначенийИдентичны = Ложь;
				Возврат ТаблицыЗначенийИдентичны;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ТаблицыЗначенийИдентичны;
	
КонецФункции

// Возвращает Истина, если клиентское приложение является тонким-клиентом.
//
// Возвращаемое значение:
//  Булево - Клиентское приложение является тонким клиеннтом
//
Функция ЭтоТонкийКлиент() Экспорт
	
	ИспользуемыйКлиент = ОбщегоНазначения.ИспользуемыйКлиент();
	ЭтоТонкийКлиент = ИспользуемыйКлиент = "ТонкийКлиент";
	
	Возврат ЭтоТонкийКлиент;
	
КонецФункции

// Удаляет дубли строк табличной части.
//
// Параметры:
//  ТабличнаяЧасть - ТабличнаяЧасть
//  МетаданныеТабличнойЧасти - ОбъектМетаданныхТабличнаяЧасть
//
Процедура УдалитьДублиСтрокТабличнойЧасти(ТабличнаяЧасть, МетаданныеТабличнойЧасти) Экспорт
	
	МассивИменаРеквизитовПроверки = Новый Массив;
	
	Для Каждого Реквизит Из МетаданныеТабличнойЧасти.Реквизиты Цикл
		МассивИменаРеквизитовПроверки.Добавить(Реквизит.Имя);
	КонецЦикла;
	
	ИменаРеквизитовПроверки = СтрСоединить(МассивИменаРеквизитовПроверки, ",");
	
	ОбщегоНазначенияДокументооборотКлиентСервер.УдалитьДублиСтрокТаблицы(
		ТабличнаяЧасть,
		ИменаРеквизитовПроверки);
	
КонецПроцедуры

// Формирует массив имен реквизитов формы.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - Форма.
//
// Возвращаемое значение:
//	Массив Из Строка - Массив с именами реквизитов.
//
Функция ИменаРеквизитовФормы(Форма) Экспорт
	
	Результат = Новый Массив;
	
	//@skip-check bsl-legacy-check-dynamic-feature-access
	Для Каждого РеквизитФормы Из Форма.ПолучитьРеквизиты() Цикл
		
		Результат.Добавить(РеквизитФормы.Имя);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Обработка получения данных выбора, для расширения полным типом.
//
// Параметры:
//  ДанныеВыбора - СписокЗначений из ЛюбаяСсылка
//  Параметры - Структура
//  СтандартнаяОбработка - Булево
//
Процедура ОбработкаПолученияДанныхВыбора(ДанныеВыбора, Параметры, СтандартнаяОбработка) Экспорт
	
	Если ТипЗнч(Параметры) <> Тип("Структура")
		Или Не Параметры.Свойство("ПолныйТип")
		Или Параметры.Свойство("ПолучениеПолныхДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СтандартнаяОбработка = Ложь;
	
	ДанныеВыбора = Новый СписокЗначений();
	
	Параметры.Вставить("ПолучениеПолныхДанных", Истина);
	
	ПолныйТип = Параметры.ПолныйТип;
	ОписаниеТипов = Новый ОписаниеТипов(ПолныйТип);
	Для Каждого Тип Из ОписаниеТипов.Типы() Цикл
		
		СсылкаТипа = Новый(Тип);
		МенеджерТипа = ОбщегоНазначения.МенеджерОбъектаПоСсылке(СсылкаТипа);
		ДанныеВыбораТипа = МенеджерТипа.ПолучитьДанныеВыбора(Параметры);
		Для Каждого ЭлементВыбораТипа Из ДанныеВыбораТипа Цикл
			ДанныеВыбора.Добавить(
				ЭлементВыбораТипа.Значение,
				ЭлементВыбораТипа.Представление,
				ЭлементВыбораТипа.Пометка,
				ЭлементВыбораТипа.Картинка);
		КонецЦикла;
		
	КонецЦикла;
	
	ДанныеВыбора.СортироватьПоПредставлению();
	
КонецПроцедуры

// Преобразует переданную ссылку в физическое лицо.
// Для физических лиц это будет само физическое лицо.
// Для сотрудников это будет физическое лицо сотрудника.
// Для пользователей это будет физичское лицо любого сотрудника пользователя.
// Для любых других типов будет пустая ссылка на физическое лицо.
// Для не заполненного значения будет пустая ссылка на физическое лицо.
// 
// Параметры:
//  Ссылка - СправочникСсылка.Пользователи
//         - СправочникСсылка.Сотрудники
//         - СправочникСсылка.ФизическиеЛица
// 
// Возвращаемое значение:
//  СправочникСсылка.ФизическиеЛица
// 
Функция ФизическоеЛицо(Ссылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		ФизическоеЛицо = Справочники.ФизическиеЛица.ПустаяСсылка();
	ИначеЕсли ТипЗнч(Ссылка) = Тип("СправочникСсылка.ФизическиеЛица") Тогда
		ФизическоеЛицо = Ссылка;
	ИначеЕсли ТипЗнч(Ссылка) = Тип("СправочникСсылка.Сотрудники") Тогда
		ФизическоеЛицо = Сотрудники.ФизЛицоСотрудника(Ссылка);
	ИначеЕсли ТипЗнч(Ссылка) = Тип("СправочникСсылка.Пользователи") Тогда
		ФизическоеЛицо = ПользователиДокументооборот.ФизЛицоПользователя(Ссылка);
	Иначе
		ФизическоеЛицо = Справочники.ФизическиеЛица.ПустаяСсылка();
	КонецЕсли;
	
	Возврат ФизическоеЛицо;
	
КонецФункции

// Преобразует переданную ссылку в сотрудника.
// Для сотрудников это будет сам сотрудник.
// Для физических лиц это будет основной сотрудник, либо любой действительные сотрудник, либо любой недействительный
// сотрудник, не помеченный на удаление
// Для пользователей это будет основной сотрудник, либо любой действительные сотрудник, либо любой недействительный
// сотрудник.
// Для любых других типов будет пустая ссылка.
// Для не заполненного значения будет пустая ссылка на сотрудника.
// 
// Параметры:
//  Ссылка - СправочникСсылка.Пользователи
//         - СправочникСсылка.Сотрудники
//         - СправочникСсылка.ФизическиеЛица
// 
// Возвращаемое значение:
//  СправочникСсылка.Сотрудники
// 
Функция Сотрудник(Ссылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		Сотрудник = Справочники.Сотрудники.ПустаяСсылка();
	ИначеЕсли ТипЗнч(Ссылка) = Тип("СправочникСсылка.Сотрудники") Тогда
		Сотрудник = Ссылка;
	ИначеЕсли ТипЗнч(Ссылка) = Тип("СправочникСсылка.ФизическиеЛица") Тогда
		
		// В приоритете основной сотрудники.
		Сотрудник = Сотрудники.ОсновнойСотрудникФизЛица(Ссылка);
		
		// Если основного сотрудника нет, то подойдёт любой действующий.
		Если Не ЗначениеЗаполнено(Сотрудник) Тогда
			ВсеСотрудникиФизЛица = Сотрудники.ВсеСотрудникиФизЛица(Ссылка);
			Если ВсеСотрудникиФизЛица.Количество() > 0 Тогда
				Сотрудник = ВсеСотрудникиФизЛица[0];
			КонецЕсли;
		КонецЕсли;
		
		// Если действующих нет, то подойдёт любой недействующий.
		Если Не ЗначениеЗаполнено(Сотрудник) Тогда
			ВсеНедействующиеСотрудникиФизЛица = Сотрудники.ВсеНедействующиеСотрудникиФизЛица(Ссылка);
			Если ВсеНедействующиеСотрудникиФизЛица.Количество() > 0 Тогда
				Сотрудник = ВсеНедействующиеСотрудникиФизЛица[0];
			КонецЕсли;
		КонецЕсли;
		
		// Если не нашли, то просто пустую ссылку вернём.
		Если Не ЗначениеЗаполнено(Сотрудник) Тогда
			Сотрудник = Справочники.Сотрудники.ПустаяСсылка();
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(Ссылка) = Тип("СправочникСсылка.Пользователи") Тогда
		
		// В приоритете основной сотрудники.
		Сотрудник = Сотрудники.ОсновнойСотрудникПользователя(Ссылка);
		
		// Если нет основного сотрудника нет, то подойдёт любой действующий.
		Если Не ЗначениеЗаполнено(Сотрудник) Тогда
			Действительные = Истина;
			СотрудникиПользователя = Сотрудники.СотрудникиПользователя(Ссылка, Действительные);
			Если СотрудникиПользователя.Количество() > 0 Тогда
				Сотрудник = СотрудникиПользователя[0];
			КонецЕсли;
		КонецЕсли;
		
		// Если действующих нет, то подойдёт любой недействующий.
		Если Не ЗначениеЗаполнено(Сотрудник) Тогда
			Действительные = Ложь;
			СотрудникиПользователя = Сотрудники.СотрудникиПользователя(Ссылка, Действительные);
			Если СотрудникиПользователя.Количество() > 0 Тогда
				Сотрудник = СотрудникиПользователя[0];
			КонецЕсли;
		КонецЕсли;
		
		// Если не нашли, то просто пустую ссылку вернём.
		Если Не ЗначениеЗаполнено(Сотрудник) Тогда
			Сотрудник = Справочники.Сотрудники.ПустаяСсылка();
		КонецЕсли;
		
	Иначе
		Сотрудник = Справочники.Сотрудники.ПустаяСсылка();
	КонецЕсли;
	
	Возврат Сотрудник;
	
КонецФункции

// Проверяет, завершено ли отложенное обновление.
// 
// Параметры:
//  ИмяОбработчика - Строка
// 
// Возвращаемое значение:
//  Булево - Отложенное обновление завершено
// 
Функция ОтложенноеОбновлениеЗавершено(ИмяОбработчика) Экспорт
	
	БлокирующиеСтатусы = Новый Массив;
	БлокирующиеСтатусы.Добавить(Перечисления.СтатусыОбработчиковОбновления.НеВыполнялся);
	БлокирующиеСтатусы.Добавить(Перечисления.СтатусыОбработчиковОбновления.Выполняется);
	БлокирующиеСтатусы.Добавить(Перечисления.СтатусыОбработчиковОбновления.Приостановлен);
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ОбработчикиОбновления.ИмяОбработчика
		|ИЗ
		|	РегистрСведений.ОбработчикиОбновления КАК ОбработчикиОбновления
		|ГДЕ
		|	ОбработчикиОбновления.ИмяОбработчика = &ИмяОбработчика
		|	И ОбработчикиОбновления.Статус В (&БлокирующиеСтатусы)");
	Запрос.УстановитьПараметр("ИмяОбработчика", ИмяОбработчика);
	Запрос.УстановитьПараметр("БлокирующиеСтатусы", БлокирующиеСтатусы);
	РезультатЗапроса = Запрос.Выполнить();
	
	ОтложенноеОбновлениеЗавершено = РезультатЗапроса.Пустой();
	
	Возврат ОтложенноеОбновлениеЗавершено;
	
КонецФункции

// Исключает помеченные на удаление из массив.
// 
// Параметры:
//  Массив - Массив из СправочникСсылка, ДокументСсылка, БизнесПроцессСсылка, ЗадачаСсылка
// 
Процедура ИсключитьПомеченныеНаУдаление(Массив) Экспорт
	
	ПометкиУдаленияОбъектов = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Массив, "ПометкаУдаления");
	
	КоличествоЭлементов = Массив.Количество();
	Для Индекс = 1 По КоличествоЭлементов Цикл
		
		ОбратныйИндекс = КоличествоЭлементов - Индекс;
		ЭлементМассива = Массив[ОбратныйИндекс];
		
		ПометкаУдаленияОбъекта = ПометкиУдаленияОбъектов[ЭлементМассива];
		Если ПометкаУдаленияОбъекта = Ложь Тогда
			Продолжить;
		КонецЕсли;
		
		Массив.Удалить(ОбратныйИндекс);
		
	КонецЦикла;
	
КонецПроцедуры

// Обновляет таблицу формы, без учёта порядка.
// 
// Параметры:
//  ТаблицаФормы - ДанныеФормыКоллекция
//  ДанныеТаблицы - ТаблицаЗначений
//  ИмяКолонкиКлюча - Строка
// 
Процедура ОбновитьТаблицуФормы(ТаблицаФормы, ДанныеТаблицы, ИмяКолонкиКлюча) Экспорт
	
#Если Не ВнешнееСоединение Тогда
	
	СтрокиПоКлючам = Новый Соответствие;
	Для Каждого СтрокаТаблицы Из ТаблицаФормы Цикл
		СтрокиПоКлючам[СтрокаТаблицы[ИмяКолонкиКлюча]] = СтрокаТаблицы;
	КонецЦикла;
	
	ВостребованныеСтроки = Новый Соответствие;
	Для Каждого СтрокаДанных Из ДанныеТаблицы Цикл
		
		Если СтрокиПоКлючам[СтрокаДанных[ИмяКолонкиКлюча]] = Неопределено Тогда
			СтрокиПоКлючам[СтрокаДанных[ИмяКолонкиКлюча]] = ТаблицаФормы.Добавить();
		КонецЕсли;
		
		СтрокаТаблицы = СтрокиПоКлючам[СтрокаДанных[ИмяКолонкиКлюча]];
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, СтрокаДанных);
		
		ВостребованныеСтроки[СтрокаТаблицы[ИмяКолонкиКлюча]] = СтрокаТаблицы;
		
	КонецЦикла;
	
	КоличествоЭлементов = ТаблицаФормы.Количество();
	Для Индекс = 1 По КоличествоЭлементов Цикл
		ОбратныйИндекс = КоличествоЭлементов - Индекс;
		СтрокаТаблицы = ТаблицаФормы[ОбратныйИндекс];
		Если ВостребованныеСтроки[СтрокаТаблицы[ИмяКолонкиКлюча]] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ТаблицаФормы.Удалить(ОбратныйИндекс);
	КонецЦикла;
	
#Иначе
	ВызватьИсключение НСтр("ru = 'Метод ОбновитьТаблицуФормы не доступен во внешнем соединении.'");
#КонецЕсли
	
КонецПроцедуры

// Определяет предыдущие записи по набору записей.
// Если набор записей без отборов - то ничего не возвращает.
// 
// Параметры:
//  НаборЗаписей - РегистрСведенийНаборЗаписей
// 
// Возвращаемое значение:
//  ТаблицаЗначений
// 
Функция ПредыдущиеЗаписи(НаборЗаписей) Экспорт
	
	ПредыдущиеЗаписи = Новый ТаблицаЗначений;
	Если НаборЗаписей.Отбор.Количество() = 0 Тогда
		Возврат ПредыдущиеЗаписи;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	*
		|ИЗ
		|	&ПолноеИмяТаблицы КАК ТаблицаРегистра
		|ГДЕ
		|	&Условие");
	
	Условие = "";
	Разделитель = "";
	
	Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		СтрокаУсловия = СтрШаблон("ТаблицаРегистра.%1 = &%2", ЭлементОтбора.Имя, ЭлементОтбора.Имя);
		Условие = Условие + Разделитель + СтрокаУсловия;
		Запрос.УстановитьПараметр(ЭлементОтбора.Имя, ЭлементОтбора.Значение);
		Разделитель = Символы.ПС + "	И ";
	КонецЦикла;
	
	Если Условие = "" Тогда
		Условие = "ИСТИНА";
	КонецЕсли;
	
	МетаданныеТаблицы = НаборЗаписей.Метаданные();
	ПолноеИмяТаблицы = МетаданныеТаблицы.ПолноеИмя();
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ПолноеИмяТаблицы", ПолноеИмяТаблицы);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Условие", Условие);
	
	ПредыдущиеЗаписи = Запрос.Выполнить().Выгрузить();
	
	Возврат ПредыдущиеЗаписи;
	
КонецФункции

// Определяет удаленные записи.
// 
// Параметры:
//  НаборЗаписей - РегистрСведенийНаборЗаписей
//  ТекущиеЗаписи - ТаблицаЗначений
//  ПредыдущиеЗаписи - ТаблицаЗначений
// 
// Возвращаемое значение:
//  Массив из СтрокаТаблицыЗначений
// 
Функция УдаленныеЗаписи(НаборЗаписей, ТекущиеЗаписи, ПредыдущиеЗаписи) Экспорт
	
	УдаленныеЗаписи = Новый Массив;
	Для Каждого ПредыдущаяЗапись Из ПредыдущиеЗаписи Цикл
		
		СтруктураОтбора = Новый Структура;
		Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
			СтруктураОтбора.Вставить(ЭлементОтбора.Имя, ПредыдущаяЗапись[ЭлементОтбора.Имя]);
		КонецЦикла;
		
		НайденныеСтроки = ТекущиеЗаписи.НайтиСтроки(СтруктураОтбора);
		Если НайденныеСтроки.Количество() <> 0 Тогда
			Продолжить;
		КонецЕсли;
		
		УдаленныеЗаписи.Добавить(ПредыдущаяЗапись);
		
	КонецЦикла;
	
	Возврат УдаленныеЗаписи;
	
КонецФункции

// Определяет добавленные записи.
// 
// Параметры:
//  НаборЗаписей - РегистрСведенийНаборЗаписей
//  ТекущиеЗаписи - ТаблицаЗначений
//  ПредыдущиеЗаписи - ТаблицаЗначений
// 
// Возвращаемое значение:
//  Массив из РегистрСведенийЗапись
// 
Функция ДобавленныеЗаписи(НаборЗаписей, ТекущиеЗаписи, ПредыдущиеЗаписи) Экспорт
	
	ДобавленныеЗаписи = Новый Массив;
	Для Каждого ТекущаяЗапись Из ТекущиеЗаписи Цикл
		
		СтруктураОтбора = Новый Структура;
		Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
			СтруктураОтбора.Вставить(ЭлементОтбора.Имя, ТекущаяЗапись[ЭлементОтбора.Имя]);
		КонецЦикла;
		
		НайденныеСтроки = ПредыдущиеЗаписи.НайтиСтроки(СтруктураОтбора);
		Если НайденныеСтроки.Количество() <> 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ДобавленныеЗаписи.Добавить(ТекущаяЗапись);
		
	КонецЦикла;
	
	Возврат ДобавленныеЗаписи;
	
КонецФункции

// Определяет удаленные и добавленные записи.
// 
// Параметры:
//  НаборЗаписей - РегистрСведенийНаборЗаписей
//  ТекущиеЗаписи - ТаблицаЗначений
//  ПредыдущиеЗаписи - ТаблицаЗначений
// 
// Возвращаемое значение:
//  Массив из РегистрСведенийЗапись
// 
Функция УдаленныеИДобавленныеЗаписи(НаборЗаписей, ТекущиеЗаписи, ПредыдущиеЗаписи) Экспорт
	
	УдаленныеИДобавленныеЗаписи = УдаленныеЗаписи(НаборЗаписей, ТекущиеЗаписи, ПредыдущиеЗаписи);
	ДобавленныеЗаписи = ДобавленныеЗаписи(НаборЗаписей, ТекущиеЗаписи, ПредыдущиеЗаписи);
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(УдаленныеИДобавленныеЗаписи, ДобавленныеЗаписи, Ложь);
	
	Возврат УдаленныеИДобавленныеЗаписи;
	
КонецФункции

// Формирует представление ссылок на справочники.
// Если нет прав, то формирует пустое представление, вместо стандартного платформенного.
//
// Параметры:
//  Ссылки - Массив из СправочникСсылка
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//   * Ключ - СправочникСсылка
//   * Значение - Строка
//
Функция ПредставленияСсылок(Ссылки) Экспорт
	
	ПредставленияСсылок = Новый Соответствие;
	Если Ссылки.Количество() = 0 Тогда
		Возврат ПредставленияСсылок;
	КонецЕсли;
	
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого Ссылка Из Ссылки Цикл
		ТипСсылки = ТипЗнч(Ссылка);
		СсылкиТипа = СсылкиПоТипам[ТипСсылки];
		Если СсылкиТипа = Неопределено Тогда
			СсылкиПоТипам.Вставить(ТипСсылки, Новый Массив);
			СсылкиТипа = СсылкиПоТипам[ТипСсылки];
		КонецЕсли;
		СсылкиТипа.Добавить(Ссылка);
	КонецЦикла;
	
	Для Каждого КлючИЗначение Из СсылкиПоТипам Цикл
		
		СсылкиТипа = КлючИЗначение.Значение;
		
		Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	ТаблицаТипа.Ссылка КАК Ссылка,
			|	ТаблицаТипа.Представление КАК Представление
			|ИЗ
			|	&ТаблицаТипа КАК ТаблицаТипа
			|ГДЕ
			|	ТаблицаТипа.Ссылка В(&СсылкиТипа)");
		
		ТаблицаТипа = СсылкиТипа[0].Метаданные().ПолноеИмя();
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТаблицаТипа", ТаблицаТипа);
		
		Запрос.УстановитьПараметр("СсылкиТипа", СсылкиТипа);
		
		//@skip-check query-in-loop
		РезультатЗапроса = Запрос.Выполнить();
		ТаблицаРезультата = РезультатЗапроса.Выгрузить();
		ТаблицаРезультата.Индексы.Добавить("Ссылка");
		
		Для Каждого СсылкаТипа Из СсылкиТипа Цикл
			СтрокаСсылки = ТаблицаРезультата.Найти(СсылкаТипа, "Ссылка");
			Если СтрокаСсылки <> Неопределено Тогда
				ПредставленияСсылок[СсылкаТипа] = СтрокаСсылки.Представление;
			Иначе
				// Нет прав на ссылку, сформируем пустое представление, вместо платформенного.
				ПредставленияСсылок[СсылкаТипа] = "";
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ПредставленияСсылок;
	
КонецФункции

// Формирует текст ошибки "Неизвестный тип" для произвольного значения.
// 
// Параметры:
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  Строка
// 
Функция ТекстОшибкиНеизвестныйТип(Значение) Экспорт
	
	ТекстОшибкиНеизвестныйТип = СтрШаблон(
		НСтр("ru = 'Неизвестный тип %1 (%2)'"),
		Значение,
		ТипЗнч(Значение));
	
	Возврат ТекстОшибкиНеизвестныйТип;
	
КонецФункции

// Преобразует переданную строку:
// в форматированную строку, если строка начинается с "<body>" и заканчивается "</body>";
// В противном случае строка остается без изменений.
//
// Параметры:
//  ТекстСообщения - Строка - исходная строка.
//
// Возвращаемое значение:
//  Строка - результат преобразования.
//
Функция ФорматированнаяСтрокаИзHTML(ТекстСообщения) Экспорт
	
	Документ = Новый ФорматированныйДокумент;
	Документ.УстановитьHTML("<html>" + ТекстСообщения + "</html>", Новый Структура);
	Возврат Документ.ПолучитьФорматированнуюСтроку();
	
КонецФункции

// Обновляет указанные ключевые операции.
// 
// Параметры:
//  ДанныеКлючевыхОпераций - см. ОбщегоНазначенияДокументооборот.НовыеДанныеКлючевыхОпераций
// 
Процедура ОбновитьКлючевыеОперации(ДанныеКлючевыхОпераций) Экспорт
	
	Если ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(Метаданные.Справочники.КлючевыеОперации)
		И ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		// Заполняется в неразделенной области.
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	МАКСИМУМ(КлючевыеОперации.Приоритет) КАК Приоритет
		|ИЗ
		|	Справочник.КлючевыеОперации КАК КлючевыеОперации");
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Если ЗначениеЗаполнено(Выборка.Приоритет) Тогда
		Приоритет = Выборка.Приоритет + 1;
	Иначе
		Приоритет = 1;
	КонецЕсли;
	
	Для Каждого ДанныеКлючевойОперации Из ДанныеКлючевыхОпераций Цикл
		
		КлючеваяОперацияСсылка = ОценкаПроизводительностиПовтИсп.ПолучитьКлючевуюОперациюПоИмени(
			ДанныеКлючевойОперации.Имя);
		КлючеваяОперацияОбъект = КлючеваяОперацияСсылка.ПолучитьОбъект();
		КлючеваяОперацияОбъект.Наименование = ДанныеКлючевойОперации.Наименование;
		
		Если ЗначениеЗаполнено(ДанныеКлючевойОперации.ЦелевоеВремя) Тогда
			КлючеваяОперацияОбъект.ЦелевоеВремя = ДанныеКлючевойОперации.ЦелевоеВремя;
		КонецЕсли;
		
		Если КлючеваяОперацияОбъект.Приоритет = 0 Тогда
			КлючеваяОперацияОбъект.Приоритет = Приоритет;
			Приоритет = Приоритет + 1;
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(КлючеваяОперацияОбъект.МинимальноДопустимыйУровень) Тогда
			КлючеваяОперацияОбъект.МинимальноДопустимыйУровень = Перечисления.УровниПроизводительности.Хорошо;
		КонецЕсли;
		
		КлючеваяОперацияОбъект.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

// Новые данные ключевых операций.
// 
// Возвращаемое значение:
//  ТаблицаЗначений:
//   * Имя - Строка
//   * Наименование - Строка
//   * ЦелевоеВремя - Число
// 
Функция НовыеДанныеКлючевыхОпераций() Экспорт
	
	ДанныеКлючевыхОпераций = Новый ТаблицаЗначений;
	ДанныеКлючевыхОпераций.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ДанныеКлючевыхОпераций.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка"));
	ДанныеКлючевыхОпераций.Колонки.Добавить("ЦелевоеВремя", Новый ОписаниеТипов("Число"));
	
	Возврат ДанныеКлючевыхОпераций;
	
КонецФункции

#Область РежимыЗамещенияНаборовЗаписей

// Проверяет, что указанный режим соответствует режиму Замещение набора записей.
//
// Параметры:
//	Режим - Булево, РежимЗамещения - Режим замещения набора записей.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоРежимЗамещениеНабораЗаписей(Режим) Экспорт
	
	Возврат Режим = Истина Или ОбщегоНазначения.ЭтоЗамещениеНабораЗаписей(Режим);
	
КонецФункции

// Проверяет, что указанный режим соответствует режиму Добавление набора записей.
//
// Параметры:
//	Режим - Булево, РежимЗамещения - Режим замещения набора записей.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоРежимДобавлениеНабораЗаписей(Режим) Экспорт
	
	Возврат Режим = Ложь Или ОбщегоНазначения.ЭтоДобавлениеНабораЗаписей(Режим);
	
КонецФункции

// Проверяет, что указанный режим соответствует режиму Обновление набора записей.
//
// Параметры:
//	Режим - Булево, РежимЗамещения - Режим замещения набора записей.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоРежимОбновлениеНабораЗаписей(Режим) Экспорт
	
	Возврат ОбщегоНазначения.ЭтоОбновлениеНабораЗаписей(Режим);
	
КонецФункции

// Проверяет, что указанный режим соответствует режиму Слияние набора записей.
//
// Параметры:
//	Режим - Булево, РежимЗамещения - Режим замещения набора записей.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоРежимСлияниеНабораЗаписей(Режим) Экспорт
	
	Возврат ОбщегоНазначения.ЭтоСлияниеНабораЗаписей(Режим);
	
КонецФункции

// Проверяет, что указанный режим соответствует режиму Обновление набора записей.
//
// Параметры:
//	Режим - Булево, РежимЗамещения - Режим замещения набора записей.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоРежимУдалениеНабораЗаписей(Режим) Экспорт
	
	Возврат ОбщегоНазначения.ЭтоУдалениеНабораЗаписей(Режим);
	
КонецФункции

// Возвращает Истина, если производится удаление набора записей.
//
// Параметры:
//	НаборЗаписей - РегистрСведенийНаборЗаписей, РегистрНакопленияНаборЗаписей - Набор записей.
//	Режим - Булево, РежимЗамещения - Режим замещения набора записей.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоУдалениеНабораЗаписей(НаборЗаписей, Режим) Экспорт
	
	Возврат ЭтоРежимУдалениеНабораЗаписей(Режим)
			Или НаборЗаписей.Количество() = 0 И ЭтоРежимЗамещениеНабораЗаписей(Режим);
	
КонецФункции

#КонецОбласти

// Формирует пустую структуру параметров метода ОбщегоНазначенияДокументооборот.ПроверитьДублиСтрокТаблицы.
//
// Возвращаемое значение:
//  Структура:
//   * ТаблицаФормы - ТаблицаФормы
//                  - Неопределено
//   * ИменаРеквизитовПроверки - Строка
//   * ИмяКлючевогоРеквизита - Строка
//   * ИмяТаблицыФормы - Строка
//   * ШаблонСообщенияОДубле - Строка
//
Функция НовыеПараметрыПроверкиДублейСтрокТаблицы() Экспорт
	
	ПараметрыПроверки = Новый Структура;
	ПараметрыПроверки.Вставить("ТаблицаФормы", Неопределено);
	ПараметрыПроверки.Вставить("ИменаРеквизитовПроверки", "");
	ПараметрыПроверки.Вставить("ИмяКлючевогоРеквизита", "");
	ПараметрыПроверки.Вставить("ИмяТаблицыФормы", "");
	ПараметрыПроверки.Вставить("ШаблонСообщенияОДубле", "");
	
	Возврат ПараметрыПроверки;
	
КонецФункции

// Проверяет дубли строк таблицы.
//
// Параметры:
//  ПараметрыПроверки - см. ОбщегоНазначенияДокументооборот.НовыеПараметрыПроверкиДублейСтрокТаблицы
//  Отказ - Булево
//
Процедура ПроверитьДублиСтрокТаблицы(ПараметрыПроверки, Отказ) Экспорт
	
	ТаблицаФормы = ПараметрыПроверки.ТаблицаФормы;
	ИменаРеквизитовПроверки = ПараметрыПроверки.ИменаРеквизитовПроверки;
	ИмяКлючевогоРеквизита = ПараметрыПроверки.ИмяКлючевогоРеквизита;
	ИмяТаблицыФормы = ПараметрыПроверки.ИмяТаблицыФормы;
	ШаблонСообщенияОДубле = ПараметрыПроверки.ШаблонСообщенияОДубле;
	
	ИндексСтроки = 0;
	УникальныеСтроки = Новый Соответствие;
	
	МассивИменаРеквизитовПроверки = СтрРазделить(ИменаРеквизитовПроверки, ",");
	ВсегоРеквизитовПроверки = МассивИменаРеквизитовПроверки.Количество();
	
	Для Каждого Строка Из ТаблицаФормы Цикл
		
		НомерРеквизитаПроверки = 1;
		
		ТекущиеУникальныеСтроки = УникальныеСтроки;
		Для Каждого ИмяРеквизитаПроверки Из МассивИменаРеквизитовПроверки Цикл
			
			ЗначениеРеквизитаПроверки = Строка[СокрЛП(ИмяРеквизитаПроверки)];
			
			ЭтоПоследнийРеквизитПроверки = (НомерРеквизитаПроверки = ВсегоРеквизитовПроверки);
			
			Если Не ЭтоПоследнийРеквизитПроверки Тогда
				
				Если ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки] = Неопределено Тогда
					ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки] = Новый Соответствие;
				КонецЕсли;
				ТекущиеУникальныеСтроки = ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки];
				
				НомерРеквизитаПроверки = НомерРеквизитаПроверки + 1;
				
			Иначе
				
				Если ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки] = Неопределено Тогда
					ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки] = Истина;
				Иначе
					ЗначениеКлючевогоРеквизита = Строка[ИмяКлючевогоРеквизита];
					ТекстСообщения = СтрШаблон(ШаблонСообщенияОДубле, ЗначениеКлючевогоРеквизита);
					ФорматированныйИндексСтроки = Формат(ИндексСтроки, "ЧГ=0");
					ПутьСтроки = СтрШаблон(
						"%1[%2].%3",
						ИмяТаблицыФормы,
						ФорматированныйИндексСтроки,
						ИмяКлючевогоРеквизита);
					ОбщегоНазначения.СообщитьПользователю(ТекстСообщения,, ПутьСтроки,, Отказ);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		ИндексСтроки = ИндексСтроки + 1;
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, что переданное значение является структурой.
//
// Параметры:
//  ПроверяемоеЗначение - Произвольный
//
// Возвращаемое значение:
//  Булево
//
Функция ЭтоСтруктура(ПроверяемоеЗначение) Экспорт
	
	Возврат ТипЗнч(ПроверяемоеЗначение) = Тип("Структура");
	
КонецФункции

// Определяет добавленные и удаленные строки.
//
// Параметры:
//  НоваяТаблица - ТаблицаЗначений
//  СтараяТаблица - ТаблицаЗначений
//  ИменаКлючевыхКолонок - Строка - Имена ключевыхх колонок, разеделены через символ ",".
// 
// Возвращаемое значение:
//  Структура:
//   * ДобавленныеСтроки - Массив из СтрокаТаблицыЗначений
//   * УдаленныеСтроки - Массив из СтрокаТаблицыЗначений
//
Функция ДобавленныеИУдаленныеСтроки(НоваяТаблица, СтараяТаблица, ИменаКлючевыхКолонок) Экспорт
	
	ДобавленныеСтроки = ДобавленныеСтроки(НоваяТаблица, СтараяТаблица, ИменаКлючевыхКолонок);
	УдаленныеСтроки = УдаленныеСтроки(НоваяТаблица, СтараяТаблица, ИменаКлючевыхКолонок);
	
	ДобавленныеИУдаленныеСтроки = Новый Структура;
	ДобавленныеИУдаленныеСтроки.Вставить("ДобавленныеСтроки", ДобавленныеСтроки);
	ДобавленныеИУдаленныеСтроки.Вставить("УдаленныеСтроки", УдаленныеСтроки);
	
	Возврат ДобавленныеИУдаленныеСтроки;
	
КонецФункции

// Определяет добавленные строки. Так же может определить удаленные строки, если поменять порядок таблиц.
//
// Параметры:
//  НоваяТаблица - ТаблицаЗначений
//  СтараяТаблица - ТаблицаЗначений
//  ИменаКлючевыхКолонок - Строка - Имена ключевыхх колонок, разеделены через символ ",".
// 
// Возвращаемое значение:
//  Массив из СтрокаТаблицыЗначений
//
Функция ДобавленныеСтроки(НоваяТаблица, СтараяТаблица, ИменаКлючевыхКолонок) Экспорт
	
	ДобавленныеСтроки = Новый Массив;
	
	МассивИменКлючевыхКолонок = МассивИменКлючевыхКолонок(ИменаКлючевыхКолонок);
	Если МассивИменКлючевыхКолонок.Количество() = 0 Тогда
		Возврат ДобавленныеСтроки;
	КонецЕсли;
	
	СтрокиПоКлючам = СтрокиПоКлючам(СтараяТаблица, МассивИменКлючевыхКолонок);
	
	ИндексПоследнегоКлюча = МассивИменКлючевыхКолонок.ВГраница();
	ИмяПоследнегоКлюча = МассивИменКлючевыхКолонок[ИндексПоследнегоКлюча];
	
	Для Каждого СтрокаТаблицы Из НоваяТаблица Цикл
		
		Найден = Ложь;
		
		СтрокиТекущегоУровня = СтрокиПоКлючам;
		Для Каждого ИмяКлючевойКолонки Из МассивИменКлючевыхКолонок Цикл
			
			ЗначениеКлюча = СтрокаТаблицы[ИмяКлючевойКолонки];
			Если ИмяКлючевойКолонки = ИмяПоследнегоКлюча Тогда
				
				// Последняя колонка ключа - здесь хранятся конкретные значения строка.
				Если СтрокиТекущегоУровня[ЗначениеКлюча] <> Неопределено Тогда
					Найден = Истина;
				КонецЕсли;
				
			Иначе
				
				// Очередная колонка ключа - здесь хранятся ключи следующего уровня
				Если СтрокиТекущегоУровня[ЗначениеКлюча] = Неопределено Тогда
					Прервать;
				КонецЕсли;
				СтрокиТекущегоУровня = СтрокиТекущегоУровня[ЗначениеКлюча];
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если Не Найден Тогда
			ДобавленныеСтроки.Добавить(СтрокаТаблицы);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДобавленныеСтроки;
	
КонецФункции

// Проверяет, есть ли право чтения переданных объектов у текущего сеанса.
// Для фоновых заданий считается что права есть всегда, т.к. регламентное задание может выполнять
// пользователь без прав в привилегированном режиме.
//
// Параметры:
//  Ссылки - Массив из ЛюбаяСсылка
// 
// Возвращаемое значение:
//  Булево
//
Функция ЕстьПравоЧтенияВсехОбъектов(Ссылки) Экспорт
	
	ЕстьПравоЧтенияВсехОбъектов = Истина;
	
	// Для фоновых заданий считается что права есть всегда, т.к. регламентное задание может выполнять
	// пользователь без прав в привилегированном режиме.
	Если ЭтоФоновоеЗадание() Тогда
		Возврат ЕстьПравоЧтенияВсехОбъектов;
	КонецЕсли;
	
	// Установим безопасный режим, чтобы даже при включенном привилегированном режиме, была проверка прав.
	УстановитьБезопасныйРежим(Истина);
	
	СсылкиПоТипам = ОбщегоНазначенияДокументооборотКлиентСервер.СоответствиеПоТипам(Ссылки);
	Для Каждого КлючИЗначение Из СсылкиПоТипам Цикл
		
		Тип = КлючИЗначение.Ключ;
		СсылкиТипа = КлючИЗначение.Значение;
		
		КоличествоСсылокТипа = СсылкиТипа.Количество();
		
		КоличествоДоступныхСсылок = 0;
		Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ПсевдонимЗаданнойТаблицы.Ссылка) КАК КоличествоДоступныхСсылок
			|ИЗ
			|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
			|ГДЕ
			|	ПсевдонимЗаданнойТаблицы.Ссылка В(&СсылкиТипа)");
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
		Запрос.УстановитьПараметр("СсылкиТипа", СсылкиТипа);
		//@skip-check query-in-loop
		// Для каждого типа выполяется отдельный запрос.
		РезультатЗапроса = Запрос.Выполнить();
		Выборка = РезультатЗапроса.Выбрать();
		Если Выборка.Следующий() Тогда
			КоличествоДоступныхСсылок = Выборка.КоличествоДоступныхСсылок;
		КонецЕсли;
		
		Если КоличествоСсылокТипа <> КоличествоДоступныхСсылок Тогда
			ЕстьПравоЧтенияВсехОбъектов = Ложь;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ЕстьПравоЧтенияВсехОбъектов;
	
КонецФункции

// Проверяет, есть ли право чтения переданного объекта у текущего сеанса.
// Для фоновых заданий считается что права есть всегда, т.к. регламентное задание может выполнять
// пользователь без прав в привилегированном режиме.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка
// 
// Возвращаемое значение:
//  Булево
//
Функция ЕстьПравоЧтенияОбъекта(Ссылка) Экспорт
	
	ЕстьПравоЧтенияОбъекта = Истина;
	
	// Для фоновых заданий считается что права есть всегда, т.к. регламентное задание может выполнять
	// пользователь без прав в привилегированном режиме.
	Если ЭтоФоновоеЗадание() Тогда
		Возврат ЕстьПравоЧтенияОбъекта;
	КонецЕсли;
	
	// Установим безопасный режим, чтобы даже при включенном привилегированном режиме, была проверка прав.
	УстановитьБезопасныйРежим(Истина);
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	ПсевдонимЗаданнойТаблицы.Ссылка КАК КоличествоДоступныхСсылок
		|ИЗ
		|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка");
	Тип = ТипЗнч(Ссылка);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
	ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	РезультатЗапроса = Запрос.Выполнить();
	ЕстьПравоЧтенияОбъекта = Не РезультатЗапроса.Пустой();
	
	Возврат ЕстьПравоЧтенияОбъекта;
	
КонецФункции

// Проверяет, является ли текущий сеанс фоновым заданием или нет.
// 
// Возвращаемое значение:
//  Булево
// 
Функция ЭтоФоновоеЗадание() Экспорт
	
	ТекущийСеансИнформационнойБазы = ПолучитьТекущийСеансИнформационнойБазы();
	ФоновоеЗадание = ТекущийСеансИнформационнойБазы.ПолучитьФоновоеЗадание();
	ЭтоФоновоеЗадание = ФоновоеЗадание <> Неопределено;
	
	Возврат ЭтоФоновоеЗадание;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Устаналивает стандартные цвета диаграммы отчета.
//
// Параметры:
//   Диаграмма - Диаграмма - оформляемая диаграмма.
//
Процедура УстановитьЦветаДиаграммы(Диаграмма) 
	
	Если Диаграмма.ТипДиаграммы = ТипДиаграммы.Гистограмма
		Или Диаграмма.ТипДиаграммы = ТипДиаграммы.ГистограммаГоризонтальная
		Или Диаграмма.ТипДиаграммы = ТипДиаграммы.ГистограммаСНакоплением
		Или Диаграмма.ТипДиаграммы = ТипДиаграммы.ГистограммаСНакоплениемГоризонтальная Тогда
		
		НомерОбласти = 0; 
		КоличествоСерий = Диаграмма.Серии.Количество();
		Для Каждого Серия из Диаграмма.Серии Цикл
			Если КоличествоСерий <= 4 Тогда
				Серия.Цвет = ОттенокЦвета(НомерОбласти, 5, 1); // начиная со светло-синего
			Иначе
				Серия.Цвет = КонтрастныйЦвет(НомерОбласти, 5, 1); // начиная со светло-синего
			КонецЕсли;
			НомерОбласти = НомерОбласти + 1;
		КонецЦикла;
		
	ИначеЕсли Диаграмма.ТипДиаграммы = ТипДиаграммы.График
		Или Диаграмма.ТипДиаграммы = ТипДиаграммы.ГрафикПоШагам
		Или Диаграмма.ТипДиаграммы = ТипДиаграммы.ГрафикСОбластями Тогда
		
		НомерОбласти = 0;
		Для Каждого Серия из Диаграмма.Серии Цикл
			Серия.Цвет = ЦветОттенка(НомерОбласти, 5, 5); // начиная с темно-синего
			НомерОбласти = НомерОбласти + 1;
		КонецЦикла;
		
	ИначеЕсли Диаграмма.ТипДиаграммы = ТипДиаграммы.Круговая Тогда
		
		НомерОбласти = 0;
		Для Каждого Серия из Диаграмма.Серии Цикл
			Серия.Цвет = КонтрастныйЦвет(НомерОбласти, 5, 1); // начиная со светло-синего
			НомерОбласти = НомерОбласти + 1;
		КонецЦикла;
		
	Иначе
		
		НомерОбласти = 0;
		Для Каждого Серия из Диаграмма.Серии Цикл
			Серия.Цвет = ОттенокЦвета(НомерОбласти, 5, 1); // начиная со светло-синего
			НомерОбласти = НомерОбласти + 1;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает цвет для указанной области диаграммы, подходящий для диаграмм с большим количеством
// областей. Чередует цвета и избегает слишком светлых цветов.
//
// Параметры:
//   НомерОбласти - Число - номер области (серии, точки) диаграммы.
//   БазовыйЦвет - Число - цвет палитры для области с номером 0.
//   БазовыйОттенок - Число - оттенок палитры для области с номером 0.
//
// Возвращаемое значение:
//   Цвет - цвет из палитры для указанной области.
//
Функция КонтрастныйЦвет(НомерОбласти, БазовыйЦвет, БазовыйОттенок)
	
	Позиция = БазовыйЦвет * 8 + БазовыйОттенок + НомерОбласти * 21;
	НомерЦвета = Цел(Позиция / 8) % 8;
	НомерОттенка = Позиция % 8;
	Если НомерОттенка = 3 И НомерЦвета = 3 Тогда
		НомерЦвета = НомерЦвета - 1;
	ИначеЕсли НомерОттенка = 3 И НомерЦвета = 7 Тогда
		НомерЦвета = НомерЦвета - 1;
	КонецЕсли;

	Возврат ЦветПалитры(НомерЦвета, НомерОттенка);
	
КонецФункции

// Возвращает цвет для указанной области диаграммы, подходящий для диаграмм с небольшим (2-4)
// количеством областей. Дает оттенки одного цвета и избегает слишком светлых цветов.
//
// Параметры:
//   НомерОбласти - Число - номер области (серии, точки) диаграммы.
//   БазовыйЦвет - Число - цвет палитры для области с номером 0.
//   БазовыйОттенок - Число - оттенок палитры для области с номером 0.
//
// Возвращаемое значение:
//   Цвет - цвет из палитры для указанной области.
//
Функция ОттенокЦвета(НомерОбласти, БазовыйЦвет, БазовыйОттенок)
	
	НомерОттенка = (БазовыйОттенок + 5 * НомерОбласти) % 8;
	Если (НомерОттенка = 3 И БазовыйЦвет = 3)
		Или (НомерОттенка = 3 И БазовыйЦвет = 7) Тогда
		НомерЦвета = БазовыйЦвет - 1;
	Иначе
		НомерЦвета = БазовыйЦвет;
	КонецЕсли;
	
	Возврат ЦветПалитры(НомерЦвета, НомерОттенка);
	
КонецФункции

// Возвращает цвет для указанной области диаграммы, подходящий для графиков с небольшим (2-4)
// количеством серий. Чередует цвета одного оттенка (светлоты). Не избегает светлых цветов.
//
// Параметры:
//   НомерОбласти - Число - номер области (серии, точки) диаграммы.
//   БазовыйЦвет - Число - цвет палитры для области с номером 0.
//   БазовыйОттенок - Число - оттенок палитры для области с номером 0.
//
// Возвращаемое значение:
//   Цвет - цвет из палитры для указанной области.
//
Функция ЦветОттенка(НомерОбласти, БазовыйЦвет, БазовыйОттенок)
	
	НомерЦвета = (БазовыйЦвет + 5 * НомерОбласти) % 8;
	
	Возврат ЦветПалитры(НомерЦвета, БазовыйОттенок);
	
КонецФункции

// Возвращает цвет из стандартной палитры по номеру цвета и номеру оттенка.
//
// Параметры:
//   НомерЦвета - Число - 0...7, номер цвета.
//   НомерОттенка - Число - 0...7, номер оттенка указанного цвета.
//     Оттенки светлеют от 0 (средний) до 3 (самый светлый) и
//     темнеют до 7 (самый темный).
//
// Возвращаемое значение:
//   Цвет - цвет палитры.
//
Функция ЦветПалитры(НомерЦвета, НомерОттенка)
	
	Если НомерЦвета = 0 Тогда // красный и бордо
		Если НомерОттенка = 0 Тогда Возврат Новый Цвет(229,85,85);
		ИначеЕсли НомерОттенка = 1 Тогда Возврат Новый Цвет(234,119,119);
		ИначеЕсли НомерОттенка = 2 Тогда Возврат Новый Цвет(239,153,153);
		ИначеЕсли НомерОттенка = 3 Тогда Возврат Новый Цвет(245,187,187);
		ИначеЕсли НомерОттенка = 4 Тогда Возврат Новый Цвет(207,77,91);
		ИначеЕсли НомерОттенка = 5 Тогда Возврат Новый Цвет(167,69,81);
		ИначеЕсли НомерОттенка = 6 Тогда Возврат Новый Цвет(130,65,73);
		ИначеЕсли НомерОттенка = 7 Тогда Возврат Новый Цвет(117,70,59);
		КонецЕсли;
		
	ИначеЕсли НомерЦвета = 1 Тогда // оранжевый и коричневый
		Если НомерОттенка = 0 Тогда Возврат Новый Цвет(239,116,78);
		ИначеЕсли НомерОттенка = 1 Тогда Возврат Новый Цвет(242,144,113);
		ИначеЕсли НомерОттенка = 2 Тогда Возврат Новый Цвет(245,172,149);
		ИначеЕсли НомерОттенка = 3 Тогда Возврат Новый Цвет(249,199,184);
		ИначеЕсли НомерОттенка = 4 Тогда Возврат Новый Цвет(228,119,56);
		ИначеЕсли НомерОттенка = 5 Тогда Возврат Новый Цвет(176,104,62);
		ИначеЕсли НомерОттенка = 6 Тогда Возврат Новый Цвет(136,86,59);
		ИначеЕсли НомерОттенка = 7 Тогда Возврат Новый Цвет(123,99,55);
		Иначе
		КонецЕсли;
		
	ИначеЕсли НомерЦвета = 2 Тогда // желтый и хаки
		Если НомерОттенка = 0 Тогда Возврат Новый Цвет(251, 221, 100);
		ИначеЕсли НомерОттенка = 1 Тогда Возврат Новый Цвет(252,228,131);
		ИначеЕсли НомерОттенка = 2 Тогда Возврат Новый Цвет(253,235,162);
		ИначеЕсли НомерОттенка = 3 Тогда Возврат Новый Цвет(253,241,193);
		ИначеЕсли НомерОттенка = 4 Тогда Возврат Новый Цвет(237,203,74);
		ИначеЕсли НомерОттенка = 5 Тогда Возврат Новый Цвет(189,163,67);
		ИначеЕсли НомерОттенка = 6 Тогда Возврат Новый Цвет(143,125,63);
		ИначеЕсли НомерОттенка = 7 Тогда Возврат Новый Цвет(122,128,58);
		Иначе
		КонецЕсли;
		
	ИначеЕсли НомерЦвета = 3 Тогда // зеленый
		Если НомерОттенка = 0 Тогда Возврат Новый Цвет(171,221,185);
		ИначеЕсли НомерОттенка = 1 Тогда Возврат Новый Цвет(188,228,199);
		ИначеЕсли НомерОттенка = 2 Тогда Возврат Новый Цвет(205,235,213);
		ИначеЕсли НомерОттенка = 3 Тогда Возврат Новый Цвет(221,241,227);
		ИначеЕсли НомерОттенка = 4 Тогда Возврат Новый Цвет(148,194,161);
		ИначеЕсли НомерОттенка = 5 Тогда Возврат Новый Цвет(123,157,133);
		ИначеЕсли НомерОттенка = 6 Тогда Возврат Новый Цвет(99,121,106);
		ИначеЕсли НомерОттенка = 7 Тогда Возврат Новый Цвет(90,111,103);
		Иначе
		КонецЕсли;
		
	ИначеЕсли НомерЦвета = 4 Тогда // голубой и циан
		Если НомерОттенка = 0 Тогда Возврат Новый Цвет(104,187,219);
		ИначеЕсли НомерОттенка = 1 Тогда Возврат Новый Цвет(134,201,226);
		ИначеЕсли НомерОттенка = 2 Тогда Возврат Новый Цвет(164,214,233);
		ИначеЕсли НомерОттенка = 3 Тогда Возврат Новый Цвет(195,228,241);
		ИначеЕсли НомерОттенка = 4 Тогда Возврат Новый Цвет(93,164,197);
		ИначеЕсли НомерОттенка = 5 Тогда Возврат Новый Цвет(81,135,159);
		ИначеЕсли НомерОттенка = 6 Тогда Возврат Новый Цвет(73,108,124);
		ИначеЕсли НомерОттенка = 7 Тогда Возврат Новый Цвет(66,84,112);
		Иначе
		КонецЕсли;
		
	ИначеЕсли НомерЦвета = 5 Тогда // синий
		Если НомерОттенка = 0 Тогда Возврат Новый Цвет(136,160,210);
		ИначеЕсли НомерОттенка = 1 Тогда Возврат Новый Цвет(160,179,219);
		ИначеЕсли НомерОттенка = 2 Тогда Возврат Новый Цвет(184,198,228);
		ИначеЕсли НомерОттенка = 3 Тогда Возврат Новый Цвет(207,217,237);
		ИначеЕсли НомерОттенка = 4 Тогда Возврат Новый Цвет(119,138,187);
		ИначеЕсли НомерОттенка = 5 Тогда Возврат Новый Цвет(102,117,152);
		ИначеЕсли НомерОттенка = 6 Тогда Возврат Новый Цвет(86,96,119);
		ИначеЕсли НомерОттенка = 7 Тогда Возврат Новый Цвет(79,80,108);
		Иначе
		КонецЕсли;
		
	ИначеЕсли НомерЦвета = 6 Тогда // фиолетовый
		Если НомерОттенка = 0 Тогда Возврат Новый Цвет(149,133,244);
		ИначеЕсли НомерОттенка = 1 Тогда Возврат Новый Цвет(170,157,246);
		ИначеЕсли НомерОттенка = 2 Тогда Возврат Новый Цвет(191,182,248);
		ИначеЕсли НомерОттенка = 3 Тогда Возврат Новый Цвет(213,206,251);
		ИначеЕсли НомерОттенка = 4 Тогда Возврат Новый Цвет(132,115,215);
		ИначеЕсли НомерОттенка = 5 Тогда Возврат Новый Цвет(111,98,173);
		ИначеЕсли НомерОттенка = 6 Тогда Возврат Новый Цвет(92,83,133);
		ИначеЕсли НомерОттенка = 7 Тогда Возврат Новый Цвет(98,76,121);
		Иначе
		КонецЕсли;
		
	ИначеЕсли НомерЦвета = 7 Тогда // розовый и маджента
		Если НомерОттенка = 0 Тогда Возврат Новый Цвет(210,170,226);
		ИначеЕсли НомерОттенка = 1 Тогда Возврат Новый Цвет(219,187,232);
		ИначеЕсли НомерОттенка = 2 Тогда Возврат Новый Цвет(228,204,238);
		ИначеЕсли НомерОттенка = 3 Тогда Возврат Новый Цвет(237,221,243);
		ИначеЕсли НомерОттенка = 4 Тогда Возврат Новый Цвет(185,146,197);
		ИначеЕсли НомерОттенка = 5 Тогда Возврат Новый Цвет(150,122,160);
		ИначеЕсли НомерОттенка = 6 Тогда Возврат Новый Цвет(118,99,123);
		ИначеЕсли НомерОттенка = 7 Тогда Возврат Новый Цвет(111,90,108);
		КонецЕсли;
			
	КонецЕсли;
	
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Недопустимый цвет палитры: (%1, %2)'"),
		НомерЦвета,
		НомерОттенка);
		
	ВызватьИсключение ТекстСообщения;
	
КонецФункции

Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

// Преобразует строку реквизитов в массив реквизитов.
//
// Параметры:
//  СтрокаРеквизитов - Строка - Строка реквизитов.
// 
// Возвращаемое значение:
//  Массив - Массив реквизитов.
//
Функция МассивРеквизитов(СтрокаРеквизитов)
	
	МассивРеквизитов = Новый Массив;
	Для Каждого Реквизит Из СтрРазделить(СтрокаРеквизитов, ",") Цикл
		
		Реквизит = СокрЛП(Реквизит);
		
		МассивРеквизитов.Добавить(Реквизит);
		
	КонецЦикла;
	
	Возврат МассивРеквизитов;
	
КонецФункции

// Преобразует массив реквизитов в строку реквизитов.
//
// Параметры:
//  МассивРеквизитов - Массив - Массив реквизитов.
// 
// Возвращаемое значение:
//  Массив - Строка реквизитов.
//
Функция СтрокаРеквизитов(МассивРеквизитов)
	
	Возврат СтрСоединить(МассивРеквизитов, ", ");
	
КонецФункции

// Шлет письмо по легкой почте и делает запись в журнал регистрации
// 
// Параметры:
//  Наименование - Строка - наименование (для наименования бизнес процесса или Темы письма)
//  Описание - Строка - подробное описание
//  ИмяЗаписиЖурналаРегистрации - Строка - для имени события в журнале регистрации
//  Метаданные - Метаданные, Неопределено - Метаданные для события в ЖР
//  Данные - ЛюбаяСсылка, Неопределено - Данные для события в ЖР
Процедура УведомитьОтветственныхОПроблеме(Наименование, Описание, ИмяЗаписиЖурналаРегистрации,
		Метаданные = Неопределено, Данные = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ЗаписьЖурналаРегистрации(
		ИмяЗаписиЖурналаРегистрации,
		УровеньЖурналаРегистрации.Ошибка,
		Метаданные,
		Данные,
		Описание);
	
	МассивСотрудников = РаботаСУведомлениями.СписокПолучателейУведомленийОПроблемах(
			Перечисления.РазделыУведомленийОПроблемах.Администрирование);
			
	Если МассивСотрудников.Количество() = 0 Тогда
		
		Возврат;
		
	КонецЕсли;	
	
	// в ЖР пишем, но по почте не отправляем, если копия базы
	Если РегламентныеЗаданияСервер.РаботаСВнешнимиРесурсамиЗаблокирована() Тогда
		Возврат;
	КонецЕсли;	
		
	АдресаОповещения = "";
	
	Для Каждого Сотрудник Из МассивСотрудников Цикл
		
		Адрес = ВстроеннаяПочтаСервер.ПолучитьОсновнойАдрес(Сотрудник);
		
		Если ЗначениеЗаполнено(Адрес) Тогда          
			
			Если ЗначениеЗаполнено(АдресаОповещения) Тогда
				АдресаОповещения = АдресаОповещения + ";";
			КонецЕсли;	
			
			АдресаОповещения = АдресаОповещения + Адрес;
			
		КонецЕсли;	
		
	КонецЦикла;
	
	Попытка
	
//		НаименованиеУзла = ОбщегоНазначенияДокументооборот.НаименованиеУзлаБазы();
//		ПолнаяТема = СтрШаблон(НСтр("ru = '%1. %2'"), НаименованиеУзла, Наименование);
		ПолнаяТема = Наименование; 
		
		ПараметрыПисьма = Новый Структура;
		ПараметрыПисьма.Вставить("Тема", ПолнаяТема);
		ПараметрыПисьма.Вставить("Текст", Описание);
		ПараметрыПисьма.Вставить("Кому", АдресаОповещения);
		ПараметрыПисьма.Вставить("ТипТекста", Перечисления.ТипыТекстовПочтовыхСообщений.ПростойТекст);
	
	Исключение
		
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1: %2. %3.'"),
			ИмяЗаписиЖурналаРегистрации, Наименование, ОписаниеОшибки);
			
		ЗаписьЖурналаРегистрации(
			ИмяЗаписиЖурналаРегистрации,
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные,
			Данные,
			ТекстСообщения);
			
	КонецПопытки;
	
	СообщениеОбОшибке = "";
	
	Попытка
		
		КодВозврата = ЛегкаяПочтаСервер.ОтправитьИнтернетПочта(ПараметрыПисьма,,,СообщениеОбОшибке);
		
		Если КодВозврата = Ложь Тогда
			
			ЗаписьЖурналаРегистрации(
				ИмяЗаписиЖурналаРегистрации,
				УровеньЖурналаРегистрации.Ошибка,
				Метаданные,
				Данные,
				СообщениеОбОшибке);
			
		КонецЕсли;	
		
	Исключение
		
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1: %2.'"),
			ИмяЗаписиЖурналаРегистрации, ОписаниеОшибки);
			
		ЗаписьЖурналаРегистрации(
			ИмяЗаписиЖурналаРегистрации,
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные,
			Данные,
			ТекстСообщения);
			
	КонецПопытки;
	
КонецПроцедуры	

// Устарела. Следует использовать ВыполнитьВФоне.
//
// Запускает выполнение процедуры в фоновом задании.
// Является менее функциональным аналогом ВыполнитьВФоне, предусмотрена для обратной совместимости.
// 
// Параметры:
//  ИдентификаторФормы     - УникальныйИдентификатор - идентификатор формы, 
//                           из которой выполняется запуск длительной операции. 
//  ИмяЭкспортнойПроцедуры - Строка - имя экспортной процедуры, 
//                           которую необходимо выполнить в фоне.
//  Параметры              - Структура - все необходимые параметры для 
//                           выполнения процедуры ИмяЭкспортнойПроцедуры.
//  НаименованиеЗадания    - Строка - наименование фонового задания. 
//                           Если не задано, то будет равно ИмяЭкспортнойПроцедуры. 
//  ИспользоватьДополнительноеВременноеХранилище - Булево - признак использования
//                           дополнительного временного хранилища для передачи данных
//                           в родительский сеанс из фонового задания. По умолчанию - Ложь.
//
// Возвращаемое значение:
//  Структура              - параметры выполнения задания: 
//   * АдресХранилища  - Строка     - адрес временного хранилища, в которое будет
//                                    помещен результат работы задания;
//   * АдресХранилищаДополнительный - Строка - адрес дополнительного временного хранилища,
//                                    в которое будет помещен результат работы задания (доступно только если 
//                                    установлен параметр ИспользоватьДополнительноеВременноеХранилище);
//   * ИдентификаторЗадания - УникальныйИдентификатор - уникальный идентификатор запущенного фонового задания;
//   * ЗаданиеВыполнено - Булево - Истина если задание было успешно выполнено за время вызова функции.
// 
Функция ЗапуститьВыполнениеВФоне(Знач ИдентификаторФормы, Знач ИмяЭкспортнойПроцедуры, Знач Параметры,
	Знач НаименованиеЗадания = "", ИспользоватьДополнительноеВременноеХранилище = Ложь, ВремяОжидания = 0) Экспорт
	
	АдресХранилища = ПоместитьВоВременноеХранилище(Неопределено, ИдентификаторФормы);
	
	Результат = Новый Структура;
	Результат.Вставить("АдресХранилища",       АдресХранилища);
	Результат.Вставить("ЗаданиеВыполнено",     Ложь);
	Результат.Вставить("ИдентификаторЗадания", Неопределено);
	
	Если Не ЗначениеЗаполнено(НаименованиеЗадания) Тогда
		НаименованиеЗадания = ИмяЭкспортнойПроцедуры;
	КонецЕсли;
	
	ПараметрыЭкспортнойПроцедуры = Новый Массив;
	ПараметрыЭкспортнойПроцедуры.Добавить(Параметры);
	ПараметрыЭкспортнойПроцедуры.Добавить(АдресХранилища);
	
	Если ИспользоватьДополнительноеВременноеХранилище Тогда
		АдресХранилищаДополнительный = ПоместитьВоВременноеХранилище(Неопределено, ИдентификаторФормы);
		ПараметрыЭкспортнойПроцедуры.Добавить(АдресХранилищаДополнительный);
	КонецЕсли;
	
	ЗапущеноЗаданий = 0;
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая()
		И Не ОбновлениеИнформационнойБазы.НеобходимоОбновлениеИнформационнойБазы() Тогда
		Отбор = Новый Структура;
		Отбор.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
		ЗапущеноЗаданий = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор).Количество();
	КонецЕсли;
	
	Если ОбщегоНазначения.РежимОтладки()
		Или ЗапущеноЗаданий > 0 Тогда
		ОбщегоНазначения.ВыполнитьМетодКонфигурации(ИмяЭкспортнойПроцедуры, ПараметрыЭкспортнойПроцедуры);
		Результат.ЗаданиеВыполнено = Истина;
	Иначе
		Если ВремяОжидания = 0 Тогда
			ВремяОжидания = ?(ПолучитьСкоростьКлиентскогоСоединения() = СкоростьКлиентскогоСоединения.Низкая, 4, 2);
		КонецЕсли;
		ПараметрыВыполнения = ДлительныеОперации.ПараметрыВыполненияВФоне(Неопределено);
		ПараметрыВыполнения.НаименованиеФоновогоЗадания = НаименованиеЗадания;
		БезопасныйРежим = БезопасныйРежим();
		УстановитьОтключениеБезопасногоРежима(Истина);
		Задание = ДлительныеОперации.ЗапуститьФоновоеЗаданиеСКонтекстомКлиента(ИмяЭкспортнойПроцедуры,
			ПараметрыВыполнения, ПараметрыЭкспортнойПроцедуры, БезопасныйРежим);
		УстановитьОтключениеБезопасногоРежима(Ложь);
		
		Задание = Задание.ОжидатьЗавершенияВыполнения(ВремяОжидания);
		
		Статус = ДлительныеОперации.ОперацияВыполнена(Задание.УникальныйИдентификатор);
		Результат.ЗаданиеВыполнено = Статус.Статус = "Выполнено";
		Результат.ИдентификаторЗадания = Задание.УникальныйИдентификатор;
	КонецЕсли;
	
	Если ИспользоватьДополнительноеВременноеХранилище Тогда
		Результат.Вставить("АдресХранилищаДополнительный", АдресХранилищаДополнительный);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Обработчик регламентного задания "Обслуживание итогов".
// 
Процедура ОбслуживаниеИтогов() Экспорт
	
	Отказ = Ложь;
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(
		Метаданные.РегламентныеЗадания.ОбслуживаниеИтогов,
		Отказ);
	
	Если Отказ = Истина Тогда
		Возврат;
	КонецЕсли;
	
	РегистрыНакопленияКОбработке = Новый Массив;
	РегистрыНакопленияКОбработке.Добавить(РегистрыНакопления.КоличествоКонтролей);
	
	Для Каждого РегистрНакопленияМенеджер Из РегистрыНакопленияКОбработке Цикл
		РегистрНакопленияМенеджер.ПересчитатьТекущиеИтоги();
	КонецЦикла;
	
КонецПроцедуры

// Преобразует имена ключевых колонок в массив.
//
// Параметры:
//  ИменаКлючевыхКолонок - Строка - Имена ключевыхх колонок, разеделены через символ ",".
// 
// Возвращаемое значение:
//  Массив из Строка
//
Функция МассивИменКлючевыхКолонок(ИменаКлючевыхКолонок)
	
	РазделительКлючевыхКолонок = ",";
	ВключатьПустые = Ложь;
	МассивИменКлючевыхКолонок = СтрРазделить(ИменаКлючевыхКолонок, РазделительКлючевыхКолонок, ВключатьПустые);
	Для Индекс = 0 По МассивИменКлючевыхКолонок.ВГраница() Цикл
		МассивИменКлючевыхКолонок[Индекс] = СокрЛП(МассивИменКлючевыхКолонок[Индекс]);
	КонецЦикла;
	
	Возврат МассивИменКлючевыхКолонок;
	
КонецФункции

// Преобразует таблицу в соответствие по указанным ключам.
//
// Параметры:
//  Таблица - ТаблицаЗначений
//  МассивИменКлючевыхКолонок - Массив из Строка
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение
//
Функция СтрокиПоКлючам(Таблица, МассивИменКлючевыхКолонок)
	
	СтрокиПоКлючам = Новый Соответствие;
	Если МассивИменКлючевыхКолонок.Количество() = 0 Тогда
		Возврат СтрокиПоКлючам;
	КонецЕсли;
	
	ИндексПоследнегоКлюча = МассивИменКлючевыхКолонок.ВГраница();
	ИмяПоследнегоКлюча = МассивИменКлючевыхКолонок[ИндексПоследнегоКлюча];
	
	Для Каждого СтрокаТаблицы Из Таблица Цикл
		
		СтрокиТекущегоУровня = СтрокиПоКлючам;
		Для Каждого ИмяКлючевойКолонки Из МассивИменКлючевыхКолонок Цикл
			
			ЗначениеКлюча = СтрокаТаблицы[ИмяКлючевойКолонки];
			
			Если ИмяКлючевойКолонки = ИмяПоследнегоКлюча Тогда
				
				// Последняя колонка ключа - здесь хранятся конкретные значения строка.
				СтрокиТекущегоУровня[ЗначениеКлюча] = СтрокаТаблицы;
				
			Иначе
				
				// Очередная колонка ключа - здесь хранятся ключи следующего уровня
				Если СтрокиТекущегоУровня[ЗначениеКлюча] = Неопределено Тогда
					СтрокиТекущегоУровня[ЗначениеКлюча] = Новый Соответствие;
				КонецЕсли;
				СтрокиТекущегоУровня = СтрокиТекущегоУровня[ЗначениеКлюча];
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат СтрокиПоКлючам;
	
КонецФункции

// Определяет удаленные строки.
//
// Параметры:
//  НоваяТаблица - ТаблицаЗначений
//  СтараяТаблица - ТаблицаЗначений
//  ИменаКлючевыхКолонок - Строка - Имена ключевыхх колонок, разеделены через символ ",".
// 
// Возвращаемое значение:
//  Массив из СтрокаТаблицыЗначений
//
Функция УдаленныеСтроки(НоваяТаблица, СтараяТаблица, ИменаКлючевыхКолонок)
	
	// Для расчета удаленных строк, нужно найти добавленные строки в старую таблицу относительно новой.
	УдаленныеСтроки = ДобавленныеСтроки(СтараяТаблица, НоваяТаблица, ИменаКлючевыхКолонок);
	
	Возврат УдаленныеСтроки;
	
КонецФункции

#КонецОбласти
