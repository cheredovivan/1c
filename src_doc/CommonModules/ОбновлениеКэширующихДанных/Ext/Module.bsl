////////////////////////////////////////////////////////////////////////////////
// Обновление кэширующих данных (сервер).
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Обработчик регламентного задания.
//
Процедура ОбновлениеКэширующихДанных() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(
		Метаданные.РегламентныеЗадания.ОбновлениеКэширующихДанных);
	
	ДатаСегодня = НачалоДня(ТекущаяДатаСеанса());
	ДатаСбросаПопыток = Константы.ДатаСбросаПопытокОбработкиКэширующихДанных.Получить();
	Если ДатаСегодня <> ДатаСбросаПопыток Тогда
		
		Константы.ДатаСбросаПопытокОбработкиКэширующихДанных.Установить(ДатаСегодня);
		
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			СброситьПопытки();
		Иначе
			ФоновыеЗадания.Выполнить("ОбновлениеКэширующихДанных.СброситьПопытки");
		КонецЕсли;
		
	КонецЕсли;
	
	Долгое = Ложь;
	ЗапуститьПотокиОбновленияКэширующихДанных(Долгое);
	
	Долгое = Истина;
	ЗапуститьПотокиОбновленияКэширующихДанных(Долгое);
	
КонецПроцедуры

// Формирует событие журнала регистрации.
//
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - Полное имя обрабатываемого объекта метаданных.
// 
// Возвращаемое значение:
//  Строка - Событие журнала регистрации.
//
Функция СобытиеЖурналаРегистрации(ПолноеИмяОбъектаМетаданных) Экспорт
	
	Возврат СтрШаблон(
		НСтр("ru = 'Обновление кэширующих данных.%1'", ОбщегоНазначения.КодОсновногоЯзыка()),
		ПолноеИмяОбъектаМетаданных);
	
КонецФункции

// Сбрасывает попытки обработки.
//  
Процедура СброситьПопытки() Экспорт
	
	НомерЦикла = 0;
	ЕстьДанныеКОбработке = Истина;
	Пока ЕстьДанныеКОбработке Цикл
		
		ЕстьДанныеКОбработке = Ложь;
		
		Запрос = Новый Запрос(
			"ВЫБРАТЬ ПЕРВЫЕ 1000
			|	ОчередьОбновленияКэширующихДанных.ВлияющийОбъектМетаданных,
			|	ОчередьОбновленияКэширующихДанных.ЗависимыйОбъектМетаданных,
			|	ОчередьОбновленияКэширующихДанных.КлючВлияющихДанных,
			|	ОчередьОбновленияКэширующихДанных.ОтметкаВремени
			|ИЗ
			|	РегистрСведений.ОчередьОбновленияКэширующихДанных КАК ОчередьОбновленияКэширующихДанных
			|ГДЕ
			|	ОчередьОбновленияКэширующихДанных.Попыток >= 3");
		
		//@skip-check query-in-loop
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			
			ЕстьДанныеКОбработке = Истина;
			
			РегистрыСведений.ОчередьОбновленияКэширующихДанных.СброситьПопытки(
				Выборка.ОтметкаВремени,
				Выборка.ЗависимыйОбъектМетаданных,
				Выборка.ВлияющийОбъектМетаданных,
				Выборка.КлючВлияющихДанных);
			
		КонецЦикла;
		
		НомерЦикла = НомерЦикла + 1;
		Если НомерЦикла > 10000 Тогда
			ВызватьИсключение НСтр("ru = 'Обнаружено зацикливание'");
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует структуру изменений влияющих данных.
// 
// Параметры:
//  Объект - СправочникОбъект,
//           ДокументОбъект.
//  ВлияющиеДанные - Строка.
// 
// Возвращаемое значение:
//  См. ОбновлениеКэширующихДанных.НовыеИзмененияВлияющихДанных.
// 
Функция ИзмененияВлияющихДанных(Объект, ВлияющиеДанные) Экспорт
	
	Если Не Объект.ДополнительныеСвойства.Свойство("ПредыдущиеЗначенияРеквизитов") Тогда
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Предыдущие значения реквизитов объекта %1 (%2) не инициализированы.
				|Для инициализации необходимо вызвать процедуру УстановитьДополнительноеСвойствоПредыдущиеЗначенияРеквизитов.'"),
			Объект,
			ТипЗнч(Объект));
	КонецЕсли;
	
	ИзмененияВлияющихДанных = НовыеИзмененияВлияющихДанных();
	
	ПредыдущиеЗначенияРеквизитов = Объект.ДополнительныеСвойства.ПредыдущиеЗначенияРеквизитов;
	
	ВлияющиеРеквизиты = СтрРазделить(ВлияющиеДанные, ",", Ложь);
	
	Для Каждого ВлияющийРеквизит Из ВлияющиеРеквизиты Цикл
		
		ВлияющийРеквизит = СокрЛП(ВлияющийРеквизит);
		
		ПредыдущееЗначениеРеквизита = ПредыдущиеЗначенияРеквизитов[ВлияющийРеквизит];
		ИзмененияВлияющихДанных.ПредыдущиеЗначенияРеквизитов.Вставить(
			ВлияющийРеквизит,
			ПредыдущееЗначениеРеквизита);
		
		Если ТипЗнч(ПредыдущееЗначениеРеквизита) = Тип("ТаблицаЗначений") Тогда
			НовоеЗначениеРеквизита = Объект[ВлияющийРеквизит].Выгрузить();
		Иначе
			НовоеЗначениеРеквизита = Объект[ВлияющийРеквизит];
		КонецЕсли;
		ИзмененияВлияющихДанных.НовыеЗначенияРеквизитов.Вставить(
			ВлияющийРеквизит,
			НовоеЗначениеРеквизита);
		
	КонецЦикла;
	
	Возврат ИзмененияВлияющихДанных;
	
КонецФункции

// Формирует пустую структуру изменений влияющих данных.
// 
// Возвращаемое значение:
//  Структура - Изменения влияющих данных:
//   * ПредыдущиеЗначенияРеквизитов - Структура. 
//   * НовыеЗначенияРеквизитов - Структура.
//   * ВариантОбновления - Строка.
// 
Функция НовыеИзмененияВлияющихДанных() Экспорт
	
	ИзмененияВлияющихДанных = Новый Структура;
	ИзмененияВлияющихДанных.Вставить("ПредыдущиеЗначенияРеквизитов", Новый Структура);
	ИзмененияВлияющихДанных.Вставить("НовыеЗначенияРеквизитов", Новый Структура);
	ИзмененияВлияющихДанных.Вставить("ВариантОбновления", "");
	
	Возврат ИзмененияВлияющихДанных;
	
КонецФункции

// Обрабатывает изменение влияющих данных, формирует очередь обновления кэширующих данных.
// 
// Параметры:
//  Объект - СправочникОбъект,
//           ДокументОбъект.
//  ЗависимыйОбъектМетаданных - Строка.
//  ВлияющийОбъектМетаданных - Строка.
//  КлючВлияющихДанных - СправочникСсылка,
//                       ДокументСсылка.
//  ВлияющиеРеквизиты - Строка.
//  ВариантОбновления - Строка.
// 
Процедура ОбработатьИзменениеВлияющихДанных(
	Объект, 
	ЗависимыйОбъектМетаданных,
	ВлияющийОбъектМетаданных,
	КлючВлияющихДанных,
	ВлияющиеРеквизиты,
	ВариантОбновления = "") Экспорт
	
	ЕстьИзмененияВлияющихДанных =
		Объект.ДополнительныеСвойства.Свойство("ЭтоРазборОчередиПостобработки")
		Или ОбщегоНазначенияДокументооборот.ИзменилосьЗначениеРеквизитов(
			Объект,
			ВлияющиеРеквизиты);
	Если Не ЕстьИзмененияВлияющихДанных Тогда
		Возврат;
	КонецЕсли;
	
	ИзмененияВлияющихДанных = ИзмененияВлияющихДанных(Объект, ВлияющиеРеквизиты);
	ИзмененияВлияющихДанных.ВариантОбновления = ВариантОбновления;
	
	РегистрыСведений.ОчередьОбновленияКэширующихДанных.Добавить(
		ЗависимыйОбъектМетаданных,
		ВлияющийОбъектМетаданных,
		КлючВлияющихДанных,
		ИзмененияВлияющихДанных);
	
КонецПроцедуры

// Обновляет кэширующие данные.
// 
// Параметры:
//  Долгое - Булево
// 
// Возвращаемое значение:
//  Булево - Есть обработанные данные.
// 
Функция ОбработатьОчередьОбновленияКэширующихДанных(Долгое) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ЕстьОбработанныеДанные = Ложь;
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 500
		|	Очередь.ОтметкаВремени КАК ОтметкаВремени,
		|	Очередь.ЗависимыйОбъектМетаданных КАК ЗависимыйОбъектМетаданных,
		|	Очередь.ВлияющийОбъектМетаданных КАК ВлияющийОбъектМетаданных,
		|	Очередь.КлючВлияющихДанных КАК КлючВлияющихДанных,
		|	Очередь.Автор КАК Автор,
		|	Очередь.ЗагрузкаОбработанныхДанныхИзДругойСистемы КАК ЗагрузкаОбработанныхДанныхИзДругойСистемы,
		|	Очередь.ИзмененияВлияющихДанных КАК ИзмененияВлияющихДанных,
		|	Очередь.Попыток КАК Попыток,
		|	Очередь.ДатаКОбработке КАК ДатаКОбработке,
		|	Очередь.Долгое КАК Долгое
		|ИЗ
		|	РегистрСведений.ОчередьОбновленияКэширующихДанных КАК Очередь
		|ГДЕ
		|	Очередь.Долгое = &Долгое
		|	И Очередь.Попыток < 3
		|
		|УПОРЯДОЧИТЬ ПО
		|	ОтметкаВремени");
	
	Запрос.УстановитьПараметр("Долгое", Долгое);

	Выборка = Запрос.Выполнить().Выбрать();     
	
	Пока Выборка.Следующий() Цикл
		
		Попытка
			ЗначениеКлюча = Новый Структура;
			ЗначениеКлюча.Вставить("ОтметкаВремени", Выборка.ОтметкаВремени);
			ЗначениеКлюча.Вставить("ЗависимыйОбъектМетаданных", Выборка.ЗависимыйОбъектМетаданных);
			ЗначениеКлюча.Вставить("ВлияющийОбъектМетаданных", Выборка.ВлияющийОбъектМетаданных);
			ЗначениеКлюча.Вставить("КлючВлияющихДанных", Выборка.КлючВлияющихДанных);
			КлючБлокировки = РегистрыСведений.ОчередьОбновленияКэширующихДанных.СоздатьКлючЗаписи(
				ЗначениеКлюча);
			ЗаблокироватьДанныеДляРедактирования(КлючБлокировки);
		Исключение
			// Объектная блокировка используется для распределения по потокам.
			Продолжить;
		КонецПопытки;
		
		Попытка
			ЗначениеКлюча = Новый Структура;
			ЗначениеКлюча.Вставить("ОтметкаВремени", "");
			ЗначениеКлюча.Вставить("ЗависимыйОбъектМетаданных", Выборка.ЗависимыйОбъектМетаданных);
			ЗначениеКлюча.Вставить("ВлияющийОбъектМетаданных", Выборка.ВлияющийОбъектМетаданных);
			ЗначениеКлюча.Вставить("КлючВлияющихДанных", Выборка.КлючВлияющихДанных);
			КлючБлокировкиБезОтметки = РегистрыСведений.ОчередьОбновленияКэширующихДанных.СоздатьКлючЗаписи(
				ЗначениеКлюча);
			ЗаблокироватьДанныеДляРедактирования(КлючБлокировкиБезОтметки);
		Исключение
			// Объектная блокировка без отметки времени используется для исключения обновления одних и тех же данных.
			Продолжить;
		КонецПопытки;
		
		// Хоть мы и заблокировали, другой поток уже мог обработать ранее, проверим что ещё актуально.
		ЕстьЗаписьСТакимиПолямиКлюча =
			РегистрыСведений.ОчередьОбновленияКэширующихДанных.ЕстьЗаписьСТакимиПолямиКлюча(
				Выборка.ОтметкаВремени,
				Выборка.ЗависимыйОбъектМетаданных,
				Выборка.ВлияющийОбъектМетаданных,
				Выборка.КлючВлияющихДанных);
		
		Если ЕстьЗаписьСТакимиПолямиКлюча Тогда
			
			Попытка
				
				ЕстьОбработанныеДанные = Истина;
				
				ОбъектМетаданных = ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору(
					Выборка.ЗависимыйОбъектМетаданных, Ложь);
				Если ОбъектМетаданных = Null Или ОбъектМетаданных = Неопределено Тогда
					
					РегистрыСведений.ОчередьОбновленияКэширующихДанных.УдалитьЗаписьИзОчереди(
						Выборка.ОтметкаВремени,
						Выборка.ЗависимыйОбъектМетаданных,
						Выборка.ВлияющийОбъектМетаданных,
						Выборка.КлючВлияющихДанных);
					
				Иначе
					
					ПараметрыСеанса.ЗагрузкаОбработанныхДанныхИзДругойСистемы =
						Выборка.ЗагрузкаОбработанныхДанныхИзДругойСистемы;
					ПользователиДокументооборот.УстановитьОлицетворяемогоПользователя(
						Выборка.Автор);
					
					Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ОбъектМетаданных.ПолноеИмя());
					Менеджер.ОбновитьКэширующиеДанные(Выборка);
					
					РегистрыСведений.ОчередьОбновленияКэширующихДанных.ЗаписатьУспешнуюПопытку(
						Выборка.ОтметкаВремени,
						Выборка.ЗависимыйОбъектМетаданных,
						Выборка.ВлияющийОбъектМетаданных,
						Выборка.КлючВлияющихДанных);
					
					ПараметрыСеанса.ЗагрузкаОбработанныхДанныхИзДругойСистемы = Ложь;
					ПользователиДокументооборот.ОчиститьОлицетворяемогоПользователя();
				
				КонецЕсли;
				
			Исключение
				
				ПараметрыСеанса.ЗагрузкаОбработанныхДанныхИзДругойСистемы = Ложь;
				ПользователиДокументооборот.ОчиститьОлицетворяемогоПользователя();
				
				РегистрыСведений.ОчередьОбновленияКэширующихДанных.ЗаписатьНеуспешнуюПопытку(
					Выборка.ОтметкаВремени,
					Выборка.ЗависимыйОбъектМетаданных,
					Выборка.ВлияющийОбъектМетаданных,
					Выборка.КлючВлияющихДанных,
					ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				
			КонецПопытки;
			
		КонецЕсли;
		
		РазблокироватьДанныеДляРедактирования(КлючБлокировки);
		РазблокироватьДанныеДляРедактирования(КлючБлокировкиБезОтметки);
		
	КонецЦикла;
	
	Возврат ЕстьОбработанныеДанные;
	
КонецФункции

// Обрабатывает очередь обновления кэширующих данных в потоке.
// 
// Параметры:
//  Долгое - Булево
// 
Процедура ОбработатьОчередьОбновленияКэширующихДанныхВПотоке(Долгое) Экспорт
	
	ЕстьОбработанныеДанные = Истина;
	Пока ЕстьОбработанныеДанные Цикл
		//@skip-check query-in-loop
		ЕстьОбработанныеДанные = ОбработатьОчередьОбновленияКэширующихДанных(Долгое);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Обновляет информацию об активных потоках обновления и определяет количество активных потоков.
// 
// Параметры:
//  Долгое - Булево
// 
// Возвращаемое значение:
//  Число
// 
Функция КоличествоАктивныхПотоков(Долгое)
	
	АктивныеЗаданияОбновления =
		РегистрыСведений.АктивныеЗаданияОбновленияКэширующихДанных.АктивныеЗаданияОбновления(Долгое);
	
	КоличествоЭлементов = АктивныеЗаданияОбновления.Количество();
	Для Индекс = 1 По КоличествоЭлементов Цикл
		
		ОбратныйИндекс = КоличествоЭлементов - Индекс;
		УникальныйИдентификаторЗадания = АктивныеЗаданияОбновления[ОбратныйИндекс];
		
		АктивноеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(УникальныйИдентификаторЗадания);
		Если АктивноеЗадание <> Неопределено
			И АктивноеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			Продолжить;
		КонецЕсли;
		
		АктивныеЗаданияОбновления.Удалить(ОбратныйИндекс);
		
		РегистрыСведений.АктивныеЗаданияОбновленияКэширующихДанных.Удалить(
			УникальныйИдентификаторЗадания);
		
	КонецЦикла;
	
	КоличествоАктивныхПотоков = АктивныеЗаданияОбновления.Количество();
	
	Возврат КоличествоАктивныхПотоков;
	
КонецФункции

// Запускает потоки обновления кэширующих данных.
// 
// Параметры:
//  Долгое - Булево
// 
Процедура ЗапуститьПотокиОбновленияКэширующихДанных(Долгое)
	
	НужноеКоличествоПотоков = НужноеКоличествоПотоков(Долгое);
	ИнформационнаяБазаФайловая = ОбщегоНазначения.ИнформационнаяБазаФайловая();
	
	Если НужноеКоличествоПотоков = 0 Или ИнформационнаяБазаФайловая Тогда
		// Обновляем в потоке регламентного задания, если отключили настройку или база файловая.
		ОбработатьОчередьОбновленияКэширующихДанныхВПотоке(Долгое);
		Возврат;
	КонецЕсли;
	
	КоличествоАктивныхПотоков = КоличествоАктивныхПотоков(Долгое);
	Пока КоличествоАктивныхПотоков < НужноеКоличествоПотоков Цикл
		
		ПараметрыФоновогоЗадания = Новый Массив;
		ПараметрыФоновогоЗадания.Добавить(Долгое);
		ФоновоеЗадание = ФоновыеЗадания.Выполнить(
			"ОбновлениеКэширующихДанных.ОбработатьОчередьОбновленияКэширующихДанныхВПотоке",
			ПараметрыФоновогоЗадания);
		
		РегистрыСведений.АктивныеЗаданияОбновленияКэширующихДанных.Добавить(
			ФоновоеЗадание.УникальныйИдентификатор,
			Долгое);
		
		КоличествоАктивныхПотоков = КоличествоАктивныхПотоков + 1;
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет нужное количество потоков обновления кэширующих данных.
// 
// Параметры:
//  Долгое - Булево
// 
// Возвращаемое значение:
//  Число
// 
Функция НужноеКоличествоПотоков(Долгое)
	
	Если Долгое Тогда
		НужноеКоличествоПотоков = Константы.ЧислоПотоковДолгогоОбновленияКэширующихДанных.Получить();
	Иначе
		НужноеКоличествоПотоков = Константы.ЧислоПотоковОбновленияКэширующихДанных.Получить();
	КонецЕсли;
	
	Возврат НужноеКоличествоПотоков;
	
КонецФункции

#КонецОбласти