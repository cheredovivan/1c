// @skip-check bsl-nstr-string-literal-format

#Область ПрограммныйИнтерфейс

// Проверяет авторизацию аккаунта.
// 
// Возвращаемое значение:
//  Булево - Аккаунт авторизован
//
Функция АвторизацияВыполнена() Экспорт
	
	Параметры = ПараметрыАвторизацииНеАвторизован();
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации(Параметры);
	
	Возврат (Параметры.РежимАвторизации <> "НеАвторизован");
	
КонецФункции

// Для использования в РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации
// Констурктор режима авторизации Десктоп
// 
// Параметры:
//  Токен - Строка - токен авторизации в сервисе распознавания документов
// 
// Возвращаемое значение:
//  см. ПараметрыАвторизации
//
Функция ПараметрыАвторизацииДесктоп(Токен) Экспорт
	
	Результат = ПараметрыАвторизации();
	Результат.РежимАвторизации = "Десктоп";
	Результат.Токен = Токен;
	
	Возврат Результат;
	
КонецФункции

// Для использования в РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации
// Констурктор режима авторизации МобильноеПриложение
//
// Параметры:
//  Токен - Строка - токен авторизации в сервисе распознавания документов
// 
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.ПараметрыАвторизации
//
Функция ПараметрыАвторизацииМобильноеПриложение(Токен) Экспорт
	
	Результат = ПараметрыАвторизации();
	Результат.РежимАвторизации = "МобильноеПриложение";
	Результат.Токен = Токен;
	
	Возврат Результат;
	
КонецФункции

// Для использования в РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации
// Констурктор режима авторизации НеАвторизован
//
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.ПараметрыАвторизации
//
Функция ПараметрыАвторизацииНеАвторизован() Экспорт
	
	Результат = ПараметрыАвторизации();
	Возврат Результат;
	
КонецФункции

// Для использования в РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации
// Констурктор режима авторизации НеАвторизован
//
// Возвращаемое значение:
//  Структура - Параметры авторизации десктоп:
// * РежимАвторизации - Строка - режим авторизации
// * Токен - Строка - токен авторизации в сервисе распознавания документов
// * АдресСервисаРаспознавания - Строка - адрес сервиса распознавания
// * НомерМодели - Строка - номер модели распознавания  
//
Функция ПараметрыАвторизации() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("РежимАвторизации", "НеАвторизован");
	Результат.Вставить("Токен", "");
	Результат.Вставить("АдресСервисаРаспознавания", "https://ocr.1c.ai");
	Результат.Вставить("НомерМодели", "5");
	
	Возврат Результат;
	
КонецФункции

// Вызывает исключение если мобильного приложение с указанным идентификатором не существует.
// 
// Параметры:
//  ИдентификаторКлиента - Строка - Идентификатор клиента
//
Процедура ПроверитьИдентификаторКлиента(ИдентификаторКлиента) Экспорт
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/users/" + XMLСтрока(ИдентификаторКлиента));
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200 Тогда
		ВызватьИсключение
			НСтр("ru='Ключ пользователя не верный. Попробуйте еще раз.';
			     |en='Invalid user key. Please try again.'");
	КонецЕсли;
	
КонецПроцедуры

// Выполнить авторизацию в сервисе распознавания используя логин и пароль пилотной программы.
//
// Параметры:
//  Логин - Строка - Логин
//  Пароль - Строка - Пароль
// 
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакРезультатАвторизации
// 
Функция ВыполнитьАвторизациюПоЛогинуПаролю(Логин, Пароль) Экспорт
	
	Область = ОбластьАвторизации();
	
	ПараметрыАвторизации = ПараметрыАвторизацииНеАвторизован();
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации(ПараметрыАвторизации);
	
	Данные = Новый Структура;
	Данные.Вставить("client_id", ПараметрыАвторизации.Токен);
	Данные.Вставить("scope", РаспознаваниеДокументовHTTP.ОбъектВJson(Область));
	Данные.Вставить("login", Логин);
	Данные.Вставить("password", Пароль);
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Заголовки.Вставить("Content-Type", "application/json");
	Параметры.Заголовки.Вставить("Charset", "utf-8");
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/users_auth",
		РаспознаваниеДокументовHTTP.ОбъектВJson(Данные),
		Параметры);
	
	Возврат КакРезультатАвторизации(Ответ);
	
КонецФункции

// Выполнить авторизацию в сервисе распознавания используя тикет Портала 1С:ИСТ.
//
// Параметры:
//  Тикет - Строка
// 
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакРезультатАвторизации
// 
Функция ВыполнитьАвторизациюПоТикетуИТС(Тикет) Экспорт
	
	Область = ОбластьАвторизации();
	
	ПараметрыАвторизации = ПараметрыАвторизацииНеАвторизован();
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации(ПараметрыАвторизации);
	
	Данные = Новый Структура;
	Данные.Вставить("client_id", ПараметрыАвторизации.Токен);
	Данные.Вставить("scope", РаспознаваниеДокументовHTTP.ОбъектВJson(Область));
	Данные.Вставить("ticket", Тикет);
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Заголовки.Вставить("Content-Type", "application/json");
	Параметры.Заголовки.Вставить("Charset", "utf-8");
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/users_its",
		РаспознаваниеДокументовHTTP.ОбъектВJson(Данные),
		Параметры);
	
	Возврат КакРезультатАвторизации(Ответ);
	
КонецФункции

// Выполнить авторизацию в сервисе распознавания используя логин и пароль Портала 1С:ИТС.
// 
// Параметры:
//  Логин - Строка - Логин
//  Пароль - Строка - Пароль
// 
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакРезультатАвторизации
// 
Функция ВыполнитьАвторизациюПоЛогинуПаролюИТС(Логин, Пароль) Экспорт
	
	Область = ОбластьАвторизации();
	
	ПараметрыАвторизации = ПараметрыАвторизацииНеАвторизован();
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации(ПараметрыАвторизации);
	
	Данные = Новый Структура;
	Данные.Вставить("client_id", ПараметрыАвторизации.Токен);
	Данные.Вставить("scope", РаспознаваниеДокументовHTTP.ОбъектВJson(Область));
	Данные.Вставить("its_login", Логин);
	Данные.Вставить("its_password", Пароль);
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Заголовки.Вставить("Content-Type", "application/json");
	Параметры.Заголовки.Вставить("Charset", "utf-8");
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/users_its",
		РаспознаваниеДокументовHTTP.ОбъектВJson(Данные),
		Параметры);
	
	Возврат КакРезультатАвторизации(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для получения состояния текущего баланса.
//
// Возвращаемое значение:
//   см. РаспознаваниеДокументовSDK.КакСостояниеТекущегоБаланса
//
Функция ТекущийБаланс() Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 2;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/users/balance/struct_docs", , Параметры);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200  Тогда
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка получения свойств текущего баланса.';
			     |en='Failed to receive the current balance properties.'"));
	КонецЕсли;
	
	Возврат КакСостояниеТекущегоБаланса(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для установки адреса электронной почты.
// Этот адрес будет использоваться для уведомления об активации учетной записи
// и для сообщений об изменении баланса.
//
// Параметры:
//  АдресЭлПочты - Строка - адрес электронной почты клиента.
//
Процедура УстановитьАдресЭлектроннойПочты(АдресЭлПочты) Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 2;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	Параметры.Заголовки.Вставить("Content-Type", "application/json");
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/users/notification_email",
		"""" + АдресЭлПочты + """",
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Адрес электронной почты не установлен.';
			     |en='Email do not set.'")
		);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет запрос к серверу распознавания документов для получения предложений клиенту.
//
// Параметры:
//  Пользователь - Строка - уникальный идентификатор пользователя ИБ
//  Размещение - Строка - код места размещения баннера
//  ЗакрытыеБаннеры - Соответствие из КлючИЗначение - список идентификаторов закрытых баннеров:
//    * Ключ - Строка - Идентификатор баннера
//    * Значение - Дата
//
// Возвращаемое значение:
//   см. КакПерсонализированныеПредложения
//
Функция ТекущиеПерсонализированныеПредложения(Пользователь = Неопределено, Размещение = Неопределено, ЗакрытыеБаннеры = Неопределено) Экспорт 
	
	ПараметрыЗапроса = Новый Соответствие;
	Если ЗначениеЗаполнено(Размещение) Тогда
		ПараметрыЗапроса.Вставить("origin", Размещение);
	КонецЕсли;
	Если ЗначениеЗаполнено(ЗакрытыеБаннеры) Тогда
		ИдентификаторыЗакрытыхБаннеров = Новый Массив; // Массив из Строка
		Для Каждого Баннер Из ЗакрытыеБаннеры Цикл
			ИдентификаторыЗакрытыхБаннеров.Добавить(Баннер.Ключ);
		КонецЦикла;
		ПараметрыЗапроса.Вставить("closed_banners", СтрСоединить(ИдентификаторыЗакрытыхБаннеров, "|"));
	КонецЕсли;
	Если ЗначениеЗаполнено(Пользователь) Тогда
		ПараметрыЗапроса.Вставить("usr_uuid", Пользователь);
	КонецЕсли;
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 2;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	Параметры.Заголовки.Вставить("X-appname", ВРег(Метаданные.Имя));
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/users/special_offers",
		ПараметрыЗапроса,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200  Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка получения персонализированных предложений.';
			     |en='Failed to receive the current service offers.'")
		);
	КонецЕсли;
	
	Возврат КакПерсонализированныеПредложения(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для проверки допустимых действий при авторизации.
//
// Возвращаемое значение:
//   см. РаспознаваниеДокументовSDK.КакДопустимыеДействияПриАвторизации.
//
Функция ТекущиеДопустимыеДействияПриАвторизации() Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 2;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	Параметры.Заголовки.Вставить("X-appname", ВРег(Метаданные.Имя));
	Параметры.Заголовки.Вставить("Content-Type", "application/json");
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/users/active_promos",
		,
		Параметры
	);
	
	Возврат КакДопустимыеДействияПриАвторизации(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для активации промокода.
//
// Параметры:
//  Промокод - Строка
//
// Возвращаемое значение:
//   см. РаспознаваниеДокументовSDK.КакРезультатАктивацииПромокода.
//
Функция АктивироватьПромокод(Промокод) Экспорт
	
	Данные = Новый Структура;
	Данные.Вставить("promocode", Промокод);
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 2;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	Параметры.Json = Данные;
	Параметры.Заголовки.Вставить("X-appname", ВРег(Метаданные.Имя));
	Параметры.Заголовки.Вставить("Content-Type", "application/json");
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/users/activate_promocode",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Возврат КакРезультатАктивацииПромокода(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для создания задания распознавания.
//
// Параметры:
//  ИменаФайлов - Массив из Строка - имена файлов, которые необходимо отправить на распознавание.
//  ДатаСоздания - Дата - дата создания задания распознавания, если не указана - текущая универсальная дата.
//
// Возвращаемое значение:
//  Строка - идентификатор задания распознавания.
//
Функция СоздатьЗаданиеРаспознавания(ИменаФайлов, ДатаСоздания = Неопределено) Экспорт
	
	Если ДатаСоздания = Неопределено Тогда
		ДатаСоздания = ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
	Данные = Новый Структура;
	Данные.Вставить("files", ИменаФайлов);
	Данные.Вставить("create_time", ДатаСоздания);
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Json = Данные;
	Параметры.Заголовки.Вставить("Charset", "utf-8");
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/ocr/models/" + НомерМодели() + "/new_task?async=1&lang=rus&api_version=v2",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка создания задания распознавания.';
			     |en='Failed to create recognition task.'")
		);
	КонецЕсли;
	
	Возврат РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для создания задания распознавания.
//
// Параметры:
//  QRКод - Строка - данные QR-кода по которым надо создать задание распознавания.
//  ДатаСоздания - Дата - дата создания задания распознавания, если не указана - текущая универсальная дата.
//
// Возвращаемое значение:
//  Строка - идентификатор задания распознавания.
//
Функция СоздатьЗаданиеРаспознаванияПоQRКоду(QRКод, ДатаСоздания = Неопределено) Экспорт
	
	Если ДатаСоздания = Неопределено Тогда
		ДатаСоздания = ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
	Данные = Новый Структура;
	Данные.Вставить("qr_code", QRКод);
	Данные.Вставить("create_time", ДатаСоздания);
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Json = Данные;
	Параметры.Заголовки.Вставить("Charset", "utf-8");
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/ocr/models/" + НомерМодели() + "/new_task?async=1&type=qr_receipt",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка создания задания распознавания.';
			     |en='Failed to create recognition task.'")
		);
	КонецЕсли;
	
	Возврат РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для получения состояния обработки задания распознавания.
//
// Параметры:
//  ИдентификаторЗадания - Строка - идентификатор созданный см. РаспознаваниеДокументовSDK.СоздатьЗаданиеРаспознавания.
//
// Возвращаемое значение:
//   см. РаспознаваниеДокументовSDK.КакСостояниеОбработкиЗадания.
//
Функция ПолучитьСостояниеОбработкиЗадания(ИдентификаторЗадания) Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 120;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	АдресСервиса = АдресСервисаРаспознавания()
		+ "/api/v1/ocr/models/" + НомерМодели()
		+ "/result/" + ИдентификаторЗадания
		+ "?only_summary=1&api_version=v2";
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервиса,
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200
	   И Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Принято_202
	   И Ответ.КодСостояния < РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ВнутренняяОшибкаСервера_500 Тогда
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка получения результата обработки задания.';
			     |en='Failed to receive the task processing result.'")
		);
	КонецЕсли;
	
	Возврат КакСостояниеОбработкиЗадания(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для загрузки файла по выделенному адресу.
//
// Параметры:
//  АдресЗагрузкиФайла - см. РаспознаваниеДокументовSDK.ПолучитьСостояниеОбработкиЗадания.
//  Данные - ДвоичныеДанные - данные загружаемого файла.
//
// Возвращаемое значение:
//  Строка - идентификатор файла.
//
Функция ЗагрузкаФайлаПоАдресу(АдресЗагрузкиФайла, Данные) Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 600;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	Параметры.Заголовки.Вставить("Content-Type", "application/octet-stream");
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1" + АдресЗагрузкиФайла,
		Данные,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200
	   И Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Принято_202 Тогда 
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка при загрузке файла на сервер.';
			     |en='Failed to upload the file.'")
		);
	КонецЕсли;
	
	Возврат РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для отмены загрузки файла по адресу.
//
// Метод предназначен для отмены загрузки в случае, когда клиентское приложение понимает, что запросило слишком много
// слотов для загрузки файлов и в процессе отправки какой-либо из файлов больше отправлять не требуется.
//
// Параметры:
//  АдресЗагрузкиФайла - см. РаспознаваниеДокументовSDK.ПолучитьСостояниеОбработкиЗадания.
//
Процедура ОтменаЗагрузкиФайлаПоАдресу(АдресЗагрузкиФайла) Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.МаксимальноеКоличествоПовторов = 3;
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	РаспознаваниеДокументовHTTP.Delete(
		АдресСервисаРаспознавания() + "/api/v1" + АдресЗагрузкиФайла,
		,
		Параметры
	);
	
КонецПроцедуры

// Выполняет запрос к серверу распознавания документов для загрузки файла по выделенному адресу.
//
// Параметры:
//  ИдентификаторФайла - см. РаспознаваниеДокументовSDK.ЗагрузкаФайлаПоАдресу.
//
// Возвращаемое значение:
//   ДвоичныеДанные - данные исходного файла.
//
Функция ПолучитьИсходныйФайл(ИдентификаторФайла) Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 120;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/ocr/file_info/" + ИдентификаторФайла,
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200  Тогда
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка получения исходного файла.';
			     |en='Failed to receive the origin file.'")
		);
	КонецЕсли;
	
	Возврат РаспознаваниеДокументовHTTP.КакДвоичныеДанные(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для получения свойств распознанного документа.
//
// Параметры:
//  ИдентификаторДокумента - Строка
//
// Возвращаемое значение:
//   см. НовыеСвойстваРаспознанногоДокумента
//
Функция ПолучитьСвойстваРаспознанногоДокумента(ИдентификаторДокумента) Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Таймаут = 120;
	Параметры.МаксимальноеКоличествоПовторов = 3;
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	АдресСервиса = АдресСервисаРаспознавания()
		+ "/api/v1/ocr/models/" + НомерМодели()
		+ "/result/" + ИдентификаторДокумента
		+ "?api_version=v2";
	
	Если ТолькоУниверсальныйФормат() Тогда
		АдресСервиса = АдресСервиса + "&force_v2=1";
	КонецЕсли;
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервиса,
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200
	   И Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Принято_202 Тогда
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка получения свойств распознанного документа.';
			     |en='Failed to receive the recognized document properties'")
		);
	КонецЕсли;
	
	Возврат КакСвойстваРаспознанногоДокумента(Ответ);
	
КонецФункции

// Возвращает структуру с результатом обработки распознанного документа в основной базе
// по каждому из переданных идентификаторов
// 
// Параметры:
//  ИдентификаторыДокументов - Массив из Строка - Идентификаторы документов
// 
// Возвращаемое значение:
//  Соответствие Из КлючИЗначение:
//  * Ключ - Строка - Идентификатор документа
//  * Значение - Структура:
//    ** Статус - Строка
//    ** НомерРаспознанногоДокумента - Строка 
//    ** НомерДокумента - Строка
//    ** ДатаДокумента - Дата
//    ** СуммаДокумента - Строка
//    ** Продавец - Строка
//    ** Покупатель -  Строка
//    ** ИсторияОбработки - Массив из Структура:
//       *** Статус - Строка
//       *** Дата - Дата
//
Функция ПолучитьРезультатыОбработкиРаспознанногоДокумента(ИдентификаторыДокументов) Экспорт
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Json = ИдентификаторыДокументов;
	Параметры.Таймаут = 300;
	
	ДобавитьЗаголовокАвторизации(Параметры.Заголовки);
	
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/ocr/feedback_list",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200
		И Ответ.КодСостояния < РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ВнутренняяОшибкаСервера_500 Тогда
		ВызватьИсключение
			НСтр("ru='Ошибка получения результата обработки распознанного документа.';
			     |en='Failed to receive the recognized document processing result.'");
	КонецЕсли;
	
	Результат = Новый Соответствие;
	
	Для Каждого РезультатJson Из РаспознаваниеДокументовHTTP.КакJson(Ответ) Цикл
		
		ИсторияОбработки = Новый Массив; // Массив из Структура
		НомерДокумента = Неопределено;
		ДатаДокумента = Неопределено;
		СуммаДокумента = Неопределено;
		Продавец = Неопределено;
		Покупатель = Неопределено;
		НомерРаспознанногоДокумента = Неопределено;
		
		ТекущийСтатус = Неопределено;
		Для Каждого ЗаписьИстории Из РезультатJson.Значение Цикл
			
			НовыйСтатус = ЗаписьИстории["Статус"]; // Строка
			
			Если ТекущийСтатус <> НовыйСтатус Тогда
				
				ДатаИзмененияСтатуса = ЗаписьИстории["ДатаИзмененияСтатуса"]; // Строка
				
				ЗаписьИсторииОбработки = Новый Структура;
				ЗаписьИсторииОбработки.Вставить("Статус", НовыйСтатус);
				ЗаписьИсторииОбработки.Вставить("Дата", ПрочитатьДатуJSON(ДатаИзмененияСтатуса, ФорматДатыJSON.ISO));
				
				ИсторияОбработки.Добавить(ЗаписьИсторииОбработки);
				
				ТекущийСтатус = НовыйСтатус;
				
			КонецЕсли;
			
		КонецЦикла;
		
		//@skip-check dynamic-access-method-not-found
		ПоследнийИндекс = РезультатJson.Значение.ВГраница(); // Число
		Если ПоследнийИндекс <> -1 Тогда
			
			НомерДокумента = ЗаписьИстории["НомерДокумента"];// Строка
			ДатаДокументаСтрокой = ЗаписьИстории["ДатаДокумента"]; // Строка
			ДатаДокумента = СтроковыеФункцииКлиентСервер.СтрокаВДату(ДатаДокументаСтрокой);
			СуммаДокумента = ЗаписьИстории["СуммаДокумента"]; // Строка
			ЭтоВходящийДокумент = (ЗаписьИстории["ЭтоВходящийДокумент"] = Истина);
			
			Если ЗаписьИстории["Статус"] = "Распознан" Тогда
				Продавец = ЗаписьИстории["Продавец"]; // Строка
				Покупатель = ЗаписьИстории["Покупатель"]; // Строка
			ИначеЕсли ЭтоВходящийДокумент Тогда
				Продавец = ЗаписьИстории["Контрагент"]; // Строка
				Покупатель = ЗаписьИстории["Организация"]; // Строка
			Иначе
				Продавец = ЗаписьИстории["Организация"]; // Строка
				Покупатель = ЗаписьИстории["Контрагент"]; // Строка
			КонецЕсли;
			
			//@skip-check dynamic-access-method-not-found
			НомерРаспознанногоДокумента = ЗаписьИстории.Получить("НомерРаспознанногоДокумента"); // Строка
			
		КонецЕсли;
		
		РезультатДокумента = Новый Структура;
		РезультатДокумента.Вставить("ИсторияОбработки", ИсторияОбработки);
		РезультатДокумента.Вставить("НомерДокумента", НомерДокумента);
		РезультатДокумента.Вставить("ДатаДокумента", ДатаДокумента);
		РезультатДокумента.Вставить("СуммаДокумента", СуммаДокумента);
		РезультатДокумента.Вставить("Продавец", Продавец);
		РезультатДокумента.Вставить("Покупатель", Покупатель);
		РезультатДокумента.Вставить("НомерРаспознанногоДокумента", НомерРаспознанногоДокумента);
		РезультатДокумента.Вставить("Статус", ТекущийСтатус);
		
		Результат.Вставить(РезультатJson.Ключ, РезультатДокумента);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Отправляет послание о проблеме
// 
// Параметры:
//  Идентификатор - Строка - Идентификатор документа или файла
//  СообщениеПользователя - Строка - Сообщение пользователя
//  ДополнительнаяИнформация - Структура - Дополнительная информация
//
Процедура ОтправитьЖалобу(Идентификатор, СообщениеПользователя, ДополнительнаяИнформация) Экспорт
	
	Пакет = Новый Структура;
	Пакет.Вставить("СообщениеПользователя", СообщениеПользователя);
	Пакет.Вставить("ДополнительнаяИнформация", ДополнительнаяИнформация);
	
	Данные = Новый Структура;
	Данные.Вставить("mobile_feedback", Пакет);
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Json = Данные;
	
	РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/ocr/feedback/" + Идентификатор,
		,
		Параметры
	);
	
КонецПроцедуры

// Отправить отзыв.
// 
// Параметры:
//  СообщениеПользователя - Строка - Сообщение пользователя
//  АдресЭлектроннойПочты - Строка - Адрес электронной почты
//  ОценкаПриложения - Число - Оценка приложения
//
Процедура ОтправитьОтзыв(СообщениеПользователя, АдресЭлектроннойПочты, ОценкаПриложения) Экспорт
	
	ПараметрыАвторизации = ПараметрыАвторизацииНеАвторизован();
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации(ПараметрыАвторизации);
	
	Данные = Новый Структура;
	Данные.Вставить("client_id", ПараметрыАвторизации.Токен);
	Данные.Вставить("type", "mobile_review");
	Данные.Вставить("message", СообщениеПользователя);
	Данные.Вставить("email", АдресЭлектроннойПочты);
	Данные.Вставить("rate", ОценкаПриложения);
	Данные.Вставить("scope", ОбластьАвторизации());
	
	Параметры = РаспознаваниеДокументовHTTP.НовыеПараметры();
	Параметры.Json = Данные;
	
	РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/ocr/feedback/support",
		,
		Параметры
	);
	
КонецПроцедуры

// Структура статусов документа.
//
// Возвращаемое значение:
//   Структура:
//   * Ошибка - Строка 
//   * Завершено - Строка
//
Функция СтатусыДокумента() Экспорт

	//@skip-check constructor-function-return-section
	Возврат РаспознаваниеДокументовSDKПовтИсп.СтатусыДокумента();
	
КонецФункции

// Структура типов документа.
//
// Возвращаемое значение:
//   Структура:
//   * НеопределенныйФормат - Строка
//   * УниверсальныйФормат - Строка
//
Функция ТипыДокумента() Экспорт
	
	//@skip-check constructor-function-return-section
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТипыДокумента();
	
КонецФункции

// Структура классов документа.
//
// Возвращаемое значение:
//   Структура:
//   * НеопределенныйДокумент - Строка
//   * СчетФактура - Строка
//   * КассовыйЧек - Строка
//   * УКД - Строка
//
Функция КлассыДокумента() Экспорт
	
	//@skip-check constructor-function-return-section
	Возврат РаспознаваниеДокументовSDKПовтИсп.КлассыДокумента();
	
КонецФункции

// Структура типов сущностей.
//
// Возвращаемое значение:
//   Структура:
//   * Идентификатор - Строка
//   * Текст - Строка
//   * Число - Строка
//   * Дата - Строка
//   * Составной - Строка
//   * Таблица - Строка
//
Функция ТипыСущностей() Экспорт
	
	//@skip-check constructor-function-return-section
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТипыСущностей();
	
КонецФункции

// Структура классов сущностей.
//
// Возвращаемое значение:
//   Структура:
//   * Дата - Строка
//   * ЗаголовокДокумента - Строка
//   * ДокументОснование - Строка
//   * ДатаДокумента - Строка
//   * НомерДокумента - Строка
//   * НаименованиеДокумента - Строка
//   * Валюта - Строка
//   * СуммаДокумента - Строка
//   * СуммаНДС - Строка
//   * Поставщик - Строка
//   * Покупатель - Строка
//   * Плательщик - Строка
//   * Грузоотправитель - Строка
//   * Грузополучатель - Строка
//   * ТранспортнаяКомпания - Строка
//   * Адрес - Строка
//   * Телефон - Строка
//   * ЭлектроннаяПочта - Строка
//   * Компания - Строка
//   * НаименованиеКомпании - Строка
//   * ИННКомпании - Строка
//   * КППКомпании - Строка
//   * БанковскийСчет - Строка
//   * НаименованиеБанка - Строка
//   * БИКБанка - Строка
//   * НомерБанковскогоСчета - Строка
//   * НомерБанковскогоСчетаКорреспондента - Строка
//   * ТаблицаНоменклатур - Строка
//   * АртикулНоменклатуры - Строка
//   * КодНоменклатуры - Строка
//   * НаименованиеНоменклатуры - Строка
//   * Цена - Строка
//   * Количество - Строка
//   * СтавкаНДС - Строка
//   * СтавкаНДСТип - Строка
//   * Сумма - Строка
//   * СуммаБезНДС - Строка
//   * СуммаСНДС - Строка
//   * Скидка - Строка
//   * НаименованиеЕдиницыИзмерения - Строка
//   * КодЕдиницыИзмерения - Строка
//   * КодСтраныПроисхождения - Строка
//   * НаименованиеСтраныПроисхождения - Строка
//   * ТипОперацииЧек - Строка
//   * НомераСчетовФактурКорректировки - Строка
//   * НомераПередаточныхКорректировки - Строка
//   * НомерИсправленияКорректировкиСчетаФактуры - Строка
//   * ТаблицаИзмененийНоменклатур - Строка
//   * НомерСтроки - Строка
//   * НомерИсходнойСтроки - Строка
//   * ЦенаДоКорректировки - Строка
//   * СуммаНДСДоКорректировки - Строка
//   * СтавкаНДСТипДоКорректировки - Строка
//   * СуммаДоКорректировки - Строка
//   * СуммаБезНДСДоКорректировки - Строка
//   * СуммаСНДСДоКорректировки - Строка
//   * КодСтраныПроисхожденияДоКорректировки - Строка
//   * НаименованиеСтраныПроисхожденияДоКорректировки - Строка
//   
Функция КлассыСущностей() Экспорт
	
	//@skip-check constructor-function-return-section
	Возврат РаспознаваниеДокументовSDKПовтИсп.КлассыСущностей();
	
КонецФункции

// Структура свойств сущностей.
//
// Возвращаемое значение:
//   Структура:
//   * Компания - Строка
//   * Дата - Строка
//   * Номер - Строка
//   * Наименование - Строка
//   * Адрес - Строка
//   * Телефон - Строка
//   * ЭлектроннаяПочта - Строка
//   * ИНН - Строка
//   * КПП - Строка
//   * БанковскийСчет - Строка
//   * НаименованиеБанка - Строка
//   * БИК - Строка
//   * НомерСчета - Строка
//   * НомерСчетаКорреспондента - Строка
//
Функция СвойстваСущностей() Экспорт
	
	//@skip-check constructor-function-return-section
	Возврат РаспознаваниеДокументовSDKПовтИсп.СвойстваСущностей();
	
КонецФункции

// Структура подвалов таблиц.
//
// Возвращаемое значение:
//   Структура:
//   * ПодвалИтого - Строка
//   * ПодвалВсего - Строка
//   * ПодвалВТомЧислеНДС - Строка
//   * ПодвалСуммаНДС - Строка
//   * ПодвалБезНалога - Строка
//   * ПодвалСкидка - Строка
//
Функция ПодвалыТаблицы() Экспорт
	
	//@skip-check constructor-function-return-section
	Возврат РаспознаваниеДокументовSDKПовтИсп.ПодвалыТаблицы();
	
КонецФункции

// Все сущности распознанного документа
//
// Параметры:
//  СвойстваРаспознанногоДокумента - См. РаспознаваниеДокументовSDK.НовыеСвойстваРаспознанногоДокумента
//  
// Возвращаемое значение:
//  См. НовоеСоответствиеСущностей
//
Функция ВсеСущности(СвойстваРаспознанногоДокумента) Экспорт
	
	Если СвойстваРаспознанногоДокумента.Страницы.Количество() = 0 Тогда
		Возврат НовоеСоответствиеСущностей();
	КонецЕсли;
	
	Результат = Новый Соответствие;
	
	Для Каждого Страница Из СвойстваРаспознанногоДокумента.Страницы Цикл
		
		Для Каждого Сущность Из Страница.Значение.Сущности Цикл
			Результат.Вставить(Сущность.Ключ, Сущность.Значение);
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Находит и возвращает первую сущность заданного класса в коллекции сущностей
// 
// Параметры:
//  СвойстваРаспознанногоДокумента - См. РаспознаваниеДокументовSDK.НовыеСвойстваРаспознанногоДокумента
//  ИмяКласса - Строка
// 
// Возвращаемое значение:
//  Неопределено - Сущность по классу
//
Функция СущностьПоКлассу(СвойстваРаспознанногоДокумента, ИмяКласса) Экспорт
	
	Результат = Неопределено;
	
	Для Каждого КлючИЗначение Из ВсеСущности(СвойстваРаспознанногоДокумента) Цикл
		
		Если КлючИЗначение.Значение.Класс = ИмяКласса Тогда
			Результат = КлючИЗначение.Значение;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Находит и возвращает сущность через свойства другой сущности
// 
// Параметры:
//  СвойстваРаспознанногоДокумента - См. НовыеСвойстваРаспознанногоДокумента
//  Сущность - См. НоваяСущность
//  Путь - Строка
// 
// Возвращаемое значение:
// - Неопределено
// - Структура
//
Функция СущностьПоСвойствуСоставнойСущности(СвойстваРаспознанногоДокумента, Знач Сущность, Правило) Экспорт
	
	Если СвойстваРаспознанногоДокумента.Страницы.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Сущность;
	
	ЧастиПути = СтрРазделить(Правило.Путь, ".");
	НомерВложенияСущности = 0;
	
	Пока ЧастиПути.Количество() > НомерВложенияСущности Цикл 
		
		Если Результат = Неопределено Или Не Результат.ЭтоТипСоставной Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ИмяСвойства = ЧастиПути[НомерВложенияСущности];
		Ключ = Результат.Свойства[ИмяСвойства];
		Результат = ВсеСущности(СвойстваРаспознанногоДокумента)[Ключ];
		
		НомерВложенияСущности = НомерВложенияСущности + 1;
		
	КонецЦикла;
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("ОсновнаяСущность", Результат);
	
	Если ЗначениеЗаполнено(Правило.ПутьПриОшибке) Тогда
		
		РезультатПриОшибке = Сущность;
		
		ЧастиПути = СтрРазделить(Правило.ПутьПриОшибке, ".");
		НомерВложенияСущности = 0;
		
		Пока ЧастиПути.Количество() > НомерВложенияСущности Цикл 
			
			Если РезультатПриОшибке = Неопределено Или Не РезультатПриОшибке.ЭтоТипСоставной Тогда
				Возврат СтруктураВозврата;
			КонецЕсли;
			
			ИмяСвойства = ЧастиПути[НомерВложенияСущности];
			Ключ = РезультатПриОшибке.Свойства[ИмяСвойства];
			РезультатПриОшибке = ВсеСущности(СвойстваРаспознанногоДокумента)[Ключ];
			
			НомерВложенияСущности = НомерВложенияСущности + 1;
			
		КонецЦикла;
		
		Если РезультатПриОшибке <> Неопределено  Тогда
			СтруктураВозврата.Вставить("СущностьПриОшибкеКоординат", РезультатПриОшибке);
		КонецЕсли;	
		
	КонецЕсли;
	
	Возврат СтруктураВозврата;
	
КонецФункции

// Новые параметры сериализации свойств документа.
// 
// Возвращаемое значение:
//  Структура - Новые параметры сериализации:
// * ОчищатьИзображенияДокумента - Булево
// * ОчищатьИзображенияСущностей - Булево
// * ОчищатьИзображенияПечатейПодписей - Булево 
//
Функция НовыеПараметрыСериализации() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ОчищатьИзображенияДокумента", Истина);
	Результат.Вставить("ОчищатьИзображенияСущностей", Истина);
	Результат.Вставить("ОчищатьИзображенияПечатейПодписей", Истина);
	
	Возврат Результат;
	
КонецФункции

// Сериализовать свойства распознанного документа в json для сохранения в базе данных
// 
// Параметры:
//  СвойстваРаспознанногоДокумента - См. НовыеСвойстваРаспознанногоДокумента
//  ПараметрыСериализации - См. НовыеПараметрыСериализации
// 
// Возвращаемое значение:
//  Строка - Свойства распознанного документа в json
//
Функция СвойстваРаспознанногоДокументаВJson(СвойстваРаспознанногоДокумента, Знач ПараметрыСериализации = Неопределено) Экспорт
	
	Если ПараметрыСериализации = Неопределено Тогда
		ПараметрыСериализации = НовыеПараметрыСериализации();
	КонецЕсли;
	
	Свойства = ОбщегоНазначения.СкопироватьРекурсивно(СвойстваРаспознанногоДокумента);
	
	Для Каждого Страница Из Свойства.Страницы Цикл
		
		СвойстваСтраницы = Страница.Значение;
		
		ОчиститьДвоичныеДанныеИзображенийДокумента(СвойстваСтраницы, ПараметрыСериализации);
		ОчиститьДвоичныеДанныеСущностей(СвойстваСтраницы.Сущности, ПараметрыСериализации);
		ОчиститьДвоичныеДанныеПечатейПодписей(СвойстваСтраницы, ПараметрыСериализации);
		
	КонецЦикла;
	
	Свойства.Картинка = Неопределено;
	Свойства.Миниатюра = Неопределено;
	
	Возврат РаспознаваниеДокументовHTTP.ОбъектВJson(Свойства);
	
КонецФункции

// Десериализовать свойства документа из json
// 
// Параметры:
//  СтрокаJson - Строка - в формате json сохраненные свойства 
// 
// Возвращаемое значение:
//  См. НовыеСвойстваРаспознанногоДокумента
//
Функция JsonВСвойстваРаспознанногоДокумента(СтрокаJson) Экспорт
	
	СвойстваРаспознанногоДокумента = НовыеСвойстваРаспознанногоДокумента();
	
	Попытка
		ЧитаемыйОбъект = РаспознаваниеДокументовHTTP.JsonВОбъект(СтрокаJson);
	Исключение
		Возврат СвойстваРаспознанногоДокумента;
	КонецПопытки;
	
	ЗаполнитьЗначенияПоСоответствию(СвойстваРаспознанногоДокумента, ЧитаемыйОбъект, , "Страницы, Картинка, Миниатюра");
	
	Для Каждого ЧитаемаяСтраница Из ЧитаемыйОбъект["Страницы"] Цикл
		
		Страница = НоваяСтраницаРаспознанногоДокумента();
		ЗаполнитьЗначенияПоСоответствию(Страница, ЧитаемаяСтраница.Значение, , "Сущности, Печати, Подписи, Картинка, Миниатюра");
		
		Если Не ПустаяСтрока(ЧитаемаяСтраница.Значение["Картинка"]) Тогда
			Страница.Картинка = Base64Значение(ЧитаемаяСтраница.Значение["Картинка"]);
		КонецЕсли;
		
		Если Не ПустаяСтрока(ЧитаемаяСтраница.Значение["Миниатюра"]) Тогда
			Страница.Миниатюра = Base64Значение(ЧитаемаяСтраница.Значение["Миниатюра"]);
		КонецЕсли;
		
		ЗаполнитьПечатиПодписи(Страница.Печати,  ЧитаемаяСтраница.Значение["Печати"],  "Область", "Картинка");
		ЗаполнитьПечатиПодписи(Страница.Подписи, ЧитаемаяСтраница.Значение["Подписи"], "Область", "Картинка");
		
		Для Каждого ЧитаемаяСущность Из ЧитаемаяСтраница.Значение["Сущности"] Цикл
			
			Сущность = НоваяСущность();
			
			ЗаполнитьЗначенияПоСоответствию(Сущность, ЧитаемаяСущность.Значение, , "Таблица, Картинка");
			
			Если ЧитаемаяСущность.Значение["ЭтоТипТаблица"] Тогда
				
				Для Каждого ЧитаемаяКолонка Из ЧитаемаяСущность.Значение["Таблица"]["Колонки"] Цикл
					
					Колонка = НоваяСущность();
					ЗаполнитьЗначенияПоСоответствию(Колонка, ЧитаемаяКолонка.Значение, , "Картинка");
					
					Если Не ПустаяСтрока(ЧитаемаяКолонка.Значение["Картинка"]) Тогда
						Колонка.Картинка = Base64Значение(ЧитаемаяКолонка.Значение["Картинка"]);
					КонецЕсли;
					
					Сущность.Таблица.Колонки.Вставить(ЧитаемаяКолонка.Ключ, Колонка);
				КонецЦикла;
				
				Для Каждого ЧитаемаяСтрока Из ЧитаемаяСущность.Значение["Таблица"]["Строки"] Цикл
					
					Строка = НовоеСоответствиеСущностей();
					
					Для Каждого ЧитаемаяЯчейка Из ЧитаемаяСтрока Цикл
						
						Ячейка = НоваяСущность();
						ЗаполнитьЗначенияПоСоответствию(Ячейка, ЧитаемаяЯчейка.Значение, , "Картинка");
						
						Если Не ПустаяСтрока(ЧитаемаяЯчейка.Значение["Картинка"]) Тогда
							Ячейка.Картинка = Base64Значение(ЧитаемаяЯчейка.Значение["Картинка"]);
						КонецЕсли;
						
						Строка.Вставить(ЧитаемаяЯчейка.Ключ, Ячейка);
						
					КонецЦикла;
					
					Сущность.Таблица.Строки.Добавить(Строка);
					
				КонецЦикла;
				
				Для Каждого ЧитаемыеПодвалы Из ЧитаемаяСущность.Значение["Таблица"]["Подвалы"] Цикл
					
					Подвал = НовоеСоответствиеСущностей();
					
					Для Каждого ЧитаемыйПодвал Из ЧитаемыеПодвалы.Значение Цикл
						
						Колонка = НоваяСущность();
						ЗаполнитьЗначенияПоСоответствию(Колонка, ЧитаемыйПодвал.Значение, , "Картинка");
						
						Если Не ПустаяСтрока(ЧитаемыйПодвал.Значение["Картинка"]) Тогда
							Колонка.Картинка = Base64Значение(ЧитаемыйПодвал.Значение["Картинка"]);
						КонецЕсли;
						
						Подвал.Вставить(ЧитаемыйПодвал.Ключ, Колонка);
						
					КонецЦикла;
					
					Сущность.Таблица.Подвалы.Вставить(ЧитаемыеПодвалы.Ключ, Подвал);
					
				КонецЦикла;
				
			КонецЕсли;
			
			Страница.Сущности.Вставить(ЧитаемаяСущность.Ключ, Сущность);
			
		КонецЦикла;
		
		СвойстваРаспознанногоДокумента.Страницы.Вставить(ЧитаемаяСтраница.Ключ, Страница);
	КонецЦикла;
	
	Возврат СвойстваРаспознанногоДокумента;
	
КонецФункции

// Конструирует таблицу по свойствам
// 
// Параметры:
//  Сущность - См. НоваяСущность
// 
// Возвращаемое значение:
//  ТаблицаЗначений:
//  * НаименованиеНоменклатуры - Строка
//  * Количество - Число
//  * НаименованиеЕдиницыИзмерения - Строка
//  * Цена - Число
//  * Скидка - Число
//  * СтавкаНДС - Строка
//  * СуммаНДС - Число
//  * СуммаБезНДС - Число
//  * СуммаСНДС - Число
//  * Сумма - Число
//  * НаименованиеСтраныПроисхождения - Строка
//  * НомерГТД - Строка
//
Функция ТаблицаДокумента(Сущность) Экспорт
	
	КолонкиДокумента = Новый Массив; // Массив Из Строка
	
	КолонкиДокумента.Добавить("НаименованиеНоменклатуры");
	КолонкиДокумента.Добавить("Количество");
	КолонкиДокумента.Добавить("НаименованиеЕдиницыИзмерения");
	КолонкиДокумента.Добавить("Цена");
	КолонкиДокумента.Добавить("Скидка");
	КолонкиДокумента.Добавить("СтавкаНДС");
	КолонкиДокумента.Добавить("СуммаНДС");
	КолонкиДокумента.Добавить("СуммаБезНДС");
	КолонкиДокумента.Добавить("СуммаСНДС");
	КолонкиДокумента.Добавить("Сумма");
	КолонкиДокумента.Добавить("НаименованиеСтраныПроисхождения");
	КолонкиДокумента.Добавить("НомерГТД");
	
	ТаблицаРезультат = Новый ТаблицаЗначений;
	
	Если Сущность = Неопределено Тогда
		Возврат ТаблицаРезультат;
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы Из Сущность.Таблица.Строки Цикл
		
		НоваяСтрока = Неопределено;
		
		Для Каждого ЯчейкаТаблицыКлючЗначение Из СтрокаТаблицы Цикл
			
			ЯчейкаТаблицы = ЯчейкаТаблицыКлючЗначение.Значение;
			
			ИмяКолонки = ЯчейкаТаблицыКлючЗначение.Ключ;
			
			Если КолонкиДокумента.Найти(ИмяКолонки) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если ТаблицаРезультат.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
				МассивТипов = Новый Массив; // Массив из Тип
				МассивТипов.Добавить(ТипЗнч(ЯчейкаТаблицы["Значение"]));
				ТипКолонки = Новый ОписаниеТипов(МассивТипов, 
				Новый КвалификаторыЧисла, Новый КвалификаторыСтроки, Новый КвалификаторыДаты);
				
				ТаблицаРезультат.Колонки.Добавить(ИмяКолонки, ТипКолонки);
			КонецЕсли;
			
			Если НоваяСтрока = Неопределено Тогда
				НоваяСтрока = ТаблицаРезультат.Добавить();
			КонецЕсли;
			
			НоваяСтрока[ИмяКолонки] = ЯчейкаТаблицы["Значение"];
			
		КонецЦикла;
		
	КонецЦикла;
		
	Возврат ТаблицаРезультат;
	
КонецФункции

// Конструирует подвал таблицы по свойствам
// 
// Параметры:
//  Сущность - См. НоваяСущность
// 
// Возвращаемое значение:
//  Структура:
//  * Сумма - Число
//  * СуммаНДС - Число
//  * СуммаСНДС - Число
//  * Скидка - Число
//
Функция ПодвалТаблицыДокумента(Сущность) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Сумма", 0);
	Результат.Вставить("СуммаНДС", 0);
	Результат.Вставить("СуммаСНДС", 0);
	Результат.Вставить("Скидка", 0);
	
	Для Каждого Подвал Из Сущность.Таблица.Подвалы Цикл
		
		Если Подвал.Ключ <> "ПодвалИтого" Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ЯчейкаПодвалаКлючЗначение Из Подвал.Значение Цикл
			
			ЯчейкаПодвала = ЯчейкаПодвалаКлючЗначение.Значение;
			
			Если СтрНайти(ЯчейкаПодвала.Класс, "$") Тогда
				Продолжить; // Обход исключения при получении свойства структуры содержащего спецсимвол.
			КонецЕсли;
			
			Если Результат.Свойство(ЯчейкаПодвала.Класс) Тогда
				Результат[ЯчейкаПодвала.Класс] = ЯчейкаПодвала.Значение;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#Область УстаревшиеПроцедурыИФункции

// Выполняет запрос к серверу распознавания документов для проверки нужно ли предлагать ввести промокод.
//
// Возвращаемое значение:
//  Булево
//
Функция ПредлагатьВводПромокодаПриАвторизации() Экспорт
	
	ДопустимыеДействия = ТекущиеДопустимыеДействияПриАвторизации();
	Возврат ДопустимыеДействия.ПоказатьВводПромокода;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область Парсеры

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - результат HTTP запроса.
//
// Возвращаемое значение:
//  ФиксированнаяСтруктура:
//    * АвторизацияТикетИТС - Булево - является ли текущий пользователь пилотом.
//    * ДатаОкончания - Дата - дата отключения пилотной программы или последнего пакета баланса.
//    * ТарификацияВключена - Булево - для пользователя активирована тарификация.
//    * Баланс - Число - количество оплаченных страниц.
//    * Лимит - Число - количество страниц, которые еще можно распознать.
//    * ИспользованоСегодня - Число - количество страниц, распознанных сегодня.
//
Функция КакСостояниеТекущегоБаланса(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ); // Соответствие
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("АвторизацияТикетИТС", (ОтветJson["is_its_user"] = Истина));
		Результат.Вставить("ДатаОкончания", ПрочитатьДату(ОтветJson["expiration_date"]));
		Результат.Вставить("ТарификацияВключена", (ОтветJson["billing"] = "enabled"));
		Результат.Вставить("Баланс", ПрочитатьЧисло(ОтветJson["balance"]));
		Результат.Вставить("Лимит", ПрочитатьЧисло(ОтветJson["limit"]));
		Результат.Вставить("ИспользованоСегодня", ПрочитатьЧисло(ОтветJson["used_today"]));	
		
		Возврат Новый ФиксированнаяСтруктура(Результат);
		
	Исключение
		ВызватьИсключение(
			РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
				НСтр("ru = 'Ошибка при чтении состояния текущего баланса
					 |en = 'Error reading current balance state'")
			), , , ,
			ИнформацияОбОшибке()
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - результат HTTP запроса.
//
// Возвращаемое значение:
//  ФиксированнаяСтруктура:
//    * Баннеры - Массив из Структура:
//      ** Идентификатор - Строка
//      ** ЗаголовокБаннера - Строка
//      ** ТекстБаннера - Строка
//      ** Картинка - ДвоичныеДанные
//      ** ТолькоДляПолныхПрав - Булево
//      ** ТекстКнопкиПоказатьБаннер - Строка
//    * Страницы - Соответствие из КлючИЗначение:
//      ** Ключ - Строка - идентификатор
//      ** Значение - Структура:
//         ** Заголовок - Строка
//         ** СтраницаHTML - Строка
//    * ПриЗагрузкеФайла - Структура:
//      ** Страница - Структура:
//         ** Заголовок - Строка
//         ** СтраницаHTML - Строка
//      ** ПоведениеСтраницы - Строка - "ПоказатьПриОтправке", "ПоказатьДоЗакрытия", "НеПоказывать"
//
Функция КакПерсонализированныеПредложения(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("Баннеры", Новый Массив);
		Результат.Вставить("Страницы", Новый Соответствие);
		Результат.Вставить("ПриЗагрузкеФайла", Новый Структура);
		Результат.ПриЗагрузкеФайла.Вставить("Страница", Неопределено);
		Результат.ПриЗагрузкеФайла.Вставить("ПоведениеСтраницы", "НеПоказывать");
		
		Для Каждого БаннерыJson Из ОтветJson["banners"] Цикл
			Баннер = Новый Структура;
			Баннер.Вставить("Идентификатор", БаннерыJson["id"]);
			Баннер.Вставить("ЗаголовокБаннера", БаннерыJson["banner_title"]);
			Баннер.Вставить("ТекстБаннера", БаннерыJson["banner_text"]);
			Баннер.Вставить("Картинка", ПрочитатьДвоичныеДанныеКартинки(БаннерыJson["banner_image"]));
			Баннер.Вставить("ТолькоДляПолныхПрав", (БаннерыJson["full_access"] = Истина));
			Баннер.Вставить("ТекстКнопкиПоказатьБаннер", БаннерыJson["show_banner_text"]);
			
			//@skip-check typed-value-adding-to-untyped-collection
			Результат.Баннеры.Добавить(Баннер);
		КонецЦикла;
		
		Для Каждого СтраницаJson Из ОтветJson["info_pages"] Цикл
			Страница = Новый Структура;
			//@skip-check property-return-type
			Страница.Вставить("Заголовок", СтраницаJson.Значение["title"]);
			//@skip-check property-return-type
			Страница.Вставить("СтраницаHTML", СтраницаJson.Значение["body"]);
			//@skip-check property-return-type
			Результат.Страницы.Вставить("#" + СтраницаJson.Ключ, Страница);
		КонецЦикла;
		
		Если ОтветJson["on_file_upload"] <> Неопределено Тогда
			//@skip-check statement-type-change
			Страница = Результат.Страницы["#" + ОтветJson["on_file_upload"]["info_page"]];
			Если Страница <> Неопределено Тогда 
				//@skip-check property-return-type
				Результат.ПриЗагрузкеФайла.Страница = Страница;
				ПоведениеСтраницыJson = ОтветJson["on_file_upload"]["info_page_behavior"]; // Строка
				Если ПоведениеСтраницыJson = "show" Тогда
					ПоведениеСтраницы = "ПоказатьПриОтправке";
				ИначеЕсли ПоведениеСтраницыJson = "wait_to_close" Тогда
					ПоведениеСтраницы = "ПоказатьДоЗакрытия";
				Иначе
					ПоведениеСтраницы = "НеПоказывать";
				КонецЕсли;
				//@skip-check property-return-type
				Результат.ПриЗагрузкеФайла.ПоведениеСтраницы = ПоведениеСтраницы;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Новый ФиксированнаяСтруктура(Результат);
		
	Исключение
		ВызватьИсключение(
			РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
				НСтр("ru = 'Ошибка при чтении текущих персонализированных предложений';
				     |en = 'Error reading current promotion'")
			), , , ,
			ИнформацияОбОшибке()
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - результат HTTP запроса.
//
// Возвращаемое значение:
//  ФиксированнаяСтруктура:
//    * ПоказатьВводПромокода - Булево
//    * АктивироватьТестовыйПакет - Булево
//
Функция КакДопустимыеДействияПриАвторизации(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("ПоказатьВводПромокода", (ОтветJson["auth_promocode"] = Истина));
		Результат.Вставить("АктивироватьТестовыйПакет", (ОтветJson["activate_test"] = Истина));
		
		Возврат Новый ФиксированнаяСтруктура(Результат);
		
	Исключение
		ВызватьИсключение(
			РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
				НСтр("ru = 'Ошибка при чтении текущих персонализированных предложений';
				     |en = 'Error reading current promotion'")
			), , , ,
			ИнформацияОбОшибке()
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - результат HTTP запроса.
//
// Возвращаемое значение:
//  ФиксированнаяСтруктура:
//    * Применен - Булево
//    * ТекстПользователю - Строка
//
Функция КакРезультатАктивацииПромокода(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("Применен", (ОтветJson["result"] = "applied"));
		Результат.Вставить("ТекстПользователю", Строка(ОтветJson["message"]));
		
		Возврат Новый ФиксированнаяСтруктура(Результат);
		
	Исключение
		ВызватьИсключение(
			РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
				НСтр("ru = 'Ошибка при чтении текущих персонализированных предложений';
				     |en = 'Error reading current promotion'")
			), , , ,
			ИнформацияОбОшибке()
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - результат HTTP запроса.
//
// Возвращаемое значение:
//  Структура:
//    * ОбработкаЗавершена - Булево - завершена ли работа с заданием на сервере распознавания.
//    * ДатаСоздания - Дата - дата отправки задания распознавания на сервер.
//    * АдресаЗагрузкиФайлов - Массив из см. РаспознаваниеДокументовSDK.ЗагрузкаФайлаПоАдресу.
//    * ИдентификаторПриложения - Строка - идентификатор приложенения.
//    * ИдентификаторМобильногоПриложения - Строка - идентификатор мобильного приложенения.
//    * РаспознанныеДокументы - Массив из Структура:
//      ** ИдентификаторДокумента - Строка - идентификатор обнаруженного документа в задании распознавания.
//      ** Тип - Строка - тип формата документа
//      ** ОшибкаРаспознавания - Булево - документ является ошибкой распознавания.
//      ** ТекстОшибки - Строка - подробное описание ошибки распознавания.
//      ** ИдентификаторыФайлов - Массив из Строка - список идентификаторов файлов, объединенных в один документ
//      ** ИменаФайлов - Массив из Строка - список имен файлов, объединенных в один документ
//      ** Страницы - Массив из Структура - список страниц всех файлов из которых составлен документ:
//           *** ИдентификаторФайла - Строка - идентификатор, соответствующий результату загрузки файла.
//           *** ИмяФайла - Строка - имя обработанного файла.
//           *** НомерСтраницы - Число - номер страницы обработанного файла.
//
Функция КакСостояниеОбработкиЗадания(Ответ) Экспорт
	
	ОбработкаЗавершена = (Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200);
	ОшибкаПолученияСостояния =
		(Ответ.КодСостояния >= РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ВнутренняяОшибкаСервера_500);
	
	Результат = Новый Структура;
	Результат.Вставить("ОбработкаЗавершена", ОбработкаЗавершена);
	Результат.Вставить("ДатаСоздания", Дата("00010101"));
	Результат.Вставить("АдресаЗагрузкиФайлов", Новый Массив);
	Результат.Вставить("ИдентификаторПриложения", "");
	Результат.Вставить("ИдентификаторМобильногоПриложения", "");
	Результат.Вставить("РаспознанныеДокументы", Новый Массив);
	
	Если ОшибкаПолученияСостояния Тогда
		Возврат Результат;
	КонецЕсли;
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		ЗаполнитьСостояниеОбработкиЗадания(Результат, ОтветJson);
		
		Возврат Результат;
		
	Исключение
		ВызватьИсключение(
			РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
				НСтр("ru = 'Ошибка при чтении состояния обработки задания';
				     |en = 'Error reading task processing status'")
			), , , ,
			ИнформацияОбОшибке()
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - результат HTTP запроса.
//
// Возвращаемое значение:
//   см. НовыеСвойстваРаспознанногоДокумента
//
Функция КакСвойстваРаспознанногоДокумента(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = НовыеСвойстваРаспознанногоДокумента();
		ЗаполнитьСвойстваРаспознанногоДокумента(Результат, ОтветJson);
		
	Исключение
		
		Результат = Неопределено;
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - результат HTTP запроса.
//
// Возвращаемое значение:
//  Структура:
//   * ИдентификаторИБ - Строка
//   * ТокенДоступа - Строка
//   * Состояние - Строка
//
Функция КакРезультатАвторизации(Ответ) Экспорт
	
	ТелоОтветаНаЗапрос = РаспознаваниеДокументовHTTP.КакТекст(Ответ);
	ДесериализованноеЗначение = РаспознаваниеДокументовHTTP.JsonВОбъект(ТелоОтветаНаЗапрос);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200
		И Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Принято_202 Тогда
		
		Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().НеверныйЗапрос_400 Тогда
			ТекстОшибки = НСтр("ru = 'Неверный логин или пароль.'; en = 'Wrong login or password.'");
		ИначеЕсли ТипЗнч(ДесериализованноеЗначение) = Тип("Соответствие") Тогда
			ТекстОшибки = ДесериализованноеЗначение.Получить("message"); // Строка
		Иначе
			ТекстОшибки = НСтр("ru = 'Ошибка при авторизации в сервисе распознавания.'; en = 'Error auth'");
		КонецЕсли;
		
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Состояние = XMLСтрока(ДесериализованноеЗначение.Получить("status"));
	Если Состояние = "pending" Тогда
		Состояние = "Ожидает";
	Иначе
		Состояние = "Активирован";
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ИдентификаторИБ", XMLСтрока(ДесериализованноеЗначение.Получить("client_id")));
	Результат.Вставить("ТокенДоступа", XMLСтрока(ДесериализованноеЗначение.Получить("session_id")));
	Результат.Вставить("Состояние", Состояние);
	
	Возврат Результат;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  СущностиJson - Соответствие Из КлючИЗначение - десериализованное значение прочитанного json фрагмента.
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//    * Ключ - Строка - уникальный идентификатору сущности в коллекции.
//        Может быть строковым уникальным идентификатором или именем известного класса.
//    * Значение - см. НоваяСущность
//
Функция ПрочитатьСущности(СущностиJson) Экспорт
	
	Сущности = Новый Соответствие;
	
	Для Каждого СущностьJson Из СущностиJson Цикл
		
		Сущность = ПрочитатьСвойстваСущности(СущностьJson.Ключ, СущностьJson.Значение);
		Сущности.Вставить(Сущность.Ключ, Сущность);
		
	КонецЦикла;
	
	Возврат Сущности;
	
КонецФункции

// Конструктор свойств распознанного документа.
//
// Возвращаемое значение:
//  Структура:
//    * Статус - Строка - статус обработки документа.
//    * Тип - Строка - тип формата документа
//    * Класс - Строка - предполагаемый класс документа.
//    * ПредставлениеДокумента - Строка - представление документа.
//    * Миниатюра - ДвоичныеДанные
//    * Картинка - ДвоичныеДанные
//    * ОшибкаРаспознавания - Булево - документ является ошибкой распознавания.
//    * ТекстОшибки - Строка - подробное описание ошибки распознавания.
//    * Страницы - Соответствие из КлючИЗначение:
//        ** Ключ - Строка - имя страницы, например "0", "1"...
//        ** Значение - См. НоваяСтраницаРаспознанногоДокумента
//
Функция НовыеСвойстваРаспознанногоДокумента() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Статус", СтатусыДокумента().Ошибка);
	Результат.Вставить("Тип", ТипыДокумента().НеопределенныйФормат);
	Результат.Вставить("Класс", КлассыДокумента().НеопределенныйДокумент);
	Результат.Вставить("ПредставлениеДокумента", "");
	Результат.Вставить("Миниатюра", Base64Значение(""));
	Результат.Вставить("Картинка", Base64Значение(""));
	Результат.Вставить("ОшибкаРаспознавания", Истина);
	Результат.Вставить("ТекстОшибки", "");
	Результат.Вставить("Страницы", Новый Соответствие);
	
	Возврат Результат;
	
КонецФункции

// Конструктор свойств страницы распознанного документа.
//
// Возвращаемое значение:
// Структура:
//   * Картинка - ДвоичныеДанные
//   * Миниатюра - ДвоичныеДанные
//   * Высота - Число
//   * Ширина - Число
//   * Сущности - см. НовоеСоответствиеСущностей
//   * Печати - Массив из Структура:
//      ** Картинка - ДвоичныеДанные - вырезанная картинка печати.
//      ** Область - Строка, Неопределено - координаты области на картинке в которой найдена печать.
//   * Подписи - Массив из Структура:
//      ** Картинка - ДвоичныеДанные - вырезанная картинка подписи.
//      ** Область - Строка, Неопределено - координаты области на картинке в которой найдена подпись.
//
Функция НоваяСтраницаРаспознанногоДокумента() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Картинка", Base64Значение(""));
	Результат.Вставить("Миниатюра", Base64Значение(""));
	Результат.Вставить("Высота", 0);
	Результат.Вставить("Ширина", 0);
	Результат.Вставить("Сущности", НовоеСоответствиеСущностей());
	Результат.Вставить("Печати", Новый Массив);
	Результат.Вставить("Подписи", Новый Массив);
	Результат.Вставить("Текст", Новый Массив);
	
	Возврат Результат;
	
КонецФункции

// Новое соответствие сущностей.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//    * Ключ - Строка - ключ сущности
//    * Значение - см. НоваяСущность
//
Функция НовоеСоответствиеСущностей() Экспорт
	
	Возврат Новый Соответствие;
	
КонецФункции

// Новая таблица сущности.
// 
// Возвращаемое значение:
//  Структура - данные табличного типа:
//    * Колонки - см. НовоеСоответствиеСущностей
//    * Строки - Массив из см. НовоеСоответствиеСущностей
//    * Подвалы - Соответствие из КлючИЗначение:
//        ** Ключ - Строка - имя известного класса футера.
//        ** Значение - см. НовоеСоответствиеСущностей
//
Функция НоваяТаблицаСущности() Экспорт
	
	Таблица = Новый Структура;
	Таблица.Вставить("Колонки", Новый Соответствие);
	Таблица.Вставить("Строки", Новый Массив);
	Таблица.Вставить("Подвалы", Новый Соответствие);
	
	Возврат Таблица;
	
КонецФункции

// Конструктор новой сущности.
//
// Возвращаемое значение:
//  Структура:
//    * Ключ - Строка - ключ сущности, дублирует значение ключа коллекции.
//    * Класс - Строка, Неопределено - имя одного из классов известных сущностей.
//    * УникальныйИдентификатор - Строка, Неопределено - уникальный идентификатор х сущности.
//    * Тип - Строка, Неопределено - имя типа одного из известных типов.
//    * ЭтоТипСоставной - Булево - Истина, если это составной тип. См. поле Свойства.
//    * ЭтоТипИдентификатор - Булево - Истина, если это тип идентификатор. См. поле Значение.
//    * ЭтоТипТекст - Булево - Истина, если это тип текст. См. поле Значение.
//    * ЭтоТипЧисло - Булево - Истина, если это тип числа. См. поле Значение.
//    * ЭтоТипДата - Булево - Истина, если это тип даты. См. поле Значение.
//    * ЭтоТипТаблица - Булево - Истина, если это табличный тип. См поле Таблица.
//    * ЭтотТипСтроковой - Булево - Истина, если это тип хранящий строковые данные. См. поле Значение.
//    * ЭтотТипПримитивный - Булево - Истина, если это примитивный тип. См. поле Значение.
//    * Уверенность - Число - уверенность найденного значения в промежутке от 0 до 1.
//    * НомерСтраницы - Число - страница, на которой найдена сущность.
//    * Область - Неопределено, Строка - координаты области на картинке в которой найдена сущность.
//    * Картинка - ДвоичныеДанные - вырезанный фрагмент картинки, соответствующий сущности.
//    * КоличествоСтрок - Число - количество строк изначального фрашмента в обнаруженной сущности.
//    * РаспознанныйТекст - Строка - текстовое представление распознанного значения.
//    * Значение - Неопределено, Строка, Число, Дата - значение для примитивного типа.
//    * Свойства - Соответствие из КлючИЗначение - свойства составного типа:
//        ** Ключ - Строка - имя известного свойства
//        ** Значение - Строка - уникальный идентификатор сущности в которой хранится значение.
//    * Таблица - см. НоваяТаблицаСущности
//
Функция НоваяСущность() Экспорт
	
	Сущность = Новый Структура;
	Сущность.Вставить("Ключ", "");
	Сущность.Вставить("УникальныйИдентификатор", "");
	Сущность.Вставить("Класс", "");
	Сущность.Вставить("Тип", "");
	Сущность.Вставить("ЭтоТипСоставной", Ложь);
	Сущность.Вставить("ЭтоТипИдентификатор", Ложь);
	Сущность.Вставить("ЭтоТипТекст", Ложь);
	Сущность.Вставить("ЭтоТипЧисло", Ложь);
	Сущность.Вставить("ЭтоТипДата", Ложь);
	Сущность.Вставить("ЭтоТипТаблица", Ложь);
	Сущность.Вставить("ЭтотТипСтроковой", Ложь);
	Сущность.Вставить("ЭтотТипПримитивный", Ложь);
	Сущность.Вставить("Уверенность", 0);
	Сущность.Вставить("НомерСтраницы", 0);
	Сущность.Вставить("Область", Неопределено);
	Сущность.Вставить("Картинка", Base64Значение(""));
	Сущность.Вставить("КоличествоСтрок", 0);
	Сущность.Вставить("РаспознанныйТекст", "");
	Сущность.Вставить("Значение", Неопределено);
	Сущность.Вставить("Свойства", Новый Соответствие);
	Сущность.Вставить("Таблица", НоваяТаблицаСущности());
	
	Возврат Сущность;
	
КонецФункции

#КонецОбласти

#Область Переопределяемый

// Для быстрой подмены адреса сервиса распознавания.
// Исп. в расширении.
//
// Возвращаемое значение:
//   Строка
//
Функция АдресСервисаРаспознавания() Экспорт
	
	Параметры = ПараметрыАвторизацииНеАвторизован();
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации(Параметры);
	
	Возврат Параметры.АдресСервисаРаспознавания;
	
КонецФункции

// Для быстрой подмены номера модели распознавания.
// Исп. в расширении.
//
// Возвращаемое значение:
//   Строка
//
Функция НомерМодели() Экспорт
	
	Параметры = ПараметрыАвторизацииНеАвторизован();
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации(Параметры);
	
	Возврат Параметры.НомерМодели;
	
КонецФункции

// Для быстрой подмены формата распознавания.
// Исп. в расширении.
//
// Возвращаемое значение:
//   Строка
//
Функция ТолькоУниверсальныйФормат() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ТолькоУниверсальныйФормат", Ложь);
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыSDK(Параметры);
	
	Возврат Параметры.ТолькоУниверсальныйФормат;
	
КонецФункции

// Для быстрой подмены формата распознавания.
// Исп. в расширении.
//
// Возвращаемое значение:
//   Соответствие из КлючИЗначение
//
Функция ОбластьАвторизации() Экспорт
	
	Результат = Новый Соответствие;
	Результат.Вставить("Конфигурация", Метаданные.Имя);
	Результат.Вставить("ВерсияКонфигурации", Метаданные.Версия);
	Результат.Вставить("ТекущаяУниверсальнаяДата", ЗаписатьДатуJSON(ТекущаяУниверсальнаяДата(), ФорматДатыJSON.ISO));
	
	Результат.Вставить("ВерсияБиблиотеки", "");
	Результат.Вставить("ИнформацияМоделиСервиса", Неопределено);
	Результат.Вставить("ИнформацияИТС", Неопределено);
	Результат.Вставить("ТипАутентификации", "<Неопределено>");
	Результат.Вставить("ИдентификаторИнформационнойБазы", "");
	
	РаспознаваниеДокументовSDKПереопределяемый.ОбластьАвторизации(Результат);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ДобавитьЗаголовокАвторизации(Заголовки)
	
	Параметры = ПараметрыАвторизацииНеАвторизован();
	РаспознаваниеДокументовSDKПереопределяемый.ПараметрыАвторизации(Параметры);
	
	Если Параметры.РежимАвторизации = "Десктоп" Тогда
		Заголовки.Вставить("X-Auth-Token", Параметры.Токен);
	ИначеЕсли Параметры.РежимАвторизации = "МобильноеПриложение" Тогда
		Заголовки.Вставить("X-Auth-Sub-Token", Параметры.Токен);
	Иначе
		// Никие заголовки не добавляем
	КонецЕсли;
	
КонецПроцедуры

#Область ОбработкаОшибок

Процедура ПроверитьКодСостоянияОтвета(Ответ)
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().НеАвторизован_401 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка авторизации. Скорее всего ключ пользователя устарел.
			         |Попробуйте выйти и авторизоваться с новым идентификатором.';
			     |en='Authorization error. The user key might be expired.
			         |Please log out and log in back with a new user key.'")
		);
	КонецЕсли;
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().НеобходимаОплата_402 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Недостаточно средств для выполнения распознавания.
			         |Пополните баланс.';
			     |en='Insufficient funds to recognize.
			         |Please top up your balance at https://portal.1c.ru/'")
		);
	КонецЕсли;
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Запрещено_403 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Ошибка доступа. Скорее всего ключ пользователя устарел.
			         |Попробуйте выйти и авторизоваться с новым идентификатором.';
			     |en='Access error. The user key might be expired.
			         |Please log out and log in back with a new user key.'")
		);
	КонецЕсли;
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Заблокировано_423 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Пилотное использование сервиса распознавания документов завершено.
			           |Для продолжения работы, пожалуйста, войдите с помощью учетной записи 1С:ИТС.';
			     |en = 'The test use of the document recognition service has ended.
			           |To continue, please log in using your 1C:ITS account.'")
		);
	КонецЕсли;
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().НевыполненнаяЗависимость_424 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Заявка на подключение сервиса распознавания документов отправлена
			           |и будет обработана в ближайшее время.';
			     |en = 'The request to connect the document recognition service has been submitted
			           |and will be processed shortly.'")
		);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область Парсеры

Процедура ЗаполнитьСостояниеОбработкиЗадания(Результат, ОтветJson)
	
	АдресаЗагрузкиФайлов = ОтветJson["info"]["upload_path"]; // Массив из Строка
	
	Результат.ДатаСоздания =  ПрочитатьДату(ОтветJson["info"]["create_time"]);
	Результат.АдресаЗагрузкиФайлов = АдресаЗагрузкиФайлов;
	Результат.ИдентификаторПриложения = XMLСТрока(ОтветJson["client_id"]);
	Результат.ИдентификаторМобильногоПриложения = XMLСТрока(ОтветJson["sub_client_id"]);
	
	РезультатСуществует = Ложь;
	
	РезультатJson = ОтветJson.Получить("result");
	Если ЗначениеЗаполнено(РезультатJson) Тогда
		РезультатСуществует = Истина;
	КонецЕсли;
	
	Если РезультатСуществует Тогда
		
		ДокументыJson = РезультатJson["documents"]; // Массив из Соответствие
		
		Для Каждого ДокументJson Из ДокументыJson Цикл
			
			ИдентификаторДокумента = XMLСтрока(ДокументJson["id"]);
			ТипДокумента = XMLСтрока(ДокументJson["type"]);
			Тип = ТипДокумента(ТипДокумента);
			
			КодОшибки = ПрочитатьЧисло(ДокументJson["error"]);
			ОшибкаРаспознавания = ЗначениеЗаполнено(КодОшибки);
			Если ОшибкаРаспознавания Тогда
				ТекстОшибки = ТекстОшибкиПоКоду(КодОшибки);
			КонецЕсли;
			
			РаспознанныйДокумент = Новый Структура;
			РаспознанныйДокумент.Вставить("ИдентификаторДокумента", ИдентификаторДокумента);
			РаспознанныйДокумент.Вставить("Тип", Тип);
			РаспознанныйДокумент.Вставить("ОшибкаРаспознавания", ОшибкаРаспознавания);
			РаспознанныйДокумент.Вставить("ТекстОшибки", ТекстОшибки);
			РаспознанныйДокумент.Вставить("ИдентификаторыФайлов", Новый Массив);
			РаспознанныйДокумент.Вставить("ИменаФайлов", Новый Массив);
			РаспознанныйДокумент.Вставить("Страницы", Новый Массив);
			
			СтраницыJson = ДокументJson["pages_info"];
			Для Каждого СтраницаДокумента Из СтраницыJson Цикл
				
				ИдентификаторФайла = ПрочитатьСтроку(СтраницаДокумента["file_id"]);
				ИмяФайла = ПрочитатьСтроку(СтраницаДокумента["file"]);
				НомерСтраницы = ПрочитатьЧисло(СтраницаДокумента["page_index"]);
				
				Страница = Новый Структура;
				Страница.Вставить("ИдентификаторФайла", ИдентификаторФайла);
				Страница.Вставить("ИмяФайла", ИмяФайла);
				Страница.Вставить("НомерСтраницы", НомерСтраницы);
				
				//@skip-check typed-value-adding-to-untyped-collection
				РаспознанныйДокумент.Страницы.Добавить(Страница);
				
				НеВключенВСписокФайлов = (РаспознанныйДокумент.ИдентификаторыФайлов.Найти(ИдентификаторФайла) = Неопределено);
				Если НеВключенВСписокФайлов Тогда
					//@skip-check typed-value-adding-to-untyped-collection
					РаспознанныйДокумент.ИдентификаторыФайлов.Добавить(ИдентификаторФайла);
					//@skip-check typed-value-adding-to-untyped-collection
					РаспознанныйДокумент.ИменаФайлов.Добавить(ИмяФайла);
				КонецЕсли;
				
			КонецЦикла;
			
			//@skip-check typed-value-adding-to-untyped-collection
			Результат.РаспознанныеДокументы.Добавить(РаспознанныйДокумент);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьСвойстваРаспознанногоДокумента(Результат, ОтветJson)
	
	Результат.Статус = СтатусДокумента(ПрочитатьСтроку(ОтветJson["status"]));
	Результат.Тип = ТипДокумента(ПрочитатьСтроку(ОтветJson["result"]["document"]["type"]));
	Результат.Класс  = КлассДокумента(ПрочитатьСтроку(ОтветJson["result"]["document"]["class"]));
	Результат.ПредставлениеДокумента = ПрочитатьСтроку(ОтветJson["result"]["document"]["name"]);
	
	КодОшибки = ПрочитатьЧисло(ОтветJson["result"]["document"]["error"]);
	Результат.ОшибкаРаспознавания = ЗначениеЗаполнено(КодОшибки);
	Результат.ТекстОшибки = ТекстОшибкиПоКоду(КодОшибки);
	
	СтраницыJson = ОтветJson["result"]["data"]["pages"]; // Соответствие
	
	Для Каждого СтраницаJsonКлючЗначение Из СтраницыJson Цикл
		
		СтраницаJson = СтраницаJsonКлючЗначение.Значение; // Соответствие
		
		Картинка = ПрочитатьДвоичныеДанныеКартинки(СтраницаJson["page_info"]["image"]);
		Миниатюра = ПрочитатьДвоичныеДанныеКартинки(СтраницаJson["page_info"]["thumbnail"]);
		Высота = ПрочитатьЧисло(СтраницаJson["page_info"]["width"]);
		Ширина = ПрочитатьЧисло(СтраницаJson["page_info"]["height"]);
		
		СущностиJson = СтраницаJson["entities"]; // Соответствие
		Сущности = ПрочитатьСущности(СущностиJson);
		
		Страница = НоваяСтраницаРаспознанногоДокумента();
		Страница.Картинка = Картинка;
		Страница.Миниатюра = Миниатюра;
		Страница.Высота = ПрочитатьЧисло(Высота);
		Страница.Ширина = ПрочитатьЧисло(Ширина);
		Страница.Сущности = Сущности;
		
		СтруктурыJson = СтраницаJson["structures"];
		Если ЗначениеЗаполнено(СтруктурыJson) Тогда
			ЗаполнитьПечатиПодписи(Страница.Печати, СтруктурыJson["stamps"]);
			ЗаполнитьПечатиПодписи(Страница.Подписи, СтруктурыJson["signatures"]);
			ЗаполнитьТекст(Страница.Текст, СтруктурыJson["text"]);
		КонецЕсли;
		
		Результат.Страницы.Вставить(СтраницаJsonКлючЗначение.Ключ, Страница);
		
	КонецЦикла;
	
	Если Результат.Страницы.Количество() > 0 Тогда
		Результат.Картинка = Результат.Страницы["0"].Картинка;
		Результат.Миниатюра = Результат.Страницы["0"].Миниатюра;
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьТекст(Список, СписокJson)
	
	Если Не ЗначениеЗаполнено(СписокJson) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ОбъектJson Из СписокJson Цикл
	
		Объект = Новый Структура;
		Объект.Вставить("Значение", ОбъектJson);
		
		Список.Добавить(Объект);
		
	КонецЦикла;
	
КонецПроцедуры

//@skip-check method-param-value-type
Процедура ЗаполнитьПечатиПодписи(Список, СписокJson, ИмяСвостваОбласть = "bbox", ИмяСвостваКартинка = "chunk_img")
	
	Если Не ЗначениеЗаполнено(СписокJson) Тогда
		Возврат;
	КонецЕсли;
	
	//@skip-check variable-value-type
	Для Каждого ОбъектJson Из СписокJson Цикл
		Область = ПрочитатьОбласть(ОбъектJson[ИмяСвостваОбласть]);
		Картинка = ПрочитатьДвоичныеДанныеКартинки(ОбъектJson[ИмяСвостваКартинка]);
		
		Объект = Новый Структура;
		Объект.Вставить("Область", Область);
		Объект.Вставить("Картинка", Картинка);
		
		Список.Добавить(Объект);
	КонецЦикла;

КонецПроцедуры

//@skip-check method-param-value-type
Функция ПрочитатьСвойстваСущности(Ключ, СущностьJson)
	
	Сущность = НоваяСущность();
	Сущность.Ключ = ПрочитатьСтроку(Ключ);
	
	Сущность.УникальныйИдентификатор = ПрочитатьСтроку(СущностьJson["uuid"]);
	Сущность.Тип = ТипСущности(ПрочитатьСтроку(СущностьJson["type"]));
	Сущность.Класс = КлассСущности(ПрочитатьСтроку(СущностьJson["class"]));
	Сущность.Уверенность = ПрочитатьЧисло(СущностьJson["confidence"]);
	Сущность.НомерСтраницы = ПрочитатьЧисло(СущностьJson["page_index"]);
	Сущность.Область = ПрочитатьОбласть(СущностьJson["bbox"]);
	Сущность.Картинка = ПрочитатьДвоичныеДанныеКартинки(СущностьJson["chunk_img"]);
	Сущность.КоличествоСтрок = ПрочитатьЧисло(СущностьJson["num_lines"]);
	
	Сущность.ЭтоТипСоставной     = (Сущность.Тип = "Составной");
	Сущность.ЭтоТипИдентификатор = (Сущность.Тип = "Идентификатор");
	Сущность.ЭтоТипТекст         = (Сущность.Тип = "Текст");
	Сущность.ЭтоТипЧисло         = (Сущность.Тип = "Число");
	Сущность.ЭтоТипДата          = (Сущность.Тип = "Дата");
	Сущность.ЭтоТипТаблица       = (Сущность.Тип = "Таблица");
	
	Сущность.ЭтотТипСтроковой   = Сущность.ЭтоТипИдентификатор Или Сущность.ЭтоТипТекст;
	Сущность.ЭтотТипПримитивный = Сущность.ЭтоТипИдентификатор Или Сущность.ЭтоТипТекст
	                                  Или Сущность.ЭтоТипЧисло Или Сущность.ЭтоТипДата;
	
	Если Сущность.ЭтотТипПримитивный Тогда
		Возврат ПрочитатьСвойстваСущностиПримитивногоТипа(Сущность, СущностьJson);
	ИначеЕсли Сущность.ЭтоТипСоставной Тогда
		Возврат ПрочитатьСвойстваСущностиСоставногоТипа(Сущность, СущностьJson);
	ИначеЕсли Сущность.ЭтоТипТаблица Тогда
		Возврат ПрочитатьСвойстваСущностиТабличногоТипа(Сущность, СущностьJson);
	Иначе
		Возврат Сущность; // Сущность неопознанного типа
	КонецЕсли;
	
КонецФункции

Функция ПрочитатьСвойстваСущностиПримитивногоТипа(Сущность, СущностьJson)
	
	Значение = ПрочитатьСтроку(СущностьJson["value"]);
	
	Если Сущность.ЭтотТипСтроковой Тогда
		Сущность.Значение = Значение;
		Сущность.РаспознанныйТекст = Значение;
	ИначеЕсли Сущность.ЭтоТипЧисло Тогда
		Сущность.Значение = ПрочитатьЧисло(Значение);
		Сущность.РаспознанныйТекст = XMLСтрока(Значение);
	ИначеЕсли Сущность.ЭтоТипДата Тогда
		Сущность.Значение = ПрочитатьДату(Значение);
		Сущность.РаспознанныйТекст = Значение;
	Иначе
		Сущность.Значение = Неопределено;
		Сущность.РаспознанныйТекст = "";
	КонецЕсли;
	
	Возврат Сущность;
	
КонецФункции

Функция ПрочитатьСвойстваСущностиСоставногоТипа(Сущность, СущностьJson)
	
	СвойстваJson = СущностьJson["fields"]; // Соответствие
	Сущность.Свойства = Новый Соответствие;
	
	Для Каждого СвойствоJson Из СвойстваJson Цикл
		КлючСвойства = СвойствоСущности(ПрочитатьСтроку(СвойствоJson.Ключ));
		Сущность.Свойства.Вставить(КлючСвойства, СвойствоJson.Значение);
	КонецЦикла;
	
	Возврат Сущность;
	
КонецФункции

Функция ПрочитатьСвойстваСущностиТабличногоТипа(Сущность, СущностьJson)
	
	Таблица = НоваяТаблицаСущности();
	
	КолонкиJson = СущностьJson["header"]; // Соответствие
	Таблица.Колонки = ПрочитатьКолонкиТаблицы(КолонкиJson);
	
	СтрокиJson = СущностьJson["body"]; // Массив
	Для Каждого СтрокаJson Из СтрокиJson Цикл
		Строка = ПрочитатьСтрокуТаблицы(СтрокаJson);
		//@skip-check typed-value-adding-to-untyped-collection
		Таблица.Строки.Добавить(Строка);
	КонецЦикла;
	
	ПодвалыJson = СущностьJson["footer"]; // Соответствие
	Для Каждого ПодвалJson Из ПодвалыJson Цикл
		КлючПодвала = ПодвалТаблицы(ПрочитатьСтроку(ПодвалJson.Ключ));
		СущностиПодвала = ПрочитатьСтрокуТаблицы(ПодвалJson.Значение);
		Таблица.Подвалы.Вставить(КлючПодвала, СущностиПодвала);
	КонецЦикла;
	
	Сущность.Таблица = Таблица;
	
	Возврат Сущность;
	
КонецФункции

Функция ПрочитатьКолонкиТаблицы(КолонкиJson)
	
	Колонки = Новый Соответствие;
	
	Для Каждого КолонкаJson Из КолонкиJson Цикл
		
		Сущность = ПрочитатьСвойстваСущности(Неопределено, КолонкаJson);
		Колонки.Вставить(Сущность.Класс, Сущность);
		
	КонецЦикла;
	
	Возврат Колонки;
	
КонецФункции

Функция ПрочитатьСтрокуТаблицы(СтрокаJson)
	
	Сущности = Новый Соответствие;
	
	Для Каждого СущностьJson Из СтрокаJson Цикл
		
		//@skip-check property-return-type
		Сущность = ПрочитатьСвойстваСущности(СущностьJson.Ключ, СущностьJson.Значение);
		Сущности.Вставить(Сущность.Класс, Сущность);
		
	КонецЦикла;
	
	Возврат Сущности;
	
КонецФункции

//@skip-check method-param-value-type
Функция ПрочитатьОбласть(ОбластьJson)
	
	Если Не ЗначениеЗаполнено(ОбластьJson) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(ОбластьJson) = Тип("Строка") Тогда
		Возврат ОбластьJson;
	КонецЕсли;
	
	Координаты = Новый Массив; // Массив из Строка
	
	//@skip-check variable-value-type
	Для Каждого Координата Из ОбластьJson Цикл
		Координаты.Добавить(XMLСтрока(Координата));
	КонецЦикла;
	
	Возврат СтрСоединить(Координаты, ",");
	
КонецФункции

// Параметры:
//  СтрокаBase64 - Произвольный
// 
// Возвращаемое значение:
//  ДвоичныеДанные
//
Функция ПрочитатьДвоичныеДанныеКартинки(Знач СтрокаBase64)
	
	Если ТипЗнч(СтрокаBase64) = Тип("Строка") Тогда
		
		Если СтрНачинаетсяС(СтрокаBase64, "data:image/png;base64,") Тогда
			СтрокаBase64 = Сред(СтрокаBase64, 23);
		КонецЕсли;
		Если СтрНачинаетсяС(СтрокаBase64, "data:image/jpeg;base64,") Тогда
			СтрокаBase64 = Сред(СтрокаBase64, 24);
		КонецЕсли;
		
		Возврат Base64Значение(СтрокаBase64);
		
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Параметры:
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  Строка
//
Функция ПрочитатьСтроку(Значение)
	
	Возврат XMLСтрока(Значение);
	
КонецФункции

// Параметры:
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  Число
//
Функция ПрочитатьЧисло(Значение)
	
	Если ТипЗнч(Значение) = Тип("Число") Тогда
		Возврат Значение;
	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда
		ОписаниеТипа = Новый ОписаниеТипов("Число");
		Результат = ОписаниеТипа.ПривестиЗначение(Значение);
		Если ТипЗнч(Результат) = Тип("Число") Тогда
			Возврат Результат;
		Иначе
			Возврат 0;
		КонецЕсли;
	Иначе
		Возврат 0;
	КонецЕсли;
	
КонецФункции

// Параметры:
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  Дата
//
Функция ПрочитатьДату(Знач Значение)
	
	ПустаяДата = Дата("00010101");
	Попытка
		Если Не ЗначениеЗаполнено(Значение) Тогда
			Дата = ПустаяДата;
		Иначе
			Если ТипЗнч(Значение) <> Тип("Строка") Тогда
				Значение = Строка(Значение);
			КонецЕсли;
			//@skip-check invocation-parameter-type-intersect
			Дата = ПрочитатьДатуJSON(Значение, ФорматДатыJSON.ISO);
			Если Год(Дата) > 3999 Тогда
				Дата = ПустаяДата;
			КонецЕсли;
		КонецЕсли;
		Возврат Дата;
	Исключение
		Возврат ПустаяДата;
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область ПовтИсп

// Параметры:
//  КодОшибки - Число
// 
// Возвращаемое значение:
//  Строка
//
Функция ТекстОшибкиПоКоду(КодОшибки)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТекстОшибкиПоКоду(КодОшибки);
	
КонецФункции

// Параметры:
//  Ключ - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция СтатусДокумента(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.СтатусДокумента(Ключ);
	
КонецФункции

// Параметры:
//  Ключ - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ТипДокумента(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТипДокумента(Ключ);
	
КонецФункции

// Параметры:
//  Ключ - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция КлассДокумента(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.КлассДокумента(Ключ);
	
КонецФункции

// Параметры:
//  Ключ - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ТипСущности(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТипСущности(Ключ);
	
КонецФункции

// Параметры:
//  Ключ - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция КлассСущности(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.КлассСущности(Ключ);
	
КонецФункции

// Параметры:
//  Ключ - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция СвойствоСущности(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.СвойствоСущности(Ключ);
	
КонецФункции

// Параметры:
//  Ключ - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ПодвалТаблицы(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ПодвалТаблицы(Ключ);
	
КонецФункции

#КонецОбласти

Процедура ОчиститьДвоичныеДанныеИзображенийДокумента(СвойстваСтраницы, ПараметрыСериализации)
	
	Если ПараметрыСериализации.ОчищатьИзображенияДокумента Тогда
		СвойстваСтраницы.Картинка = Неопределено;
		СвойстваСтраницы.Миниатюра = Неопределено;
	Иначе
		СвойстваСтраницы.Картинка = Base64Строка(СвойстваСтраницы.Картинка);
		СвойстваСтраницы.Миниатюра = Base64Строка(СвойстваСтраницы.Миниатюра);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОчиститьДвоичныеДанныеСущностей(Сущности, ПараметрыСериализации)
	
	Для Каждого Сущность Из Сущности Цикл
		
		Если ПараметрыСериализации.ОчищатьИзображенияСущностей Тогда
			Сущность.Значение.Картинка = Неопределено;
		Иначе
			Сущность.Значение.Картинка = Base64Строка(Сущность.Значение.Картинка);
		КонецЕсли;
		
		Если Сущность.Значение.Таблица <> Неопределено Тогда
			
			ОчиститьДвоичныеДанныеСущностей(Сущность.Значение.Таблица.Колонки, ПараметрыСериализации);
			
			Для Каждого Строка Из Сущность.Значение.Таблица.Строки Цикл
				ОчиститьДвоичныеДанныеСущностей(Строка, ПараметрыСериализации);
			КонецЦикла;
			
			Для Каждого Строка Из Сущность.Значение.Таблица.Подвалы Цикл
				ОчиститьДвоичныеДанныеСущностей(Строка.Значение, ПараметрыСериализации);
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОчиститьДвоичныеДанныеПечатейПодписей(СвойстваСтраницы, ПараметрыСериализации)
	
	Если ПараметрыСериализации.ОчищатьИзображенияПечатейПодписей Тогда
		Для Каждого Строка Из СвойстваСтраницы.Печати Цикл
			Строка.Картинка = Неопределено;
		КонецЦикла;
		
		Для Каждого Строка Из СвойстваСтраницы.Подписи Цикл
			Строка.Картинка = Неопределено;
		КонецЦикла;
	Иначе
		Для Каждого Строка Из СвойстваСтраницы.Печати Цикл
			Строка.Картинка = Base64Строка(Строка.Картинка);
		КонецЦикла;
		
		Для Каждого Строка Из СвойстваСтраницы.Подписи Цикл
			Строка.Картинка = Base64Строка(Строка.Картинка);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьЗначенияПоСоответствию(Приемник, Источник, СписокСвойств = "", ИсключаяСвойства = "")
	
	Если ЗначениеЗаполнено(СписокСвойств) Тогда
		ВызватьИсключение НСтр("ru = 'СписокСвойств пока не поддерживается'");
	КонецЕсли;
	
	Для Каждого Свойство Из Источник Цикл
		
		Если СтрНайти(ИсключаяСвойства, Свойство.Ключ) Тогда
			Продолжить;
		КонецЕсли;
		
		Если Приемник.Свойство(Свойство.Ключ) Тогда
			Приемник[Свойство.Ключ] = Свойство.Значение;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти
