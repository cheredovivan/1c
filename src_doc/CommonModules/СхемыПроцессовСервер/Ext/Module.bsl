////////////////////////////////////////////////////////////////////////////////
// Серверные процедуры и функции по работе со схемами процессов.
//  
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ПроверкаКорректностиСхемы

// Выполняет проверку корректности графической схемы и возвращает результат проверки.
//
// Параметры:
//  Схема - ГрафическаяСхема
// 
// Возвращаемое значение:
//  Структура - см. СхемыПроцессовКлиентСервер.СтруктуруРезультатаПроверкиСхемы
//
Функция СхемаКорректна(Схема) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	РезультатПроверки = СхемыПроцессовКлиентСервер.СтруктуруРезультатаПроверкиСхемы();	
	СтруктураДляПроверки = СтруктураДляПроверкиСхемы();
	
	ДлительныеОперации.СообщитьПрогресс(1, Нстр("ru = 'Заполнение кэша проверки.'"));
	ЗаполнитьКэшЭлементовВСтруктуреДляПроверки(СтруктураДляПроверки, Схема);	
	
	ДлительныеОперации.СообщитьПрогресс(20, Нстр("ru = 'Проверка заполнения предшественников.'"));
	ПроверитьЗаполнениеПредшественниковУЭлементов(СтруктураДляПроверки);
	
	ДлительныеОперации.СообщитьПрогресс(39, Нстр("ru = 'Формирование путей.'"));
	СформироватьПутиПоСхеме(СтруктураДляПроверки);
	
	ДлительныеОперации.СообщитьПрогресс(58, Нстр("ru = 'Проверка зацикливания.'"));
	ПроверитьЗацикливаниеСхемы(СтруктураДляПроверки);
	
	ДлительныеОперации.СообщитьПрогресс(77, Нстр("ru = 'Проверка разделений и слияний.'"));
	ПроверитьКорректностьРазделенийИСлияний(СтруктураДляПроверки);
	
	ДлительныеОперации.СообщитьПрогресс(100, Нстр("ru = 'Формирование протокола.'"));
	
	ЭлементыГрафическойСхемы = СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы;	
	
	Если ЗначениеЗаполнено(СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Соединительная линия ""%1"" не присоединена ни к одному элементу схемы.'"),
			СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии;
		
		// IDS_NOT_CONNECTED_TO_ANY_POINT
	
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяНедопустимогоЭлемента) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(СтруктураДляПроверки.ИмяНедопустимогоЭлемента);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Схема содержит недопустимый элемент: ""%1"".'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяНедопустимогоЭлемента;
	
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовСтарта > 1 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Элемент старта может быть только один.'");
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовСтарта = 0 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Нет ни одного элемента старта.'");
		
		// IDS_NO_START_POINT
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовЗавершения > 1 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Элемент завершения может быть только один.'");
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовЗавершения = 0 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Нет ни одного элемента завершения.'");
			
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Элемент ""%1"" не имеет ни одной входящей линии.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний;
		
		// IDS_STR_HAS_NO_START
		
	ИначеЕсли СтруктураДляПроверки.СложнаяКарта Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Проверка карты схемы процесса не выполнена, т.к. она слишком сложная.'");
		
		// IDS_TOO_COMPLEX_MAP
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаОбрыва) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаОбрыва);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Элемент ""%1"" не имеет пути к завершению схемы.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаОбрыва;
		
		// IDS_HAS_NO_PATH
		
	ИначеЕсли СтруктураДляПроверки.НетЗавершенныхПутей Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'В схеме нет ни одного завершенного пути.'");
		
		// IDS_STR_NO_ROUTE
		
	ИначеЕсли СтруктураДляПроверки.ЕстьЦиклыБезБлоковВыполнения Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Есть циклы не имеющие ни одного блока выполнения.'");
		
		// IDS_STR_HAS_CYCLES_WITHOUT_ROUTE_POINTS
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'В элемент ""%1"" невозможно попасть.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть;
		
		// IDS_STR_UNREACHABLE_CODE
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'В схеме есть зацикливание: %1'"),
			СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение);
		
		// IDS_FOUND_CYCLING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'У разделения ""%1"" есть только одна исходящая линия.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией;
		
		// IDS_STR_ONLY_ONE_OUTGOING_LINE_FROM_BRANCHING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Нельзя из разделения ""%1"" нескольким исходящим линиями входить в один и тот же элемент.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент;
		
		// IDS_STR_BRANCHING_SAME_NEXT_POINT
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеСОднойВходящейЛинией) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеСОднойВходящейЛинией);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'У слияния ""%1"" есть только одна входящая линия.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеСОднойВходящейЛинией;
		
		// IDS_STR_ONLY_ONE_INCOMING_LINE_INTO_GATHERING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеБезРазделения) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеБезРазделения);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Не все линии, вошедшие слияние ""%1"" вышли из разделения.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеБезРазделения;
		
		// IDS_STR_GATHERING_MISMATCH
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеСразуПослеРазделения) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеСразуПослеРазделения);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Нельзя сразу из разделения ""%1"" попадать в слияние.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеСразуПослеРазделения;
		
		// IDS_STR_BRANCHING_IMMEDIATELY_AFTER_GATHERING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ЭлементПересеченияРазделений) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ЭлементПересеченияРазделений);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Запрещено распараллеленным веткам входить в один и то же элемент ""%1"".'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ЭлементПересеченияРазделений;
		
		// IDS_STR_BRANCHING_MERGE
	
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ЗавершениеСразуПослеРазделения) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ЗавершениеСразуПослеРазделения);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Нельзя сразу из разделения ""%1"" попадать в завершение.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ЗавершениеСразуПослеРазделения;
		
	КонецЕсли;
	
	Возврат РезультатПроверки
	
КонецФункции

#Область ФонововаяПроверка

// Операция фоновой проверки схемы(выполнения длительной операции).
// 
// Параметры:
//  ИдентификаторФормы - УникальныйИдентификатор
//  Схема - ГрафическаяСхема
// 
// Возвращаемое значение:
//  см. ДлительныеОперации.ВыполнитьФункцию
//
Функция ЗапускФоновойПроверкиСхемы(ИдентификаторФормы, Схема) Экспорт

	ВыполняемыйМетод = "СхемыПроцессовСервер.СхемаКорректна";
	
	ПараметрыВыполнения 	= ДлительныеОперации.ПараметрыВыполненияВФоне(ИдентификаторФормы);
	ПараметрыВыполнения.НаименованиеФоновогоЗадания = СхемыПроцессовКлиентСервер.ЗаголовокПроверкаСхемы();
	ПараметрыВыполнения.ЗапуститьВФоне = Истина;
	ПараметрыВыполнения.Вставить("ИдентификаторФормы", ИдентификаторФормы); 
	
	Возврат ДлительныеОперации.ВыполнитьФункцию(ПараметрыВыполнения, ВыполняемыйМетод, Схема);

КонецФункции

#КонецОбласти

#КонецОбласти

#Область РаботаСДаннымиСхемы

// Возвращает данные схемы по умолчанию.
// 
// Возвращаемое значение:
//  см. Справочники.СхемыПроцессов.СтруктураДанныхСхемыПроцесса
// 
Функция ДанныеСхемыПоУмолчанию() Экспорт
	
	ОписаниеСхемы = Новый Массив();
		
	ЭлементСтарт = Справочники.СхемыПроцессов.ОписаниеЭлементаСтарт();
	ЭлементСтарт.Лево = 60;
	ЭлементСтарт.Верх = 20;
	ЭлементСтарт.ИмяПоследователя = "Обработка1";
	ОписаниеСхемы.Добавить(ЭлементСтарт);
	
	ЭлементДействие = Справочники.СхемыПроцессов.ОписаниеЭлементаДействие();
	ЭлементДействие.Имя = "Обработка1";
	ЭлементДействие.Наименование = НСтр("ru = 'Действие 1'");
	ЭлементДействие.Лево = 20;
	ЭлементДействие.Верх = 80;
	ЭлементДействие.ИмяПоследователя = "Обработка2";
	ОписаниеСхемы.Добавить(ЭлементДействие);
	
	ЭлементДействие = Справочники.СхемыПроцессов.ОписаниеЭлементаДействие();
	ЭлементДействие.Имя = "Обработка2";
	ЭлементДействие.Наименование = НСтр("ru = 'Действие 2'");
	ЭлементДействие.Лево = 20;
	ЭлементДействие.Верх = 160;
	ЭлементДействие.ИмяПоследователя = "Завершение";
	ОписаниеСхемы.Добавить(ЭлементДействие);
	
	ЭлементЗавершение = Справочники.СхемыПроцессов.ОписаниеЭлементаЗавершение();
	ЭлементЗавершение.Лево = 60;
	ЭлементЗавершение.Верх = 240;
	ОписаниеСхемы.Добавить(ЭлементЗавершение);
	
	ДанныхСхемыПроцесса = 
		Справочники.СхемыПроцессов.ДанныеСхемыПоОписаниюЭлементов(ОписаниеСхемы);
	
	Возврат ДанныхСхемыПроцесса;
	
КонецФункции

// Возвращает таблицу предшественников элементов по схеме.
// 
// Параметры:
//  ДанныеСхемы - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса 
// 	
// Возвращаемое значение:
//  ТаблицаЗначений:
//    * Имя - Строка
//    * ИмяПредшественника - Строка
//    * РезультатУсловияПерехода - см. РезультатУсловияПереходаСтрокой
//    * ЭтоДействие - Булево
// 	
Функция ПредшественникиЭлементовПоДаннымСхемы(ДанныеСхемы) Экспорт
	
	Предшественники = Новый ТаблицаЗначений;
	Предшественники.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	Предшественники.Колонки.Добавить("ИмяПредшественника", Новый ОписаниеТипов("Строка"));
	Предшественники.Колонки.Добавить("ЭтоДействие", Новый ОписаниеТипов("Булево"));
	
	Предшественники.Колонки.Добавить(
		"РезультатУсловияПерехода", Новый ОписаниеТипов("Строка"));
	
	Предшественники.Индексы.Добавить("ИмяПредшественника");
	Предшественники.Индексы.Добавить("ЭтоДействие");
	Предшественники.Индексы.Добавить("ИмяПредшественника, РезультатУсловияПерехода");

	Для Каждого ЭлементСхемы Из ДанныеСхемы.Схема.ЭлементыГрафическойСхемы Цикл
		
		ТипЭлемента = ТипЗнч(ЭлементСхемы);
		Если ТипЭлемента <> Тип("ЭлементГрафическойСхемыСоединительнаяЛиния") Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаТаблицы = Предшественники.Добавить();
		
		Если ЭлементСхемы.НачалоЭлемент <> Неопределено Тогда
			СтрокаТаблицы.ИмяПредшественника = ЭлементСхемы.НачалоЭлемент.Имя;
		КонецЕсли;
		
		ОтметитьДействие = ТипЗнч(ЭлементСхемы.КонецЭлемент) = Тип("ЭлементГрафическойСхемыОбработка");
		Если ЭлементСхемы.КонецЭлемент <> Неопределено Тогда
			СтрокаТаблицы.Имя = ЭлементСхемы.КонецЭлемент.Имя;
			Если ОтметитьДействие Тогда
				ТипЭлемента = ДанныеСхемы.Настройки.ТипыЭлементов[СтрокаТаблицы.Имя];
				СтрокаТаблицы.ЭтоДействие = СхемыПроцессовКлиентСервер.ЭтоДействиеСхемы(ТипЭлемента)
					Или СхемыПроцессовКлиентСервер.ЭтоВложенныйПроцессСхемы(ТипЭлемента);
			КонецЕсли;
		КонецЕсли;
		
		СтрокаТаблицы.РезультатУсловияПерехода = РезультатУсловияПереходаСтрокой(
			ДанныеСхемы.Настройки.СоединительныеЛинииУсловий[ЭлементСхемы.Имя]);
		
	КонецЦикла;
	
	Возврат Предшественники;
	
КонецФункции

// Возвращает таблицу предшественников элементов по схеме.
// 
// Параметры:
// 	ДанныеСхемы - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
// 	ПутиСхемы - см. ПутиСхемыПроцесса
// 	ИзКэша - Булево - Истина, если получаем данные из РС "ПредшественникиДействийПоПутямСхемыПроцесса"
// 	ИдентификаторОбъекта - Строка - Уникальный идентификатор владельца схемы, процесса или шаблона
// 	ДействияВыделены - Булево - Истина, если пути, состоящие только из действий и вложенных процессов сформированы
// 	
// Возвращаемое значение:
//  см. СрокиИсполненияПроцессов.ПустаяТаблицаПредшественников
// 	
Функция ПредшественникиДействийПоПутямСхемы(ДанныеСхемы, ПутиСхемы, ИзКэша = Ложь, ИдентификаторОбъекта = "", 
		ДействияВыделены = Ложь) Экспорт
	
	Если ИзКэша Тогда
		Возврат РегистрыСведений.ПредшественникиДействийПоПутямСхемыПроцесса.ПредшественникиДействийПоПутямСхемы(
			ДанныеСхемы, ИдентификаторОбъекта);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ИдентификаторОбъекта) Тогда
		ИдентификаторОбъекта = ИдентификаторВладельцаСхемыСтрокой(ДанныеСхемы);
	КонецЕсли;
	
	Предшественники = СрокиИсполненияПроцессов.ПустаяТаблицаПредшественников();
	СрокиИсполненияПроцессовКОРП.ВыделитьДействияЗаполнитьТаблицуПредшественников(Предшественники, ДанныеСхемы,
		ПутиСхемы, ИдентификаторОбъекта, ДействияВыделены);

	Возврат Предшественники;
	
КонецФункции

// Возвращает возможные пути схемы процесса по таблице предшественников,
// исключая циклы.
//
// Параметры:
//  ДанныеСхемы см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ИзКэша - Булево - Истина, если получаем данные из РегистрыСведений.ДанныеСхемыПроцесса
//  ИмяПервогоЭлемента - Строка - имя первого элемента в пути (старт).
//  Предшественники - см. ПредшественникиЭлементовПоДаннымСхемы
//
// Возвращаемое значение:
//  Массив Из Строка - список путей, каждый путь это массив имен элементов в этом пути.
//
Функция ПутиСхемыПроцесса(ДанныеСхемы, ИзКэша = Истина, Знач ИмяПервогоЭлемента = "",
		Знач Предшественники = Неопределено) Экспорт
	
	ВсеПути = Новый Массив;
	Если НЕ ДанныеСхемы.ПутиИзменены И ИзКэша Тогда
		ВсеПути = РегистрыСведений.ДанныеСхемыПроцесса.ВсеПутиСхемы(ДанныеСхемы.Ссылка);
	КонецЕсли;
	
	Если ВсеПути.Количество() > 0 Тогда
		Возврат ВсеПути;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ИмяПервогоЭлемента) Тогда
		ИмяПервогоЭлемента = СхемыПроцессовКлиентСервер.ИмяЭлементаСтартаСхемы(ДанныеСхемы);
	КонецЕсли;	
	
	Если Предшественники = Неопределено Тогда
		Предшественники = ПредшественникиЭлементовПоДаннымСхемы(ДанныеСхемы);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИмяПервогоЭлемента) Тогда
		// Добавим первый путь в массив всех путей.
		ВсеПути.Добавить(Новый Массив);
		ДобавитьПоследователейЭлементаСхемыВПуть(ВсеПути, 0, Предшественники, ИмяПервогоЭлемента);
	КонецЕсли;
	
	Возврат ВсеПути;
	
КонецФункции

// Выделяет в путях схемы последовательности элементов по отбору(см. параметр "Элементы"),
// удаляя лишние элементы.
//
// Параметры:
//  Пути - см. ПутиСхемыПроцесса
//  Элементы - Соответствие Из КлючИЗначение - соответствие элементов для отбора:
//   * Ключ - Строка - ИмяЭлемента
//   * Значение - Булево
//
Процедура ВыделитьПоследовательностиЭлементовВПутях(Пути, Элементы) Экспорт
	
	// Обойдем все пути и удалим все элементы типы которых отсутствуют в ТипыЭлементов.
	// Если в пути не остается элементов, то его тоже удаляем.
	ИндексПути = Пути.Количество() - 1;
	Пока ИндексПути >= 0 Цикл
		
		Путь = Пути[ИндексПути];
		
		ИндексЭлемента = Путь.Количество() - 1;
		
		Пока ИндексЭлемента >= 0 Цикл
			
			ИмяЭлемента = Путь[ИндексЭлемента];
					
			Если Элементы[ИмяЭлемента] = Неопределено Тогда
				Путь.Удалить(ИндексЭлемента);
			КонецЕсли;
			
			ИндексЭлемента = ИндексЭлемента - 1;
		КонецЦикла;
		
		Если Путь.Количество() = 0 Тогда
			Пути.Удалить(ИндексПути);
		КонецЕсли;
		
		ИндексПути = ИндексПути - 1;
		
	КонецЦикла;
	
КонецПроцедуры

// Выделяет элементы-действия в путях схемы.
// 
// Параметры:
//  Пути см. ПутиСхемыПроцесса
//  ДанныеСхемы см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//
Процедура ВыделитьДействияВПутяхСхемы(Пути, ДанныеСхемы) Экспорт
	
	ЭлементыДействия = Новый Соответствие;
	ПредшественникиЭлементов = ПредшественникиЭлементовПоДаннымСхемы(ДанныеСхемы);
	
	Отбор = Новый Структура("ЭтоДействие", Истина);
	СтрокиПредшественникиДействий = ПредшественникиЭлементов.НайтиСтроки(Отбор);
	Для Каждого СтрТЗ Из СтрокиПредшественникиДействий Цикл
		ЭлементыДействия[СтрТЗ.Имя] = СтрТЗ.ЭтоДействие;
	КонецЦикла;
	
	ВыделитьПоследовательностиЭлементовВПутях(Пути, ЭлементыДействия);
	
КонецПроцедуры

// Возвращает массив путей схемы, в котором содержаться только действия исполнителей.
// 
// Параметры:
//  Пути см. ПутиСхемыПроцесса
//  ДанныеСхемы см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//
//Возвращаемое значение:
// см. ПутиСхемыПроцесса
//
Функция ДействияВПутяхСхемы(Пути, ДанныеСхемы) Экспорт
	
	ЭлементыДействия = Новый Соответствие;
	ПредшественникиЭлементов = ПредшественникиЭлементовПоДаннымСхемы(ДанныеСхемы);
	
	Отбор = Новый Структура("ЭтоДействие", Истина);
	СтрокиПредшественникиДействий = ПредшественникиЭлементов.НайтиСтроки(Отбор);
	Для Каждого СтрТЗ Из СтрокиПредшественникиДействий Цикл
		ЭлементыДействия[СтрТЗ.Имя] = СтрТЗ.ЭтоДействие;
	КонецЦикла;
	
	ПутиДействий = Новый Массив;
		
	// Обойдем все пути и отберем все элементы типы которых присутствуют в ЭлементыДействия.
	Для Каждого Путь Из Пути Цикл
		
		НовыйПуть = Новый Массив;
		
		Для Каждого ЭлементПути Из Путь Цикл
			Если ЭлементыДействия[ЭлементПути] = Истина Тогда
				НовыйПуть.Добавить(ЭлементПути);
			КонецЕсли;
		КонецЦикла;
		
		Если НовыйПуть.Количество() <> 0 Тогда
			ПутиДействий.Добавить(НовыйПуть);
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат ПутиДействий;
	
КонецФункции	

// Возвращает условие перехода от элемента к элементу в виде строки.
// 
// Параметры:
// 	РезультатУсловия - Булево
// 					 - Неопределено
// 	
// Возвращаемое значение:
// 	Строка - одно из значений: "ПоложительныйРезультат", "ОтрицательныйРезультат", "НетРезультата"
//
Функция РезультатУсловияПереходаСтрокой(РезультатУсловия) Экспорт
	
	Если РезультатУсловия = Истина Тогда
		Возврат "ПоложительныйРезультат";
	ИначеЕсли РезультатУсловия = Ложь Тогда
		Возврат "ОтрицательныйРезультат";
	Иначе
		Возврат "НетРезультата";
	КонецЕсли;
	
КонецФункции

// Возвращает владельца схемы обработки или процесса.
// 
// Параметры:
//  СхемаСсылка - СправочникСсылка.СхемыПроцессов
// 
// Возвращаемое значение:
//  Неопределено, 
//  СправочникСсылка.ШаблоныКомплексныхБизнесПроцессов, БизнесПроцессСсылка.КомплексныйПроцесс,
//  СправочникСсылка.ОбработкиОбъектов, СправочникСсылка.НастройкиОбработкиВидовОбъектов - Владелец схемы
//
Функция ВладелецСхемы(СхемаСсылка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ПараметрыСхемДляКомплексныхПроцессов.ВладелецСхемы
		|ИЗ
		|	Справочник.ПараметрыСхемДляКомплексныхПроцессов КАК ПараметрыСхемДляКомплексныхПроцессов
		|ГДЕ
		|	ПараметрыСхемДляКомплексныхПроцессов.Схема = &Схема
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	ПараметрыСхемДляОбработокОбъектов.ВладелецСхемы
		|ИЗ
		|	Справочник.ПараметрыСхемДляОбработокОбъектов КАК ПараметрыСхемДляОбработокОбъектов
		|ГДЕ
		|	ПараметрыСхемДляОбработокОбъектов.Схема = &Схема";
	
	Запрос.УстановитьПараметр("Схема", СхемаСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.ВладелецСхемы;
	
КонецФункции

// Идентификатор владельца схемы строкой.
// 
// Параметры:
//  ДанныеСхемы - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ВладелецСхемы - СправочникСсылка.ШаблоныКомплексныхБизнесПроцессов
//  			  - БизнесПроцессСсылка.КомплексныйПроцесс
//  			  - Неопределено - Владелец схемы
// 
// Возвращаемое значение:
//  Строка - Идентификатор владельца схемы строкой
//
Функция ИдентификаторВладельцаСхемыСтрокой(ДанныеСхемы, ВладелецСхемы = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(ВладелецСхемы) Тогда
		ВладелецСхемы = ВладелецСхемы(ДанныеСхемы.Ссылка);
	КонецЕсли;
	
	ИдентификаторСсылки = Новый УникальныйИдентификатор;
	Если ТипЗнч(ВладелецСхемы) = Тип("БизнесПроцессСсылка.КомплексныйПроцесс")
		Или ТипЗнч(ВладелецСхемы) = Тип("СправочникСсылка.ШаблоныКомплексныхБизнесПроцессов") Тогда
			ИдентификаторСсылки = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ВладелецСхемы, "ИдентификаторСсылки");
	КонецЕсли;
	
	Возврат СтрШаблон("%1_", ИдентификаторСсылки);
	
КонецФункции

#Область ОбновленияКэширующихДанныхСхемы

// Рассчитывает кэширующие данные схемы
// 
// Параметры:
//  ДанныеСхемы - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ДанныеПараметровСхемы - см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураДанныхПараметровСхемы
// 
// Возвращаемое значение:
//  см. НовыйРезультатРасчетаКэширующихДанныхСхемы
//  
Функция РезультатРасчетаКэширующихДанныхСхемы(ДанныеСхемы, ДанныеПараметровСхемы) Экспорт
	
	РезультатРасчета = НовыйРезультатРасчетаКэширующихДанныхСхемы();
	ВладелецСхемы = ?(ДанныеПараметровСхемы.Количество() = 0, Неопределено, ДанныеПараметровСхемы.ВладелецСхемы);
	Если ДанныеСхемы.ПутиИзменены Тогда
		РезультатРасчета.ВсеПути = ПутиСхемыПроцесса(ДанныеСхемы, Ложь);
		РезультатРасчета.Записывать = Истина;
		РезультатРасчета.ИменаДанныхДляЗаписи = "ВсеПути";
		РассчитатьТаблицуПредшественниковДействийСхемы(ДанныеСхемы, РезультатРасчета.ВсеПути, РезультатРасчета,
			ВладелецСхемы);		
		Если ДанныеПараметровСхемы.Количество() <> 0 Тогда
			РассчитатьПорядокСортировкиНастроек(ДанныеПараметровСхемы, РезультатРасчета.ВсеПути, РезультатРасчета);
		КонецЕсли;	
	КонецЕсли;
	
	РассчитатьДлительностьСхемы(ДанныеСхемы, ВладелецСхемы, РезультатРасчета);
	
	Возврат РезультатРасчета;
		
КонецФункции

// Записывает кэш в базу.
// 
// Параметры:
//  ДанныеСхемы - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ИменаОбновляемыхДанных - Строка
//  ТаблицаПредшественников - Неопределено
//  						- см. СрокиИсполненияПроцессов.ПустаяТаблицаПредшественников
//	ВыполняетсяОбновлениеИБ - Булево
//
Процедура ЗаписатьКэшСхемы(ДанныеСхемы, ИменаОбновляемыхДанных, ТаблицаПредшественников = Неопределено,
		ВыполняетсяОбновлениеИБ = Ложь) Экспорт

	РегистрыСведений.ДанныеСхемыПроцесса.ЗаписатьДанныеСхемы(ДанныеСхемы, ИменаОбновляемыхДанных,
		ВыполняетсяОбновлениеИБ);
	Если ДанныеСхемы.ПутиИзменены И ТаблицаПредшественников <> Неопределено Тогда
		РегистрыСведений.ПредшественникиДействийПоПутямСхемыПроцесса.ЗаписатьДанныеПредшественников(ДанныеСхемы.Ссылка,
			ТаблицаПредшественников, ВыполняетсяОбновлениеИБ);
	КонецЕсли;

КонецПроцедуры

#Область ФоновоеОбновлениеКэширующихДанныхСхемы

// Параметры фонового обновления кэширующих данных схемы(выполнения длительной операции).
// 
// Параметры:
//  ИдентификаторФормы - УникальныйИдентификатор
//  ДанныеСхемы - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ДанныеПараметровСхемы 	- Неопределено
//  						- см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураДанныхПараметровСхемы
//  ОжидатьЗавершения - Булево						
// 
// Возвращаемое значение:
//  см. ДлительныеОперации.ВыполнитьФункцию
//
Функция ЗапускФоновогоРасчетаКэширующихДанныхСхемы(ИдентификаторФормы, ДанныеСхемы, ДанныеПараметровСхемы,
		ОжидатьЗавершения = Истина) Экспорт

	ВыполняемыйМетод = "СхемыПроцессовСервер.РезультатРасчетаКэширующихДанныхСхемы";
	
	ПараметрыВыполнения 	= ДлительныеОперации.ПараметрыВыполненияВФоне(ИдентификаторФормы);
	ПараметрыВыполнения.НаименованиеФоновогоЗадания = НСтр("ru = 'Расчет кэширующих данных схемы.'");
	ПараметрыВыполнения.ЗапуститьВФоне = Истина;
	ПараметрыВыполнения.Вставить("ИдентификаторФормы", ИдентификаторФормы);
	Если Не ОжидатьЗавершения Тогда
		ПараметрыВыполнения.ОжидатьЗавершение = 0;
	КонецЕсли;	
	
	Возврат ДлительныеОперации.ВыполнитьФункцию(ПараметрыВыполнения, ВыполняемыйМетод, ДанныеСхемы,
		ДанныеПараметровСхемы);

КонецФункции

#КонецОбласти

#КонецОбласти

#КонецОбласти

#Область РаботаССхемойВФорме

// Читает схему в форму с возможность отображения/редактирования.
// В форме должны быть соответствующие реквизиты и элементы управления.
// 
// Параметры:
// 	СхемаПроцесса - СправочникСсылка.СхемыПроцессов
// 	Форма - ФормаКлиентскогоПриложения.
//
Процедура ПрочитатьСхемуВФорму(СхемаПроцесса, Форма) Экспорт

	УстановитьПривилегированныйРежим(Истина);
	
	Форма.ДанныеСхемы = СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыВФорме();
	
	Если ЗначениеЗаполнено(СхемаПроцесса) Тогда
		
		ДанныхСхемыПроцесса = Справочники.СхемыПроцессов.ДанныеСхемыПроцесса(СхемаПроцесса);
		
		Если Не ПараметрыСеанса.ЭтоМобильныйКлиент Тогда
			УстановитьГрафическуюСхемуВФорму(ДанныхСхемыПроцесса.Схема, Форма);
			УстановитьНастройкиСхемыВФорму(ДанныхСхемыПроцесса.Настройки, Форма);
		Иначе 
			УстановитьГрафическуюСхемуВФормуМК(ДанныхСхемыПроцесса.Схема, Форма);
		КонецЕсли;
				
		Форма.ДанныеСхемы.Ссылка = СхемаПроцесса;		
		Форма.ДанныеСхемы.Наименование = ДанныхСхемыПроцесса.Наименование;
		Форма.ДанныеСхемы.ВерсияДанных = ДанныхСхемыПроцесса.ВерсияДанных;
		Форма.ДанныеСхемы.ПолучатьДлительностьИзКэш = ДанныхСхемыПроцесса.ПолучатьДлительностьИзКэш;

	Иначе
		
		ДанныхСхемыПроцесса = ДанныеСхемыПоУмолчанию();
		
		Если Не ПараметрыСеанса.ЭтоМобильныйКлиент Тогда
			
			УстановитьГрафическуюСхемуВФорму(ДанныхСхемыПроцесса.Схема, Форма);
			УстановитьНастройкиСхемыВФорму(ДанныхСхемыПроцесса.Настройки, Форма);
		Иначе 
			УстановитьГрафическуюСхемуВФормуМК(ДанныхСхемыПроцесса.Схема, Форма);
		КонецЕсли;

		Форма.ДанныеСхемы.СхемаИзменена = Истина;
		
	КонецЕсли;
	
	УстановитьПоддерживаемыеТипыЭлементовСхемыВФорму(
		СхемыПроцессовКлиентСервер.ПоддерживаемыеТипыЭлементовСхемыПоУмолчанию(),
		Форма);
	
КонецПроцедуры

// Настраивает доступность редактирования схемы процесса в форме.
// 
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения
// 	Доступность - Булево
//
Процедура НастроитьДоступностьРедактированияСхемы(Форма, Доступность) Экспорт
	
	Форма.Элементы.Схема.ТолькоПросмотр = Не Доступность;
	Форма.Элементы.КомандыСхемы.Доступность = Доступность;
	Форма.Схема.ИспользоватьСетку = Доступность;
		
КонецПроцедуры

// Записывает схему процесса из формы.
// 
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения
//
Процедура ЗаписатьСхемуИзФормы(Форма) Экспорт

	УстановитьПривилегированныйРежим(Истина);
	
	Если Не Форма.ДанныеСхемы.СхемаИзменена Тогда
		Возврат;
	КонецЕсли;
	
	ДанныеСхемыПроцесса = СхемыПроцессовКлиентСервер.ДанныеСхемыПроцессаИзФормы(Форма);
			
	РезультатЗаписи = Справочники.СхемыПроцессов.ЗаписатьДанныеСхемыПроцесса(
		Форма.ДанныеСхемы.Ссылка, ДанныеСхемыПроцесса);
	
	Если Не ЗначениеЗаполнено(Форма.ДанныеСхемы.Ссылка) Тогда
		Форма.ДанныеСхемы.Ссылка = РезультатЗаписи.СхемаПроцесса;
	КонецЕсли;
	 
	Форма.ДанныеСхемы.ВерсияДанных = РезультатЗаписи.ВерсияДанных;
	
	Форма.ДанныеСхемы.СхемаИзменена = Ложь;
	
КонецПроцедуры

// Создает копию данных схемы из формы и возвращает ее в виде структуры.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - карточка со схемой.
// 
// Возвращаемое значение:
//  Структура
//   * Схема - ХранилищеЗначения - графическая схема в форме упакованная в хранилище значения.
//   * ДанныеСхемы - ХранилищеЗначения - данные схемы в форме.
//
Функция СкопироватьДанныеСхемыПроцессыИзФормы(Форма) Экспорт
		
	КопияДанныхСхемы = Новый Структура;
	
	КопияДанныхСхемы.Вставить("Схема", Новый ХранилищеЗначения(Форма.Схема));
	КопияДанныхСхемы.Вставить("ДанныеСхемы", Новый ХранилищеЗначения(Форма.ДанныеСхемы));
	
	Возврат КопияДанныхСхемы;
	
КонецФункции

// Восстановить схему процесса в форме из копиданных схемы.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - карточка со схемой.
//  КопияДанныхСхемы - Структура - см. СкопироватьДанныеСхемыПроцессыИзФормы
//
Процедура ВосстановитьСхемуПроцессаИзКопииДанных(Форма, КопияДанныхСхемы) Экспорт
	
	Форма.ДанныеСхемы = КопияДанныхСхемы.ДанныеСхемы.Получить();
	Форма.Схема = КопияДанныхСхемы.Схема.Получить();
	
КонецПроцедуры

// Устанавливает графическую схему в форме.
// 
// Параметры:
// 	Схема - ГрафическаяСхема
// 	Форма - ФормаКлиентскогоПриложения 
//
Процедура УстановитьГрафическуюСхемуВФорму(Схема, Форма) Экспорт
	
	Форма.Схема = Схема;
	Форма.ДанныеСхемы.СхемаИзменена = Истина;
					
КонецПроцедуры

// Устанавливает картинку графической схемы в форму на мобильном.
// 
// Параметры:
// 	Схема - ГрафическаяСхема
// 	Форма - ФормаКлиентскогоПриложения 
//
Процедура УстановитьГрафическуюСхемуВФормуМК(Схема, Форма) Экспорт
	
	Форма.Схема = ПолучитьКартинкуСхемы(Схема);
	Форма.ДанныеСхемы.СхемаИзменена = Истина;
					
КонецПроцедуры

// Возвращает адрес картинки во временном хранилище грфической схемы.
// 
// Возвращаемое значение:
// 	Строка - адрес картинки во временном хранилище
//
Функция ПолучитьКартинкуСхемы(Схема)
	
		АдресКартинки = ПоместитьВоВременноеХранилище(Схема.ПолучитьКартинку());
	
	Возврат АдресКартинки;
	
КонецФункции

// Устанавливает настройки схемы в форму.
//
// Параметры:
// 	Настройки - Структура - см. СхемыПроцессовКлиентСервер.СтруктураНастроекСхемыПроцесса
// 	Форма - ФормаКлиентскогоПриложения
//
Процедура УстановитьНастройкиСхемыВФорму(Настройки, Форма) Экспорт
	
	Форма.ДанныеСхемы.НастройкиСхемы = Настройки;
	Форма.ДанныеСхемы.СхемаИзменена = Истина;
	
КонецПроцедуры

// Устанавливает поддерживаемые типы элементов схемы в форму.
// 
// Параметры:
//  ТипыЭлементов - Соответствие
//   * Ключ - ПеречислениеСсылка.ТипыЭлементовСхемПроцессов
//   * Значение - Булево - всегда Истина.
//  Форма - ФормаКлиентскогоПриложения
//
Процедура УстановитьПоддерживаемыеТипыЭлементовСхемыВФорму(ТипыЭлементов, Форма) Экспорт
	
	Форма.ДанныеСхемы.ПоддерживаемыеТипыЭлементов = ТипыЭлементов;
	
КонецПроцедуры

// Проверить корректность схемы в форме.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения
//
Процедура ПроверитьКорректностьСхемыВФорме(Форма) Экспорт
	
	Форма.ДанныеСхемы.РезультатПроверкиСхемы = СхемаКорректна(Форма.Схема);
	
КонецПроцедуры

// Проверяет, что пути схемы были изменены в форме
//
// Параметры:
//  НачальныеПредшественники - см. СхемыПроцессовСервер.ПредшественникиЭлементовПоДаннымСхемы
//  ДанныеСхемы - см. СхемыПроцессовКлиентСервер.ДанныеСхемыПроцессаИзФормы
//
// Возвращаемое значение:
//  Булево
//
Функция ПутиСхемыИзменены(НачальныеПредшественники, ДанныеСхемы) Экспорт
	
	// В мобильном клиенте схема недоступна
	Если ОбщегоНазначения.ЭтоМобильныйКлиент() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ТекущиеПредшественники = ПредшественникиЭлементовПоДаннымСхемы(ДанныеСхемы);
	Если ОбщегоНазначения.КоллекцииИдентичны(ТекущиеПредшественники, НачальныеПредшественники) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции	

// Заполняет таблицу элементов последователей и предшественников при открытии формы
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения
//
Процедура ЗаполнитьНачальныхПредшественников(Форма) Экспорт
	
	ДанныеСхемыПроцесса = СхемыПроцессовКлиентСервер.ДанныеСхемыПроцессаИзФормы(Форма);
	ТЗ_НачальныеПредшественники = ПредшественникиЭлементовПоДаннымСхемы(ДанныеСхемыПроцесса);
	ЗначениеВДанныеФормы(ТЗ_НачальныеПредшественники, Форма.НачальныеПредшественники);
	
КонецПроцедуры

// Возвращает сроки элементов схемы.
// 
// Параметры:
//  ДанныеПараметровСхемы - см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураДанныхПараметровСхемы
//  ВладелецСхемы - СправочникСсылка.ШаблоныКомплексныхБизнесПроцессов
//  			  - БизнесПроцессСсылка.КомплексныйПроцесс
// 
// Возвращаемое значение:
//	см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураСроковЭлементовСхемы
//  
Функция СрокиЭлементовПоДаннымСхемы(ДанныеПараметровСхемы, ВладелецСхемы) Экспорт
	
	СрокиЭлементов = РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураСроковЭлементовСхемы();
	ЗаполнитьСрокиЭлементовСхемы(ДанныеПараметровСхемы, ВладелецСхемы, СрокиЭлементов);
	
	Возврат СрокиЭлементов;
	
КонецФункции

#КонецОбласти

// Возвращает доступность настройки скриптов в схемах процессов.
// 
// Возвращаемое значение:
// 	Булево
//
Функция ДоступнаНастройкаСкриптовВСхемахПроцессов() Экспорт
	
	Возврат РольДоступна("ДобавлениеИзменениеНСИ") Или РольДоступна("ПолныеПрава");
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроверкаКорректностиСхемы

// Возвращает структуру для проверки схемы.
// 
// Возвращаемое значение:
//  Структура - Структура для проверки схемы:
//   * ЭлементыСхемы - Соответствие из КлючИЗначение
//   * СоединительныеЛинииСхемы - Соответствие из КлючИЗначение 
//   * Слияния - Массив из Строка
//   * Разделения - Массив из Строка
//   * ЭлементСтарта - Строка
//   * ЭлементЗавершения - Строка
//   * ГрафическаяСхема - Неопределено, ГрафическаяСхема, Структура
//   * ЗавершенныеПути - Массив из Строка
//   * Циклы - Массив Из Строка
//   * ПроверкаЗавершена - Булево
//   * СложнаяКарта - Булево
//   * НетЗавершенныхПутей - Булево
//   * ЕстьЦиклыБезБлоковВыполнения - Булево
//   * КоличествоЭлементовСтарта - Число
//   * КоличествоЭлементовЗавершения - Число
//   * ИмяНедопустимогоЭлемента - Строка
//   * ИмяНеприсоединеннойСоединительнойЛинии - Строка
//   * ИмяЭлементаБезВходящихСоединительныхЛиний - Строка
//   * ИмяЭлементаОбрыва - Строка
//   * ИмяЭлементаВКоторыйНевозможноПопасть - Строка
//   * ЦиклИзКоторогоНедоступноЗавершение - Строка
//   * РазделениеСОднойИсходящейЛинией - Строка
//   * РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент - Строка
//   * СлияниеСОднойВходящейЛинией - Строка
//   * СлияниеБезРазделения - Строка
//   * СлияниеСразуПослеРазделения - Строка
//   * ЭлементПересеченияРазделений - Строка
//   * ЗавершениеСразуПослеРазделения - Строка
//
Функция СтруктураДляПроверкиСхемы()
	
	СтруктураДляПроверки = Новый Структура;
	
	// Кэш элементов схемы.
	СтруктураДляПроверки.Вставить("ЭлементыСхемы", Новый Соответствие);
	СтруктураДляПроверки.Вставить("СоединительныеЛинииСхемы", Новый Соответствие);
	СтруктураДляПроверки.Вставить("Слияния", Новый Массив);
	СтруктураДляПроверки.Вставить("Разделения", Новый Массив);
	СтруктураДляПроверки.Вставить("ЭлементСтарта", "");
	СтруктураДляПроверки.Вставить("ЭлементЗавершения", "");
	СтруктураДляПроверки.Вставить("ГрафическаяСхема", Неопределено);
	
	// Пути схемы.
	СтруктураДляПроверки.Вставить("ЗавершенныеПути", Новый Массив);
	СтруктураДляПроверки.Вставить("Циклы", Новый Массив);
		
	// Результат проверки.
	СтруктураДляПроверки.Вставить("ПроверкаЗавершена", Ложь);
	СтруктураДляПроверки.Вставить("СложнаяКарта", Ложь);
	СтруктураДляПроверки.Вставить("НетЗавершенныхПутей", Ложь);
	СтруктураДляПроверки.Вставить("ЕстьЦиклыБезБлоковВыполнения", Ложь);
	СтруктураДляПроверки.Вставить("КоличествоЭлементовСтарта", 0);
	СтруктураДляПроверки.Вставить("КоличествоЭлементовЗавершения", 0);
	СтруктураДляПроверки.Вставить("ИмяНедопустимогоЭлемента", "");
	СтруктураДляПроверки.Вставить("ИмяНеприсоединеннойСоединительнойЛинии", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаБезВходящихСоединительныхЛиний", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаОбрыва", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаВКоторыйНевозможноПопасть", "");
	СтруктураДляПроверки.Вставить("ЦиклИзКоторогоНедоступноЗавершение", "");
	СтруктураДляПроверки.Вставить("РазделениеСОднойИсходящейЛинией", "");
	СтруктураДляПроверки.Вставить("РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент", "");
	СтруктураДляПроверки.Вставить("СлияниеСОднойВходящейЛинией", "");
	СтруктураДляПроверки.Вставить("СлияниеБезРазделения", "");
	СтруктураДляПроверки.Вставить("СлияниеСразуПослеРазделения", "");
	СтруктураДляПроверки.Вставить("ЭлементПересеченияРазделений", "");
	СтруктураДляПроверки.Вставить("ЗавершениеСразуПослеРазделения", "");
	
	Возврат СтруктураДляПроверки;
	
КонецФункции

// Заполняет кэш элементов схемы в структуре для проверки.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//  Схема - ГрафическаяСхема
//
Процедура ЗаполнитьКэшЭлементовВСтруктуреДляПроверки(СтруктураДляПроверки, Схема)
	
	СтруктураДляПроверки.ГрафическаяСхема = Схема;
	
	Если СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы.Количество() = 0 Тогда
		СтруктураДляПроверки.ПроверкаЗавершена = Истина;
		Возврат;
	КонецЕсли;
	
	НеПоддерживаемыеЭлементы = СхемыПроцессовКлиентСервер.НеПоддерживаемыеЭлементыГрафическойСхемы(); 
	
	// Заполним соотвествия ЭлементыГрафическойСхемы и СоединительныеЛинииГрафическойСхемы
	// и выполним возможные проверки.
	// В случаи ошибок заполнения, прерываем заполнение.
	Для Каждого Элемент Из СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы Цикл
		
		ТипЭлемента = ТипЗнч(Элемент);
		
		// Пропуская декоративные линии и декорации.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыДекоративнаяЛиния")
			Или ТипЭлемента = Тип("ЭлементГрафическойСхемыДекорация") Тогда
			
			Продолжить;
		КонецЕсли;
		
		// Прерываем проверку, если схема содержит недопустимые элементы.
		Если НеПоддерживаемыеЭлементы[ТипЭлемента] = Истина Тогда
			СтруктураДляПроверки.ИмяНедопустимогоЭлемента = Элемент.Имя;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Возврат;
		КонецЕсли;
		
		// Считаем количество элементов старта и если их больше 1го, то прерываем проверку.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСтарт") Тогда
			СтруктураДляПроверки.КоличествоЭлементовСтарта = 
				СтруктураДляПроверки.КоличествоЭлементовСтарта + 1;
			Если СтруктураДляПроверки.КоличествоЭлементовСтарта > 1 Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			СтруктураДляПроверки.ЭлементСтарта = Элемент.Имя;
		КонецЕсли;
		
		// Считаем количество элементов завершения и если их больше 1го, то прерываем проверку.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыЗавершение") Тогда
			СтруктураДляПроверки.КоличествоЭлементовЗавершения =
				СтруктураДляПроверки.КоличествоЭлементовЗавершения + 1;
			Если СтруктураДляПроверки.КоличествоЭлементовЗавершения > 1 Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			СтруктураДляПроверки.ЭлементЗавершения = Элемент.Имя;
		КонецЕсли;
		
		// Помещаем все элементы в соответствие ЭлементыГрафическойСхемы,
		// а соединительные линии в СоединительныеЛинииГрафическойСхемы
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСоединительнаяЛиния") Тогда
			
			НачалоЭлемент = Элемент.НачалоЭлемент;
			КонецЭлемент = Элемент.КонецЭлемент;
			
			// Если линия не присоединена, то прерываем проверку.
			Если НачалоЭлемент = Неопределено Или КонецЭлемент = Неопределено Тогда
				СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии = Элемент.Имя;
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			
			СоединительнаяЛинияГрафическойСхемы = СоединительнаяЛинияГрафическойСхемы();
			СоединительнаяЛинияГрафическойСхемы.Предшественник = НачалоЭлемент.Имя;
			СоединительнаяЛинияГрафическойСхемы.Последователь = КонецЭлемент.Имя;
			
			СтруктураДляПроверки.СоединительныеЛинииСхемы.Вставить(
				Элемент.Имя,
				СоединительнаяЛинияГрафическойСхемы);
		Иначе
			
			ЭлементГрафическойСхемы = ЭлементГрафическойСхемы();
			ЭлементГрафическойСхемы.Тип = ТипЭлемента;
			
			СтруктураДляПроверки.ЭлементыСхемы.Вставить(
				Элемент.Имя,
				ЭлементГрафическойСхемы);
		КонецЕсли;
		
		// Поместим имена сляний и разделение в отдельные массивы структуры для проверки.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСлияние") Тогда
			СтруктураДляПроверки.Слияния.Добавить(Элемент.Имя);
		ИначеЕсли ТипЭлемента = Тип("ЭлементГрафическойСхемыРазделение") Тогда
			СтруктураДляПроверки.Разделения.Добавить(Элемент.Имя);
		КонецЕсли;
		
	КонецЦикла;
	
	// Заполним предшественников и последователей элементов в соотвествии ЭлементыСхемы
	// по соединительными линиям (СоединительныеЛинииСхемы)
	Для Каждого Линия Из СтруктураДляПроверки.СоединительныеЛинииСхемы Цикл
		
		ПараметрыЛинии = Линия.Значение;
		
		// Заполняем предшественников
		ЭлементСхемы = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПараметрыЛинии.Последователь);
		ЭлементСхемы.Предшественники.Добавить(ПараметрыЛинии.Предшественник);
		
		// Заполняем последователей
		ЭлементСхемы = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПараметрыЛинии.Предшественник);
		ЭлементСхемы.Последователи.Добавить(ПараметрыЛинии.Последователь);
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает структуру соединительной линии в кэше элементов структуры для проверки.
//
// Возвращаемое значение:
//  Структура
//   * Предшественник - Строка - имя предшествующего элемента.
//   * Последователь - Строка - имя последующего элемента.
//
Функция СоединительнаяЛинияГрафическойСхемы()
	
	СоединительнаяЛиния = Новый Структура;
	СоединительнаяЛиния.Вставить("Предшественник", "");
	СоединительнаяЛиния.Вставить("Последователь", "");
	
	Возврат СоединительнаяЛиния;
	
КонецФункции

// Возвращает структуру графического элемента в кэше элементов структуры для проверки.
//
// Возвращаемое значение:
//  Структура:
//   * Тип - ЭлементГрафическойСхемыДействие,
//         - ЭлементГрафическойСхемыРазделение,
//         - ЭлементГрафическойСхемыУсловие,
//         - ЭлементГрафическойСхемыЗавершение,
//         - ЭлементГрафическойСхемыСтарт,
//         - ЭлементГрафическойСхемыСлияние,
//         - ЭлементГрафическойСхемыВложенныйБизнесПроцесс,
//         - Неопределено - тип элемента графической схемы.
//   * Предшественники - Массив Из Строка - имена предшествующих элементов.
//   * Последователи - Массив Из Строка - имена последующих элементов.
//
Функция ЭлементГрафическойСхемы()
	
	ЭлементГрафическойСхемы = Новый Структура;
	ЭлементГрафическойСхемы.Вставить("Тип", Неопределено);
	ЭлементГрафическойСхемы.Вставить("Предшественники", Новый Массив);
	ЭлементГрафическойСхемы.Вставить("Последователи", Новый Массив);
	
	Возврат ЭлементГрафическойСхемы;
	
КонецФункции

// Проверяет заполнение предшественников у элементов.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьЗаполнениеПредшественниковУЭлементов(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверяем заполнение предшественников у элементов.
	// Если элемент не Старт и у него нет входящих соединительных линий - прерываем проверку.
	Для Каждого Элемент Из СтруктураДляПроверки.ЭлементыСхемы Цикл
		
		ПараметрыЭлемента = Элемент.Значение;
		
		// Пропускаем элемент Старта.
		Если ПараметрыЭлемента.Тип = Тип("ЭлементГрафическойСхемыСтарт") Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПараметрыЭлемента.Предшественники.Количество() = 0 Тогда
			СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний = Элемент.Ключ;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует список завершенных путей и циклов по схеме процесса.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//
Процедура СформироватьПутиПоСхеме(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Создадим начальный путь с одим элементом старта и поместим его в массив путей для обработки.
	Путь = Новый Массив;
	Путь.Добавить(СтруктураДляПроверки.ЭлементСтарта);
	
	ПутиВОбработке = Новый Массив;
	ПутиВОбработке.Добавить(Путь);
	
	КоличествоЭлементовИЛиний = СтруктураДляПроверки.ЭлементыСхемы.Количество()
		+ СтруктураДляПроверки.СоединительныеЛинииСхемы.Количество();
	
	// Вычислим количество циклов определения путей. Количество должно быть конечно, т.к.
	// использовать бесконечный цикл с условием выхода опасно - из за ошибки можно получить зависание программы.
	КоличествоЦикловОпределенияПути = КоличествоЭлементовИЛиний * 10;
	
	// Определим максимальное количество путей. В случае превышения прерываем проверку.
	// Нужно, чтобы не ожидать очень долго проверки сложной карты маршрута.
	МаксимальноеКоличествоПутей = КоличествоЭлементовИЛиний * 100;
	
	// Выполняем поиск всех путей
	Для НомерЦикла = 0 По КоличествоЦикловОпределенияПути Цикл
		
		НовыеПутиКОбработке = Новый Массив;
		
		Если ПутиВОбработке.Количество() >= МаксимальноеКоличествоПутей Тогда
			СтруктураДляПроверки.СложнаяКарта = Истина;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Прервать;
		КонецЕсли;
		
		// Обходим все пути в обработке.
		Для Каждого ОбрабатываемыйПуть Из ПутиВОбработке Цикл
			
			// Продвигаемся по пути схемы.
			РезультатПродвижения = ПродвинутьсяПоПутиСхемы(
				СтруктураДляПроверки, ОбрабатываемыйПуть, НовыеПутиКОбработке);
			
			// Выполняем проверку результата продвижения и помещаем путь в соответствующий список структуры для проверки.
			// В случае обрыва прерываем обработку.
			Если РезультатПродвижения = "УПутиЕстьПродолжение" Тогда
				
				НовыеПутиКОбработке.Добавить(
					ОбщегоНазначенияДокументооборотКлиентСервер.ПростаяКопияМассива(ОбрабатываемыйПуть));
				
			ИначеЕсли РезультатПродвижения = "ПутьЗавершен" Тогда
				
				СтруктураДляПроверки.ЗавершенныеПути.Добавить(ОбрабатываемыйПуть);
				
			ИначеЕсли РезультатПродвижения = "ПутьИмеетЦикл" Тогда
				
				ВыделитьЦиклВПути(ОбрабатываемыйПуть);
				СтруктураДляПроверки.Циклы.Добавить(ОбрабатываемыйПуть);
				
			ИначеЕсли РезультатПродвижения = "ПутьОборван" Тогда
				
				ПоследнийЭлемент = ПоследнийЭлементПути(ОбрабатываемыйПуть);
				СтруктураДляПроверки.ИмяЭлементаОбрыва = ПоследнийЭлемент;
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
			Прервать;
		КонецЕсли;
		
		Если НовыеПутиКОбработке.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ПутиВОбработке = НовыеПутиКОбработке;
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ЗавершенныеПути.Количество() = 0 Тогда
		СтруктураДляПроверки.НетЗавершенныхПутей = Истина;
		СтруктураДляПроверки.ПроверкаЗавершена = Истина;
	КонецЕсли;
	
КонецПроцедуры

// Продвигается по пути схемы, при определении завершенных путей и возвращает результат
// продвижения.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//  Путь - Массив Из Строка - массив из имен элементов схемы.
//  НовыеПутиКОбработке - Массив Из Строка - массив новых путей для обработки.
//
// Возвращаемое значение:
//  Строка - может принимать значения
//   * "УПутиЕстьПродолжение"
//   * "ПутьЗавершен"
//   * "ПутьИмеетЦикл"
//   * "ПутьОборван"
//
Функция ПродвинутьсяПоПутиСхемы(СтруктураДляПроверки, Путь, НовыеПутиКОбработке)
	
	ПоследнийЭлемент = ПоследнийЭлементПути(Путь);
	Последователи = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПоследнийЭлемент).Последователи;
	
	КоличествоПоследователей = Последователи.Количество();
	
	// Если у элемента нет последователей и путь не достиг элемента завершения, то это ошибка.
	Если КоличествоПоследователей = 0 Тогда
		Возврат "ПутьОборван";
	КонецЕсли;
	
	// Обходим всех последователей, кроме последнего.
	Для ИндексПоследователя = 0 По КоличествоПоследователей - 2 Цикл
		
		ЭлементПоследователь = Последователи[ИндексПоследователя];
		
		// Копируем исходный путь.
		НовыйПуть = ОбщегоНазначенияДокументооборотКлиентСервер.ПростаяКопияМассива(Путь);
		
		// Добавляем в новый путь последователя
		НовыйПуть.Добавить(ЭлементПоследователь);
		
		// Выполняем проверку и помещаем путь в соответствующий список структуры для проверки.
		Если ПутьЗавершен(СтруктураДляПроверки, НовыйПуть) Тогда
			СтруктураДляПроверки.ЗавершенныеПути.Добавить(НовыйПуть);
		ИначеЕсли ПутьИмеетЦикл(НовыйПуть) Тогда
			ВыделитьЦиклВПути(НовыйПуть);
			СтруктураДляПроверки.Циклы.Добавить(НовыйПуть);
		Иначе
			НовыеПутиКОбработке.Добавить(НовыйПуть);
		КонецЕсли;
		
	КонецЦикла;
	
	// Поместим последнего последователя в путь.
	ЭлементПоследователь = Последователи[КоличествоПоследователей - 1];
	Путь.Добавить(ЭлементПоследователь);
	
	// Выполняем проверку текущего пути и возвращаем результат.
	Если ПутьЗавершен(СтруктураДляПроверки, Путь) Тогда
		Возврат "ПутьЗавершен";
	ИначеЕсли ПутьИмеетЦикл(Путь) Тогда
		Возврат "ПутьИмеетЦикл";
	Иначе
		Возврат "УПутиЕстьПродолжение";
	КонецЕсли;
	
КонецФункции

// Возвращает последний элемент пути. Путь должен иметь не менее 1го элемента.
//
// Параметры:
//  Путь - Массив Из Строка - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Строка
//
Функция ПоследнийЭлементПути(Путь)
	
	Возврат Путь[Путь.Количество() - 1];
	
КонецФункции

// Проверяет путь на предмет достижения элемиента завершения.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//  Путь - Массив Из Строка - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Булево
//
Функция ПутьЗавершен(СтруктураДляПроверки, Путь)
	
	Результат = Ложь;
	
	ПоследнийЭлемент = ПоследнийЭлементПути(Путь);
	ТипЭлемента = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПоследнийЭлемент).Тип;
	
	Если ТипЭлемента = Тип("ЭлементГрафическойСхемыЗавершение") Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Определяет и возвращает признак наличия цикла в пути.
//
// Параметры:
//  Путь - Массив Из Строка - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Булево
//
Функция ПутьИмеетЦикл(Путь)
	
	Результат = Ложь;
	
	// Проверяем только последений элемент пути.
	ИндексПоследнегоЭлемента = Путь.Количество() - 1;
	
	ПоследнийЭлемент = Путь[ИндексПоследнегоЭлемента];
	
	ИндексЭлемента = Путь.Найти(ПоследнийЭлемент);
	
	Если ИндексЭлемента <> ИндексПоследнегоЭлемента Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Удаляет из пути все, что находится до цикла.
// Например, было так: 1-2-3-4-5-3
// Станет так: 3-4-5-3.
//
Процедура ВыделитьЦиклВПути(Путь)
	
	КоличествоЭлементов = Путь.Количество();
	
	// Получаем последнеий элемент пути
	ПоследнийЭлемент = Путь[КоличествоЭлементов - 1];
	
	// Получим индекс следующего элемента с конца.
	ИндексЭлемента = КоличествоЭлементов - 2;
	
	// Обходим путь с конца и удаляем элементы, которые не входят в цикл.
	УдалитьЭлемент = Ложь;
	Пока ИндексЭлемента >=0 Цикл
		
		// Удаляем элемент из массива
		Если УдалитьЭлемент Тогда
			Путь.Удалить(ИндексЭлемента);
			
		// Если текущий элемент равен последнему, то включаем удаление всех предыдущих.
		ИначеЕсли Путь[ИндексЭлемента] = ПоследнийЭлемент Тогда
			УдалитьЭлемент = Истина;
		КонецЕсли;
		
		ИндексЭлемента = ИндексЭлемента - 1;
	КонецЦикла;
	
КонецПроцедуры

// Проверяет зацикливание схемы.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьЗацикливаниеСхемы(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим наличие действий и вложенных процессов в циклах.
	// Если в циклах их нет, то прекращаем проверку.
	Для Каждого Путь Из СтруктураДляПроверки.Циклы Цикл
		
		ЕстьЦиклыБезБлоковВыполнения = Истина;
		
		Для Каждого Элемент Из Путь Цикл
			
			ПараметрыЭлементы = СтруктураДляПроверки.ЭлементыСхемы.Получить(Элемент);
			
			Если ПараметрыЭлементы.Тип = Тип("ЭлементГрафическойСхемыОбработка") Тогда
				
				ЕстьЦиклыБезБлоковВыполнения = Ложь;
				
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Если ЕстьЦиклыБезБлоковВыполнения Тогда
			
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.ЕстьЦиклыБезБлоковВыполнения = Истина;
			
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим наличие элементов в которые невозможно попасть.
	Для Каждого Элемент Из СтруктураДляПроверки.ЭлементыСхемы Цикл
		
		ВЭлементНевозможноПопасть = Истина;
		
		// Проверим наличие элемента в циклах
		Для Каждого Путь Из СтруктураДляПроверки.Циклы Цикл
			
			Если Путь.Найти(Элемент.Ключ) <> Неопределено Тогда
				ВЭлементНевозможноПопасть = Ложь;
			КонецЕсли;
			
			// Если элемент входит хотябы в один цикл, то прервываем проверку
			// остальных циклов.
			Если Не ВЭлементНевозможноПопасть Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если элемент входит хотябы в один цикл, то прерываем проверку текущего
		// элемента и переходим к следующему.
		Если Не ВЭлементНевозможноПопасть Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверим наличие элемента в завершенных путях.
		Для Каждого Путь Из СтруктураДляПроверки.ЗавершенныеПути Цикл
			
			Если Путь.Найти(Элемент.Ключ) <> Неопределено Тогда
				ВЭлементНевозможноПопасть = Ложь;
			КонецЕсли;
			
			// Если элемент входит хотябы в один путь, то прервываем проверку
			// остальных путей.
			Если Не ВЭлементНевозможноПопасть Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если элемент не найден ни в одном пути и ни в одном цикле, тогда
		// прекращаем проверку.
		Если ВЭлементНевозможноПопасть Тогда
			СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть = Элемент.Ключ;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим возможность достижения элемента завершения из циклов.
	
	СостоянияЗацикленныхПутей = Неопределено;
	
	// Обойдем все циклы
	Для ИндексЦикла = 0 По СтруктураДляПроверки.Циклы.Количество() - 1 Цикл
		
		ЦиклыВОбработке = Новый Массив;
		
		// Получим состояние текущего цикла.
		СостояниеЦикла = СостояниеЦикла(
			СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеЦикла <> "ИзЦиклаДоступноЗавершение" Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			
			ПредставлениеЦиклаСтрокой = "";
			ПутьЦикла = СтруктураДляПроверки.Циклы[ИндексЦикла];
			Разделитель = "";
			Для Каждого ЭлементПути Из ПутьЦикла Цикл
				ПредставлениеЦиклаСтрокой = ПредставлениеЦиклаСтрокой
					+ Разделитель
					+ Строка(ЭлементПути);
				Разделитель = " - ";
			КонецЦикла;
			
			СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение = ПредставлениеЦиклаСтрокой;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет и возвращает состояние цикла.
// Рекурсивная процедура. Рекурсивный вызов из СостояниеЦиклаПоСвязаннымЦиклам.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//  ИндексЦикла - Число - индекс цикла в СтруктураДляПроверкиСхемы.Циклы
//  ЦиклыВОбработке - Массив Из Число - массив циклов, которые находятся в обработке определения состояния.
//  СостоянияЗацикленныхПутей - Соответствие Из КлючИЗначение:
//    * Ключ - Строка - имя пути в схеме.
//    * Значение - Строка - состояние пути, соотвествуюет значению функции СостояниеЦикла
//
// Возвращаемое значение:
//  Строка - возвращается одно из 3х значений:
//   "ЦиклУжеВОбработке", "ИзЦиклаНеДоступноЗавершение", "ИзЦиклаДоступноЗавершение"
//
Функция СостояниеЦикла(СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке,
	СостоянияЗацикленныхПутей = Неопределено)
	
	Если СостоянияЗацикленныхПутей = Неопределено Тогда
		СостоянияЗацикленныхПутей = Новый Соответствие;
	КонецЕсли;
	
	СостояниеЦикла = СостоянияЗацикленныхПутей.Получить(ИндексЦикла);
	Если СостояниеЦикла <> Неопределено Тогда
		Возврат СостояниеЦикла;
	КонецЕсли;
	
	Если ЦиклыВОбработке.Найти(ИндексЦикла) <> Неопределено Тогда
		Возврат "ЦиклУжеВОбработке";
	КонецЕсли;
	
	ЦиклыВОбработке.Добавить(ИндексЦикла);
	
	СостояниеЦикла = "ИзЦиклаНеДоступноЗавершение";
	
	ЦиклПути = СтруктураДляПроверки.Циклы[ИндексЦикла];
	
	Для Каждого ЭлементЦикла Из ЦиклПути Цикл
		
		Если ЭлементСодержитсяВЗавершенномПути(СтруктураДляПроверки, ЭлементЦикла) Тогда
			СостояниеЦикла = "ИзЦиклаДоступноЗавершение";
			Прервать;
		КонецЕсли;
		
		СостояниеПоСвязаннымЦиклам = СостояниеЦиклаПоСвязаннымЦиклам(
			СтруктураДляПроверки, ЭлементЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеПоСвязаннымЦиклам = "ИзЦиклаДоступноЗавершение" Тогда
			СостояниеЦикла = СостояниеПоСвязаннымЦиклам;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	СостоянияЗацикленныхПутей.Вставить(ИндексЦикла, СостояниеЦикла);
	
	Возврат СостояниеЦикла;
	
КонецФункции

// Возвращает состояние цикла по связанным циклам.
// Вспомогательная функция, используется в СостояниеЦикла.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//  Элемент - Строка - имя элемента цикла.
//  ЦиклыВОбработке - Массив Из Число - массив индексов циклов.
//  СостоянияЗацикленныхПутей - Соответствие Из КлючИЗначение:
//    * Ключ - Строка - имя пути в схеме.
//    * Значение - Строка - состояние пути, соотвествуюет значению функции СостояниеЦикла
//
// Возвращаемое значение:
//  Строка - возвращает одно из двух значений: "ИзЦиклаДоступноЗавершение", "ИзЦиклаНеДоступноЗавершение"
//
Функция СостояниеЦиклаПоСвязаннымЦиклам(СтруктураДляПроверки, Элемент, ЦиклыВОбработке, СостоянияЗацикленныхПутей)
	
	Для ИндексЦикла = 0 По СтруктураДляПроверки.Циклы.Количество() - 1 Цикл
		
		ЦиклПути = СтруктураДляПроверки.Циклы[ИндексЦикла];
		
		Если ЦиклПути.Найти(Элемент) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СостояниеЦикла = СостояниеЦикла(
			СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеЦикла = "ИзЦиклаДоступноЗавершение" Тогда
			Возврат СостояниеЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат "ИзЦиклаНеДоступноЗавершение";
	
КонецФункции

// Определяет, содержится элемент в завершенных путях.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//  Элемент - Строка - Имя элемента схемы процесса.
//
// Возвращаемое значение:
//  Булево
//
Функция ЭлементСодержитсяВЗавершенномПути(СтруктураДляПроверки, Элемент)
	
	Для Каждого Путь Из СтруктураДляПроверки.ЗавершенныеПути Цикл	
		Если Путь.Найти(Элемент) <> Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет корректность разделений и слияний в структуре для проверки.
//
// Параметры:
//  СтруктураДляПроверки - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьКорректностьРазделенийИСлияний(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	Если СтруктураДляПроверки.Разделения.Количество() = 0 И СтруктураДляПроверки.Слияния.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Разделения = ОбщегоНазначенияДокументооборотКлиентСервер.ПростаяКопияМассива(
		СтруктураДляПроверки.Разделения);
	
	// Проверим элементы разделений на корректность последователей.
	// Последователи должны быть уникальными.
	Для Каждого Разделение Из Разделения Цикл
		
		ПараметрыРазделения = СтруктураДляПроверки.ЭлементыСхемы.Получить(Разделение);
		
		// Проверим корректность количества последователей.
		Если ПараметрыРазделения.Последователи.Количество() = 1 Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией = Разделение;
			Возврат;
		КонецЕсли;
		
		// Проверяем, чтобы последователи в текущем разделении были уникальными.
		Для Каждого Последователь1 Из ПараметрыРазделения.Последователи Цикл
			
			КоличествоВхождений = 0;
			Для Каждого Последователь2 Из ПараметрыРазделения.Последователи Цикл
				
				Если Последователь1 = Последователь2 Тогда
					КоличествоВхождений = КоличествоВхождений + 1;
				КонецЕсли;
				
				Если КоличествоВхождений > 1 Тогда
					СтруктураДляПроверки.ПроверкаЗавершена = Истина;
					СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент = Разделение;
					Возврат;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Проверяем элементы слияний на количество предшественников.
	// Предшественников должно быть более 1го.
	Для Каждого Слияние Из СтруктураДляПроверки.Слияния Цикл
		
		ПараметрыСлияния = СтруктураДляПроверки.ЭлементыСхемы.Получить(Слияние);
		
		Если ПараметрыСлияния.Предшественники.Количество() = 1 Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.СлияниеСОднойВходящейЛинией = Слияние;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
	// Объединяем завершенные пути и циклы в один массив
	ЗавершенныеПутиИЦиклы = Новый Массив;
	Для Каждого ЗавершенныйПуть Из СтруктураДляПроверки.ЗавершенныеПути Цикл
		ЗавершенныеПутиИЦиклы.Добавить(ЗавершенныйПуть);
	КонецЦикла;
	Для Каждого ЦиклПути Из СтруктураДляПроверки.Циклы Цикл
		ЗавершенныеПутиИЦиклы.Добавить(ЦиклПути);
	КонецЦикла;
	
	Для Каждого Слияние Из СтруктураДляПроверки.Слияния Цикл
		
		СвязанноеРазделение = Неопределено;
		ИндексСвязанногоРазделения = Неопределено;
		МинимальнаяДистанцияДоРазделения = 2147483647;
		
		// Найдем раздление для текущего слияния.
		Для ИндексРазделения = 0 По Разделения.Количество() - 1 Цикл
			
			Разделение = Разделения[ИндексРазделения];
			
			Если Разделение = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			СлияниеИРаздлеоениеВОдномПути = Ложь; // хоть раз попали вместе на один путь
			МаксимальнаяДистанцияДоСлияния = 0;
			СлияниеБезРазделенияВПути = Ложь;
			
			Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
				
				ИндексРазделенияВПути = Путь.Найти(Разделение);
				ИндексСлияния = Путь.Найти(Слияние);
				
				РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
				СлияниеВходитВТекущийПуть = (ИндексСлияния <> Неопределено);
				
				Если Не РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					// Пропускаем текущий путь, если в нем нет ни разделения, ни слияния.
					Продолжить;
				ИначеЕсли Не РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// Останавливаем поиск, когда в пути есть слияние и нет раздлеления.
					// Т.к. это заведом плохой путь.
					СлияниеБезРазделенияВПути = Истина;
					Прервать;
				ИначеЕсли РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// Если в пути есть и слияние и разделение.
					
					// Если раздление раположено раньше слияния, тогда определяем
					// дистанцию между ними
					Если ИндексРазделенияВПути < ИндексСлияния Тогда
						Дистанция = ИндексСлияния - ИндексРазделенияВПути;
						Если Дистанция > МаксимальнаяДистанцияДоСлияния Тогда
							МаксимальнаяДистанцияДоСлияния = Дистанция;
						КонецЕсли;
						СлияниеИРаздлеоениеВОдномПути = Истина;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Если СлияниеИРаздлеоениеВОдномПути И Не СлияниеБезРазделенияВПути
				И МаксимальнаяДистанцияДоСлияния < МинимальнаяДистанцияДоРазделения Тогда
				
				МинимальнаяДистанцияДоРазделения = МаксимальнаяДистанцияДоСлияния;
				СвязанноеРазделение = Разделение;
				ИндексСвязанногоРазделения = ИндексРазделения;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если не нашли слияния для разделения
		Если СвязанноеРазделение = Неопределено Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.СлияниеБезРазделения = Слияние;
			Возврат;
		Иначе
			
			Разделения[ИндексСвязанногоРазделения] = Неопределено;
			
			СегментыПуйтейДляРазделения = ТаблицаСегментовРазделения();
			
			Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
				
				ИндексРазделенияВПути = Путь.Найти(СвязанноеРазделение);
				ИндексСлияния = Путь.Найти(Слияние);
				
				РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
				СлияниеВходитВТекущийПуть = (ИндексСлияния <> Неопределено);
				
				Если Не РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					Продолжить;
				ИначеЕсли Не РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// ВызватьИсключение Ложь;
					Продолжить;
				ИначеЕсли РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					
					Если ИндексРазделенияВПути >= ИндексСлияния Тогда
						//ВызватьИсключение Ложь;
						Продолжить;
					ИначеЕсли ИндексРазделенияВПути < ИндексСлияния Тогда
						
						СегментПути = Неопределено;
						ИндексЭлементаСегмента = 0;
						ИндексПоследователя = ИндексРазделенияВПути + 1;
						ПоследовательРазделения = Путь[ИндексПоследователя];
						Для ИндексЭлементаПути = ИндексПоследователя По ИндексСлияния - 1 Цикл
							СегментПути = СегментыПуйтейДляРазделения.Добавить();
							СегментПути.ЭлементСегмента = Путь[ИндексЭлементаПути];
							СегментПути.ИндексЭлемента = ИндексЭлементаСегмента;
							СегментПути.ПоследовательРазделения = ПоследовательРазделения;
							ИндексЭлементаСегмента = ИндексЭлементаСегмента + 1;
						КонецЦикла;
						
						Если СегментПути = Неопределено Тогда
							СтруктураДляПроверки.ПроверкаЗавершена = Истина;
							СтруктураДляПроверки.СлияниеСразуПослеРазделения = Слияние;
							Возврат;
						КонецЕсли;
						
					КонецЕсли;
					
				ИначеЕсли РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					
					ИндексЭлементаСегмента = 0;
					ИндексПоследователя = ИндексРазделенияВПути + 1;
					ПоследовательРазделения = Путь[ИндексПоследователя];
					// Завершение не включаем
					Для ИндексЭлементаПути = ИндексПоследователя По Путь.Количество() - 2 Цикл
						СегментПути = СегментыПуйтейДляРазделения.Добавить();
						СегментПути.ЭлементСегмента = Путь[ИндексЭлементаПути];
						СегментПути.ИндексЭлемента = ИндексЭлементаСегмента;
						СегментПути.ПоследовательРазделения = ПоследовательРазделения;
						ИндексЭлементаСегмента = ИндексЭлементаСегмента + 1;
					КонецЦикла;
					
				КонецЕсли;
				
			КонецЦикла;
			
			// Теперь проверяем, что ни одна точка из одного сегмента не принадлежит другому.
			// @skip-check query-in-loop
			ПроблемныйЭлемент = ЭлементВходящийВНесколькоСегментовРазделениеСлияние(СегментыПуйтейДляРазделения);
				
			Если ПроблемныйЭлемент <> Неопределено Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				СтруктураДляПроверки.ЭлементПересеченияРазделений = ПроблемныйЭлемент;
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	СегментыПуйтейДляРазделения = ТаблицаСегментовРазделения();
	
	Для ИндексРазделения = 0 По Разделения.Количество() - 1 Цикл
		
		Разделение = Разделения[ИндексРазделения];
		
		Если Разделение = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
			
			ИндексРазделенияВПути = Путь.Найти(Разделение);
			РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
			
			Если Не РазделениеВходитВТекущийПуть Тогда
				Продолжить;
			КонецЕсли;
			
			ИндексЭлементаСегмента = 0;
			ИндексПоследователя = ИндексРазделенияВПути + 1;
			ПоследовательРазделения = Путь[ИндексПоследователя];
			// Элемент Завершение не включаем.
			Для ИндексЭлементаПути = ИндексПоследователя По Путь.Количество() - 2 Цикл
				
				ЭлементПути = Путь[ИндексЭлементаПути];
				ПараметрыЭлемента = СтруктураДляПроверки.ЭлементыСхемы.Получить(ЭлементПути);
				
				Если ПараметрыЭлемента.Тип = Тип("ЭлементГрафическойСхемыСлияние") Тогда
					Прервать;
				КонецЕсли;
				
				СегментПути = СегментыПуйтейДляРазделения.Добавить();
				СегментПути.ЭлементСегмента = ЭлементПути;
				СегментПути.ИндексЭлемента = ИндексЭлементаСегмента;
				СегментПути.ПоследовательРазделения = ПоследовательРазделения;
				ИндексЭлементаСегмента = ИндексЭлементаСегмента + 1;
			КонецЦикла;
			
		КонецЦикла;
		
		// Теперь проверяем, что ни одна точка из одного сегмента не принадлежит другому.
		// @skip-check query-in-loop
		ПроблемныйЭлемент = ЭлементВходящийВНесколькоСегментовРазделениеСлияние(СегментыПуйтейДляРазделения);
			
		Если ПроблемныйЭлемент <> Неопределено Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.ЭлементПересеченияРазделений = ПроблемныйЭлемент;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Ищет элемент, входящий в несколько сегментов Разделение-Слияние.
// В качестве результата, возвращает его имя.
//
// Параметры:
//  СегментыРазделениеСлияние - см. ТаблицаСегментовРазделения
//
// Возвращаемое значение:
//  Строка, Неопределено - имя элемента входящего в 2 параллельных сегмента.
//
Функция ЭлементВходящийВНесколькоСегментовРазделениеСлияние(СегментыРазделениеСлияние)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТЗ_Сегменты.ЭлементСегмента КАК ЭлементСегмента,
		|	ТЗ_Сегменты.ИндексЭлемента КАК ИндексЭлемента,
		|	ТЗ_Сегменты.ПоследовательРазделения КАК ВеткаРазделения
		|ПОМЕСТИТЬ ВТ_Сегменты
		|ИЗ
		|	&ТЗ_Сегменты КАК ТЗ_Сегменты
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	ВТ_Сегменты.ЭлементСегмента КАК ЭлементСегмента,
		|	МИНИМУМ(ВТ_Сегменты.ИндексЭлемента) КАК ИндексЭлемента
		|ИЗ
		|	ВТ_Сегменты КАК ВТ_Сегменты
		|СГРУППИРОВАТЬ ПО
		|	ВТ_Сегменты.ЭлементСегмента
		|ИМЕЮЩИЕ
		|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ВТ_Сегменты.ВеткаРазделения) > 1
		|
		|УПОРЯДОЧИТЬ ПО
		|	ИндексЭлемента";
	
	Запрос.УстановитьПараметр("ТЗ_Сегменты", СегментыРазделениеСлияние);
	РезультатЗапроса = Запрос.Выполнить();
	
	Выборка = РезультатЗапроса.Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ЭлементСегмента;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает таблицу элементов схемы, которые входят в разделение.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица сегментов разделения слияния:
//	 * ЭлементСегмента - Строка - элемент схемы, который входит в один из путей разделения(сегмент) 
//	 * ИндексЭлемента - Число - порядковый номер элемента в сегменте 
//	 * ПоследовательРазделения - Строка - Имя последователя разделения, к которому относятся элемент и сегмент
// 
Функция ТаблицаСегментовРазделения()
	
	ТЗ_Сегменты = Новый ТаблицаЗначений;
	ТЗ_Сегменты.Колонки.Добавить("ЭлементСегмента", ОбщегоНазначения.ОписаниеТипаСтрока(100));
	ТЗ_Сегменты.Колонки.Добавить("ИндексЭлемента", ОбщегоНазначения.ОписаниеТипаЧисло(10));
	ТЗ_Сегменты.Колонки.Добавить("ПоследовательРазделения", ОбщегоНазначения.ОписаниеТипаСтрока(100));
	
	Возврат ТЗ_Сегменты;
	
КонецФункции

#КонецОбласти

#Область РаботаСДаннымиСхемы

// Добавляет последователей элемента схемы в путь.
// Процедура рекурсивная. Используется в функции ПутиСхемыПроцесса.
//
// Параметры:
//  ВсеПути - Массив Из Массив - все возможные пути, каждый путь это массив имен элементов схемы.
//  ИндексТекущегоПути - Число - индекс пути текущего элемента.
//  Предшественники - ТаблицаЗначений:
//    * Имя - Строка
//    * ИмяПредшественника - Строка
//  ЭлементСхемы - Строка - имя элемента схемы, последователи которого добавляются в путь.
//
Процедура ДобавитьПоследователейЭлементаСхемыВПуть(
	ВсеПути, ИндексТекущегоПути, Предшественники, ЭлементСхемы)
	
	// Определяем по индексу текущий путь.
	ТекущийПуть = ВсеПути[ИндексТекущегоПути];
	
	// Добавляем элемент в путь.
	ТекущийПуть.Добавить(ЭлементСхемы);
	
	// Находим последователей элемента схемы.
	Отбор = Новый Структура;
	Отбор.Вставить("ИмяПредшественника", ЭлементСхемы);
	Последователи = Предшественники.НайтиСтроки(Отбор);
	КоличествоПоследователей = Последователи.Количество();
	
	// Если нет, то выходим из процедуры - текущий путь сформирован.
	Если КоличествоПоследователей = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ИндексПоследователя = КоличествоПоследователей - 1;
	
	// Создаем новые пути для каждого, кроме первого, последователя
	// и добавляем них соответствующих последователей.
	Пока ИндексПоследователя > 0 Цикл
		
		ПоследовательЭлементаСхемы = Последователи[ИндексПоследователя].Имя;
		
		ИндексПоследователя = ИндексПоследователя - 1;
		
		Если ТекущийПуть.Найти(ПоследовательЭлементаСхемы) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		НовыйПуть = ОбщегоНазначенияДокументооборотКлиентСервер.ПростаяКопияМассива(ТекущийПуть);
		ВсеПути.Добавить(НовыйПуть);
		
		ИндексНовогоПути = ВсеПути.Количество() - 1;
		
		ДобавитьПоследователейЭлементаСхемыВПуть(
			ВсеПути, ИндексНовогоПути, Предшественники, ПоследовательЭлементаСхемы);
	КонецЦикла;
	
	// Первого последователя добавляем в текущий путь.
	ПоследовательЭлементаСхемы = Последователи[0].Имя;
	Если ТекущийПуть.Найти(ПоследовательЭлементаСхемы) = Неопределено Тогда
		ДобавитьПоследователейЭлементаСхемыВПуть(
			ВсеПути, ИндексТекущегоПути, Предшественники, ПоследовательЭлементаСхемы);
	КонецЕсли;
	
КонецПроцедуры

Функция  НаименованиеЭлемента(ЭлементСхемы)

	НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
	Если Не ЗначениеЗаполнено(НаименованиеЭлемента) Тогда
		НаименованиеЭлемента = ЭлементСхемы.Имя;
	КонецЕсли;	
	
	Возврат НаименованиеЭлемента;

КонецФункции

// Заполняет сроки элементов схемы для процесса
// 
// Параметры:
//  ДанныеПараметровСхемы - см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураДанныхПараметровСхемы
//  Процесс - БизнесПроцессСсылка.КомплексныйПроцесс
//  СрокиЭлементов - см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураСроковЭлементовСхемы
//
Процедура ЗаполнитьСрокиЭлементовСхемыДляПроцесса(ДанныеПараметровСхемы, Процесс, СрокиЭлементов)
	
	ПроцессыМассив = Новый Массив;
	ПроцессыЭлементов = РаботаСКомплекснымиБизнесПроцессамиСервер.ПроцессыЭлементовСхемыПоКомплексномуПроцессу(Процесс);
	
	ТипыНастроекДействий = Метаданные.ОпределяемыеТипы.ШаблонДействияКомплексногоПроцесса.Тип;
	ТипыНастроек = ТипыНастроекДействий.Типы();
	ТипыНастроек.Добавить(Тип("СправочникСсылка.ИменаПредметов"));
	ТипыНастроек = Новый ОписаниеТипов(ТипыНастроек);

	ДействияИВложенныеПроцессы = Новый Массив;
	Для Каждого ИмяЭлементаИНастройка Из ДанныеПараметровСхемы.НастройкиЭлементов Цикл
		
		ИмяЭлемента = ИмяЭлементаИНастройка.Ключ;
		НастройкаЭлемента = ИмяЭлементаИНастройка.Значение;

		Если Не ТипыНастроек.СодержитТип(ТипЗнч(НастройкаЭлемента)) Или Не ЗначениеЗаполнено(НастройкаЭлемента) Тогда
			Продолжить;
		КонецЕсли;

		ДействияИВложенныеПроцессы.Добавить(НастройкаЭлемента);

		ПроцессЭлемента = ПроцессыЭлементов[ИмяЭлемента];
		Если ЗначениеЗаполнено(ПроцессЭлемента) Тогда
			ДействияИВложенныеПроцессы.Добавить(ПроцессЭлемента);
			ПроцессыМассив.Добавить(ПроцессЭлемента);
		КонецЕсли;
		
	КонецЦикла;
	
	КэшДанныхДействий = РаботаСКомплекснымиБизнесПроцессамиСервер.КэшДанныхДействий(ДействияИВложенныеПроцессы);

	РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.ЗаполнитьСрокиЭлементовСхемы(СрокиЭлементов, 
		ДанныеПараметровСхемы.НастройкиЭлементов, ПроцессыЭлементов, КэшДанныхДействий,
		РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураПроцессовЭлементовДляПрерывания(), СрокиЭлементов);
	
КонецПроцедуры

// Заполняет сроки элементов схемы для шаблона
// 
// Параметры:
//  ДанныеПараметровСхемы - см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураДанныхПараметровСхемы
//  СрокиЭлементов - см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураСроковЭлементовСхемы
//
Процедура ЗаполнитьСрокиЭлементовСхемыДляШаблона(ДанныеПараметровСхемы, СрокиЭлементов)
	
	НастройкиДействийСхемы = РаботаСКомплекснымиБизнесПроцессамиСервер.
		НастройкиДействийИВложенныхПроцессовВДанныхПараметров(ДанныеПараметровСхемы);

	КэшДанныхДействий = РаботаСКомплекснымиБизнесПроцессамиСервер.КэшДанныхДействий(НастройкиДействийСхемы);

	РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.ЗаполнитьСрокиЭлементовСхемы(СрокиЭлементов, 
		ДанныеПараметровСхемы.НастройкиЭлементов,
		РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураПроцессовЭлементов(), КэшДанныхДействий,
		РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураПроцессовЭлементовДляПрерывания(),
		РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураТекущихЭлементовСхемы());
	
КонецПроцедуры

// Заполняет сроки элементов схемы по владельцу схемы
// 
// Параметры:
//  ДанныеСхемы - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ДанныеПараметровСхемы - см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураДанныхПараметровСхемы
//  ВладелецСхемы - СправочникСсылка.ШаблоныКомплексныхБизнесПроцессов
//  			  - БизнесПроцессСсылка.КомплексныйПроцесс
//  СрокиЭлементов - см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураСроковЭлементовСхемы
//
Процедура ЗаполнитьСрокиЭлементовСхемы(ДанныеПараметровСхемы, ВладелецСхемы, СрокиЭлементов)
	
	Если ТипЗнч(ВладелецСхемы) = Тип("СправочникСсылка.ШаблоныКомплексныхБизнесПроцессов") Тогда
		ЗаполнитьСрокиЭлементовСхемыДляШаблона(ДанныеПараметровСхемы, СрокиЭлементов);
	Иначе
		ЗаполнитьСрокиЭлементовСхемыДляПроцесса(ДанныеПараметровСхемы, ВладелецСхемы, СрокиЭлементов);
	КонецЕсли;
	
КонецПроцедуры	

#Область ОбновлениеКэширующихДанныхСхемы

// Структура результата расчета кэширующих данных схемы.
// 
// Возвращаемое значение:
//  Структура - Новый результат расчета кэширующих данных схемы:
//   * Длительность - Число
//   * ВсеПути - см. ПутиСхемыПроцесса
//   * ПорядокСортировкиНастроекЭлементов - Соответствие Из КлючИЗначение:
//     ** Ключ - Строка - Имя элемента схемы
//     ** Значение - Число
//   * ТаблицаПредшественников - Неопределено
//							 - см. СрокиИсполненияПроцессов.ПустаяТаблицаПредшественников
//   * Записывать - Булево - Истина, если записываем кэш в регистры сведений
//   * ИменаДанныхДляЗаписи - Строка - имена кэширующих данных, которые будем записывать
//
Функция НовыйРезультатРасчетаКэширующихДанныхСхемы()
	
	НовыйРезультат = Новый Структура;
	НовыйРезультат.Вставить("Длительность", 0);
	НовыйРезультат.Вставить("ВсеПути", Новый Массив);
	НовыйРезультат.Вставить("ПорядокСортировкиНастроекЭлементов", Новый Соответствие);
	НовыйРезультат.Вставить("ТаблицаПредшественников", Неопределено);
	НовыйРезультат.Вставить("Записывать", Ложь);
	НовыйРезультат.Вставить("ИменаДанныхДляЗаписи", "");
	
	Возврат НовыйРезультат;
	
КонецФункции	


// Рассчитывает длительность схемы
// 
// Параметры:
//  ДанныеСхемы см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ВладелецСхемы - СправочникСсылка.ШаблоныКомплексныхБизнесПроцессов
//  			  - БизнесПроцессСсылка.КомплексныйПроцесс
//  РезультатРасчета - см. НовыйРезультатРасчетаКэширующихДанныхСхемы
//
Процедура РассчитатьДлительностьСхемы(ДанныеСхемы, ВладелецСхемы, РезультатРасчета)

	Если Не ДанныеСхемы.РассчитатьОтносительныйСрок Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ВладелецСхемы) Тогда
		Возврат;
	КонецЕсли;	

	ДанныеСхемы.ПолучатьДлительностьИзКэш = Ложь;
	ПараметрыДляОпределенияДлительности
			= СрокиИсполненияПроцессовКОРП.ПараметрыДляОпределенияДлительностиКомплексногоПроцессаСоСхемой();
	ПараметрыДляОпределенияДлительности.Ссылка = ВладелецСхемы;
	ПараметрыДляОпределенияДлительности.ДанныеСхемы = ДанныеСхемы;
	ПараметрыДляОпределенияДлительности.СрокиЭлементов = ДанныеСхемы.СрокиЭлементов;
	ДлительностьИсполнения = СрокиИсполненияПроцессов.ДлительностьИсполненияПроцесса(
		ПараметрыДляОпределенияДлительности, ДанныеСхемы.СмещенияДатыОтсчета);
	РезультатРасчета.Длительность = СрокиИсполненияПроцессов.ДлительностьВМинутах(
		ДлительностьИсполнения.СрокИсполненияПроцессаДни, ДлительностьИсполнения.СрокИсполненияПроцессаЧасы,
		ДлительностьИсполнения.СрокИсполненияПроцессаМинуты,
		СрокиИсполненияПроцессов.КоличествоРабочихЧасовПользователя(Неопределено));
	РезультатРасчета.Записывать = Истина;
	РезультатРасчета.ИменаДанныхДляЗаписи = РезультатРасчета.ИменаДанныхДляЗаписи
		+ ?(ЗначениеЗаполнено(РезультатРасчета.ИменаДанныхДляЗаписи), ",", "") + "Длительность";
	
	Если Не ДанныеСхемы.ПутиИзменены И РезультатРасчета.Записывать Тогда
		ЗаписатьКэшСхемы(ДанныеСхемы, РезультатРасчета.ИменаДанныхДляЗаписи);
		РезультатРасчета.Записывать = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Рассчитывает таблицу последователей действий схемы.
// 
// Параметры:
//  ДанныеСхемы - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ПутиСхемы - см. ПутиСхемыПроцесса
//  РезультатРасчета - см. НовыйРезультатРасчетаКэширующихДанныхСхемы
//  ВладелецСхемы - СправочникСсылка.ШаблоныКомплексныхБизнесПроцессов
//  			  - БизнесПроцессСсылка.КомплексныйПроцесс
//  			  - Неопределено
//
Процедура РассчитатьТаблицуПредшественниковДействийСхемы(ДанныеСхемы, ПутиСхемы, РезультатРасчета,
		ВладелецСхемы = Неопределено)
		
	ИдентификаторОбъекта = ИдентификаторВладельцаСхемыСтрокой(ДанныеСхемы, ВладелецСхемы);
	ПутиДействий = ДействияВПутяхСхемы(ПутиСхемы, ДанныеСхемы);
	РезультатРасчета.ТаблицаПредшественников = ПредшественникиДействийПоПутямСхемы(ДанныеСхемы, ПутиДействий, Ложь,
		ИдентификаторОбъекта, Истина);

	РезультатРасчета.Записывать = Истина;
		
КонецПроцедуры

// Рассчитывает порядок сортировки настроек элементов схемы для последующей записи в базу
// 
// Параметры:
//  ДанныеПараметровСхемы 	- Неопределено
//  						- см. РаботаСКомплекснымиБизнесПроцессамиКлиентСервер.СтруктураДанныхПараметровСхемы
//  ВсеПутиСхемы - см. ПутиСхемыПроцесса
//  РезультатРасчета - см. НовыйРезультатРасчетаКэширующихДанныхСхемы
//  
Процедура РассчитатьПорядокСортировкиНастроек(ДанныеПараметровСхемы, ВсеПутиСхемы, РезультатРасчета)
	
	Если ДанныеПараметровСхемы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПорядокСортировкиНастроекЭлементов = Новый Соответствие;	
	
	ПараметрыСхемыОбъект = Справочники.ПараметрыСхемДляКомплексныхПроцессов.СоздатьЭлемент();
	Для Каждого Настройка Из ДанныеПараметровСхемы.НастройкиЭлементов Цикл
		ПараметрыСхемыОбъект.НастройкиЭлементов.Добавить().ИмяЭлемента = Настройка.Ключ;
	КонецЦикла;	
	ПараметрыСхемыОбъект.ЗаполнитьПорядокСортировки(ВсеПутиСхемы);
	
	Для Каждого СтрокаТаблицы Из ПараметрыСхемыОбъект.НастройкиЭлементов Цикл
		ПорядокСортировкиНастроекЭлементов[СтрокаТаблицы.ИмяЭлемента] = СтрокаТаблицы.ПорядокСортировки;
	КонецЦикла;
	
	РезультатРасчета.ПорядокСортировкиНастроекЭлементов = ПорядокСортировкиНастроекЭлементов;
	
КонецПроцедуры

#КонецОбласти	

#КонецОбласти

#КонецОбласти