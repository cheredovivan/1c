////////////////////////////////////////////////////////////////////////////////
// Модуль содержит серверные процедуры и функции для заполнения данными шаблонов
// форм федерального статистического наблюдения в форматах .XLSM или .PDF,
// а также - другие методы для подготовки первичных статистических данных перед
// отправкой их в Банк России.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

Функция ДанныеВыгрузкиИзЗаполненногоМакетаШаблона(Форма, ТекстВыгрузки, ПараметрыВыгрузки) Экспорт
	
	ИмяВременнойПапкиZIP = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
	СоздатьКаталог(ИмяВременнойПапкиZIP);
	
	ИмяВременнойПапкиXLSM = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
	СоздатьКаталог(ИмяВременнойПапкиXLSM);
	
	// Распаковка архива с шаблоном и распаковка самого шаблона.
	ИмяФайлаАрхива = ИмяВременнойПапкиZIP + "archive.zip";
	
	АрхивШаблона = Форма.ОбъектОтчета(Форма.ИмяФормы).ПолучитьМакет(ПараметрыВыгрузки.ИмяМакетаШаблона);
	АрхивШаблона.Записать(ИмяФайлаАрхива);
	
	ЧтениеZip = Новый ЧтениеZipФайла(ИмяФайлаАрхива);
	
	ИмяФайлаШаблона = ИмяВременнойПапкиZIP + ЧтениеZip.Элементы[0].Имя;
	
	ЧтениеZip.Извлечь(ЧтениеZip.Элементы[0], ИмяВременнойПапкиZIP, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	ЧтениеZip.Закрыть();
	
	ЧтениеZip = Новый ЧтениеZipФайла(ИмяФайлаШаблона); // распаковка содержимого .XLSM шаблона
	ЧтениеZip.ИзвлечьВсе(ИмяВременнойПапкиXLSM, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	ЧтениеZip.Закрыть();
	
	УдалитьФайлы(ИмяФайлаАрхива);
	УдалитьФайлы(ИмяФайлаШаблона);
	
	// Подготовка распакованных файлов шаблона к обработке.
	ТЗОбработки = Новый ТаблицаЗначений;
	ТЗОбработки.Колонки.Добавить("ИД",          Новый ОписаниеТипов("Строка"));
	ТЗОбработки.Колонки.Добавить("Каталог",     Новый ОписаниеТипов("Строка"));
	ТЗОбработки.Колонки.Добавить("ИмяФайла",    Новый ОписаниеТипов("Строка"));
	ТЗОбработки.Колонки.Добавить("ТипФайла",    Новый ОписаниеТипов("Строка"));
	ТЗОбработки.Колонки.Добавить("ТипФайлаXML", Новый ОписаниеТипов("Строка"));
	ТЗОбработки.Колонки.Добавить("ЭтоКнига",    Новый ОписаниеТипов("Булево"));
	ТЗОбработки.Колонки.Добавить("ЭтоЛист",     Новый ОписаниеТипов("Булево"));
	ТЗОбработки.Колонки.Добавить("ИмяЛиста",    Новый ОписаниеТипов("Строка"));
	ТЗОбработки.Колонки.Добавить("ИДЛиста",     Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(3,0)));
	ТЗОбработки.Колонки.Добавить("Статус",      Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(1,0)));
	ТЗОбработки.Колонки.Добавить("СвязьСтрока");
	ТЗОбработки.Колонки.Добавить("Документ");
	ТЗОбработки.Колонки.Добавить("Свойства");
	ТЗОбработки.Колонки.Добавить("КэшЭлем",     Новый ОписаниеТипов("Структура"));
	
	НайденныеФайлы = НайтиФайлы(ИмяВременнойПапкиXLSM, "*", Истина);
	Для Каждого Файл Из НайденныеФайлы Цикл
		
		Если НЕ Файл.Существует() ИЛИ Файл.ЭтоКаталог() Тогда
			Продолжить;
		КонецЕсли;
		
		Файл.УстановитьВремяИзменения('19800101000000'); // сразу установим минимальную дату изменения файла
		
		Если Файл.Расширение <> ".xml" И Файл.Расширение <> ".vml" И Файл.Расширение <> ".rels" Тогда
			Продолжить;
		КонецЕсли;
		
		НовСтрока = ТЗОбработки.Добавить();
		НовСтрока.Каталог  = Файл.Путь;
		НовСтрока.ИмяФайла = Файл.Имя;
		Если Файл.Расширение = ".rels" Тогда
			НовСтрока.ТипФайла = "Relationships";
		ИначеЕсли Файл.ИмяБезРасширения = "[Content_Types]" Тогда
			НовСтрока.ТипФайла = "Types";
		Иначе
			Продолжить;
		КонецЕсли;
		
		НовСтрока.Документ = РегламентированнаяОтчетностьПреобразованиеОФД.ДокументDOMИзФайлаXML(
			Файл.ПолноеИмя, НовСтрока.Свойства);
		
	КонецЦикла;
	
	ТЗОбработки.Сортировать("Каталог,ИмяФайла");
	
	ФайлРабочаяКнигаСтрока = Неопределено;
	СписокЛистовКорень     = Неопределено;
	СписокЛистовЭлементы   = Неопределено;
	
	ФайлыСвязейСтроки = ТЗОбработки.НайтиСтроки(Новый Структура("ТипФайла", "Relationships"));
	Для Каждого ФайлСвязейСтрока Из ФайлыСвязейСтроки Цикл
		
		СвязиИзДокумента = ФайлСвязейСтрока.Документ.ПолучитьЭлементыПоИмени("Relationship");
		Для Каждого СвязьИзДокумента Из СвязиИзДокумента Цикл
			
			ИД = СвязьИзДокумента.ПолучитьАтрибут("Id");
			ТипФайлаXML = СвязьИзДокумента.ПолучитьАтрибут("Type");
			ОтносительныйПутьКФайлу = СвязьИзДокумента.ПолучитьАтрибут("Target");
			
			Файл = Новый Файл(ФайлСвязейСтрока.Каталог + ".." + ПолучитьРазделительПути()
				+ СокрЛП(СтрЗаменить(ОтносительныйПутьКФайлу, "/", ПолучитьРазделительПути())));
			Если Файл.Существует() Тогда
				ФайлыПоСсылкеСтроки = ТЗОбработки.НайтиСтроки(Новый Структура("Каталог,ИмяФайла", Файл.Путь, Файл.Имя));
				Если ФайлыПоСсылкеСтроки.Количество() > 0 Тогда
					ФайлПоСсылкеСтрока = ФайлыПоСсылкеСтроки[0];
					
					ФайлПоСсылкеСтрока.ИД = ИД;
					ТипФайлаXMLСостав = СтрРазделить(ТипФайлаXML, "/");
					ФайлПоСсылкеСтрока.ТипФайла = ТипФайлаXMLСостав[ТипФайлаXMLСостав.ВГраница()];
					ФайлПоСсылкеСтрока.ТипФайлаXML = ТипФайлаXML;
					ФайлПоСсылкеСтрока.СвязьСтрока = ФайлСвязейСтрока;
					
					Если ФайлПоСсылкеСтрока.ТипФайла = "officeDocument" Тогда
						
						ФайлПоСсылкеСтрока.ЭтоКнига = Истина;
						ФайлПоСсылкеСтрока.Документ = РегламентированнаяОтчетностьПреобразованиеОФД.ДокументDOMИзФайлаXML(
							Файл.ПолноеИмя, ФайлПоСсылкеСтрока.Свойства);
						
						ФайлРабочаяКнигаСтрока = ФайлПоСсылкеСтрока; // файл этого типа единственный в шаблоне
						СписокЛистовКорень = ФайлРабочаяКнигаСтрока.Документ.ПолучитьЭлементыПоИмени("sheets")[0];
						СписокЛистовЭлементы = СписокЛистовКорень.ПолучитьЭлементыПоИмени("sheet");
						
						Продолжить;
						
					ИначеЕсли ФайлПоСсылкеСтрока.ТипФайла = "worksheet" Тогда
						
						ФайлПоСсылкеСтрока.ЭтоЛист = Истина;
						
						Если СписокЛистовЭлементы <> Неопределено И СписокЛистовЭлементы.Количество() > 0 Тогда
							Разыменователь = ФайлРабочаяКнигаСтрока.Документ.СоздатьРазыменовательПИ();
							РезультатXPath = ФайлРабочаяКнигаСтрока.Документ.ВычислитьВыражениеXPath("xmlns:sheet[@r:id='" + ИД + "']",
								СписокЛистовКорень, Разыменователь, ТипРезультатаDOMXPath.ПервыйУпорядоченныйУзел);
							Если ТипЗнч(РезультатXPath.ОдиночныйУзелЗначение) = Тип("ЭлементDOM") Тогда
								ФайлПоСсылкеСтрока.ИмяЛиста = СокрЛП(РезультатXPath.ОдиночныйУзелЗначение.ПолучитьАтрибут("name"));
								ФайлПоСсылкеСтрока.ИДЛиста = Число(" " + РезультатXPath.ОдиночныйУзелЗначение.ПолучитьАтрибут("sheetId"));
							КонецЕсли;
						КонецЕсли;
						
					КонецЕсли;
					
					ФайлПоСсылкеСтрока.Документ = РегламентированнаяОтчетностьПреобразованиеОФД.ДокументDOMИзФайлаXML(
						Файл.ПолноеИмя, ФайлПоСсылкеСтрока.Свойства);
					
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	// Подготовка дополнительных параметров выгрузки для оптимизации заполнения документов.
	ДопПараметрыШаблона = Новый Структура();
	ПараметрыВыгрузки.Вставить("ДопПараметрыШаблона", ДопПараметрыШаблона);
	
	ДопПараметрыШаблона.Вставить("ДокументРабочаяКнига", ФайлРабочаяКнигаСтрока.Документ);
	
	ФайлОбщиеСтроки = ТЗОбработки.Найти("sharedStrings", "ТипФайла");
	Если ФайлОбщиеСтроки <> Неопределено Тогда
		ФайлОбщиеСтроки.Статус = 1; // всегда будет модифицирован
		ДопПараметрыШаблона.Вставить("ДокументОбщиеСтроки", ФайлОбщиеСтроки.Документ);
		ДопПараметрыШаблона.Вставить("ИндексыОбщихСтрок", РегламентированнаяОтчетностьПреобразованиеОФД.ИндексыОбщихСтрок(
			ФайлОбщиеСтроки.Документ));
	КонецЕсли;
	
	// Подготовка соответствия ссылок именованным областям.
	ИменаИСсылкиРабочейКниги = Новый СписокЗначений;
	КорневыеУзлыИменаИСсылки = ФайлРабочаяКнигаСтрока.Документ.ПолучитьЭлементыПоИмени("definedNames");
	Если КорневыеУзлыИменаИСсылки.Количество() > 0 Тогда
		УзлыИменаИСсылки = КорневыеУзлыИменаИСсылки[0].ПолучитьЭлементыПоИмени("definedName");
		Для Каждого УзелИмяИСсылка Из УзлыИменаИСсылки Цикл
			ИменаИСсылкиРабочейКниги.Добавить(УзелИмяИСсылка.ПолучитьАтрибут("name"), УзелИмяИСсылка.ТекстовоеСодержимое);
		КонецЦикла;
	КонецЕсли;
	ДопПараметрыШаблона.Вставить("ИменаИСсылкиРабочейКниги", ИменаИСсылкиРабочейКниги);
	
	// Внесение изменений в документы DOM распакованного шаблона.
	ЗаписатьДанныеВДокументыШаблона(Форма, ТекстВыгрузки, ПараметрыВыгрузки, ТЗОбработки);
	ЗаписатьДополнительнуюИнформациюВДокументыШаблона(ПолноеИмяПользователя(), ТЗОбработки);
	
	// Запись модифицированных файлов шаблона после обработки.
	Для Каждого СтрокаТаблицы Из ТЗОбработки Цикл
		Если СтрокаТаблицы.Статус > 0 Тогда
			РегламентированнаяОтчетностьПреобразованиеОФД.ЗаписатьДокументDOMВФайлXML(
				СтрокаТаблицы.Документ,
				СтрокаТаблицы.Каталог + СтрокаТаблицы.ИмяФайла,
				СтрокаТаблицы.Свойства, СтрокаТаблицы.ТипФайла);
		КонецЕсли;
	КонецЦикла;
	
	// Удаление дополнительных параметров шаблона (данные используются только на сервере).
	ПараметрыВыгрузки.Удалить("ДопПараметрыШаблона");
	
	// Упаковка измененных файлов в файл шаблона и создание нового архива с шаблоном.
	ЗаписьZip = Новый ЗаписьZipФайла(ИмяФайлаШаблона, , , МетодСжатияZIP.Сжатие, УровеньСжатияZIP.Оптимальный);
	ЗаписьZip.Добавить(ИмяВременнойПапкиXLSM + "*.*",
		РежимСохраненияПутейZIP.СохранятьОтносительныеПути, РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);
	ЗаписьZip.Записать();
	
	ЗаписьZip = Новый ЗаписьZipФайла(ИмяФайлаАрхива, , , МетодСжатияZIP.Сжатие, УровеньСжатияZIP.Оптимальный);
	ЗаписьZip.Добавить(ИмяФайлаШаблона);
	ЗаписьZip.Записать();
	
	АдресАрхиваШаблонаВоВремХранилище = ПоместитьВоВременноеХранилище(
		Новый ДвоичныеДанные(ИмяФайлаАрхива), Новый УникальныйИдентификатор);
	
	// Удаляются временные папки со всеми созданными файлами.
	УдалитьФайлы(ИмяВременнойПапкиXLSM);
	УдалитьФайлы(ИмяВременнойПапкиZIP);
	
	ДанныеВыгрузкиШаблона = Новый Структура;
	ДанныеВыгрузкиШаблона.Вставить("ИмяФайлаВыгрузки", ПараметрыВыгрузки.ИмяФайлаШаблона + ".zip");
	ДанныеВыгрузкиШаблона.Вставить("АдресФайлаВыгрузки", АдресАрхиваШаблонаВоВремХранилище);
	ДанныеВыгрузкиШаблона.Вставить("ТипФайлаВыгрузки", "ОтчетФСНБР");
	
	Возврат ДанныеВыгрузкиШаблона;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ЗаполнениеФайловШаблонаДанными

Процедура ЗаписатьДанныеВДокументыШаблона(Форма, ТекстВыгрузки, ПараметрыВыгрузки, ТЗОбработки)
	
	// Обычные разделы.
	Для Каждого ЭлементРазделОтчета Из Форма.мДанныеОтчета Цикл
		
		Если ЭтоМногострочныйРаздел(ЭлементРазделОтчета.Значение) Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураДанныхРаздела = ЭлементРазделОтчета.Значение;
		
		Для Каждого ЭлементСтруктуры Из СтруктураДанныхРаздела Цикл
			
			ИмяИСсылка = НайтиЭлементСпискаПоСтроковомуЗначению(
				ПараметрыВыгрузки.ДопПараметрыШаблона.ИменаИСсылкиРабочейКниги, ЭлементСтруктуры.Ключ);
			
			Если ИмяИСсылка <> Неопределено Тогда
				
				РегламентированнаяОтчетностьПреобразованиеОФД.УстановитьЗначениеВЯчейкеЛиста(
					ИмяИСсылка.Представление, ЭлементСтруктуры.Значение, ТЗОбработки, ПараметрыВыгрузки);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Таблицы данных.
	Для Каждого ЭлементТаблицаРазделов Из ПараметрыВыгрузки.МетаданныеШаблона.ТаблицыРазделов Цикл
		
		ИмяТаблицыРаздела = ЭлементТаблицаРазделов.Ключ;
		ИмяСтартовойЯчейки = ИмяТаблицыРаздела + "_START";
		
		НачальныеИмяИСсылка = НайтиЭлементСпискаПоСтроковомуЗначению(
			ПараметрыВыгрузки.ДопПараметрыШаблона.ИменаИСсылкиРабочейКниги, ИмяСтартовойЯчейки);
		
		Если НачальныеИмяИСсылка <> Неопределено Тогда
			
			ИмяЛистаИСсылкаРазд = РегламентированнаяОтчетностьПреобразованиеОФД.ИмяЛистаИСсылка(
				НачальныеИмяИСсылка.Представление);
			КоординатыЯчейки = КоординатыОбласти(ИмяЛистаИСсылкаРазд.Ссылка);
			
			КоличествоКолонок = ЭлементТаблицаРазделов.Значение.Колонки.Количество();
			
			Для НомСтр = 1 По ЭлементТаблицаРазделов.Значение.Количество() Цикл
				ДанныеСтроки = ЭлементТаблицаРазделов.Значение[НомСтр - 1];
				
				Для НомКол = 1 По КоличествоКолонок - 1 Цикл // колонку с индексом 0 пропускаем
					ЗначениеКолонки = ДанныеСтроки[НомКол];
					
					НомСтроки  = КоординатыЯчейки.Строка1  + НомСтр;
					НомСтолбца = КоординатыЯчейки.Столбец1 + НомКол - 1;
					ИмяЛистаИСсылкаРазд.Ссылка = РегламентированнаяОтчетностьПреобразованиеОФД.СимвольныйКодИзПорядковогоНомера(
						НомСтолбца) + Формат(НомСтроки, "ЧГ=");
					
					Если НомКол = 1 И НЕ ЗначениеЗаполнено(ЗначениеКолонки) Тогда // незаполненный номер строки пропускаем
						Продолжить;
					КонецЕсли;
					
					РегламентированнаяОтчетностьПреобразованиеОФД.УстановитьЗначениеВЯчейкеЛиста(
						ИмяЛистаИСсылкаРазд, ЗначениеКолонки, ТЗОбработки, ПараметрыВыгрузки);
				КонецЦикла;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Таблица ответов.
	ТаблицаОтветов = Неопределено;
	
	Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("Answer_Meta", ТаблицаОтветов) Тогда
		ИмяЛистаИСсылка = Новый Структура("ИмяЛиста,Ссылка", "Answer_Meta", "");
		КоличествоКолонок = ТаблицаОтветов.Колонки.Количество();
		
		Для НомСтр = 1 По ТаблицаОтветов.Количество() Цикл
			ДанныеСтроки = ТаблицаОтветов[НомСтр - 1];
			
			Для НомКол = 1 По КоличествоКолонок Цикл
				ЗначениеКолонки = ДанныеСтроки[НомКол - 1];
				Если НЕ ЗначениеЗаполнено(ЗначениеКолонки) Тогда
					Продолжить;
				КонецЕсли;
				ИмяЛистаИСсылка.Ссылка = РегламентированнаяОтчетностьПреобразованиеОФД.СимвольныйКодИзПорядковогоНомера(
					НомКол) + Формат(НомСтр, "ЧГ=");
				
				РегламентированнаяОтчетностьПреобразованиеОФД.УстановитьЗначениеВЯчейкеЛиста(
					ИмяЛистаИСсылка, ЗначениеКолонки, ТЗОбработки, ПараметрыВыгрузки);
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	// Таблица ошибок.
	ТаблицаОшибок = Неопределено;
	
	Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("Errors_Meta", ТаблицаОшибок) Тогда
		ИмяЛистаИСсылка = Новый Структура("ИмяЛиста,Ссылка", "Errors_Meta", "");
		КоличествоКолонок = ТаблицаОшибок.Колонки.Количество();
		
		Для НомСтр = 1 По ТаблицаОшибок.Количество() Цикл
			ДанныеСтроки = ТаблицаОшибок[НомСтр - 1];
			
			Для НомКол = 1 По КоличествоКолонок Цикл
				ЗначениеКолонки = ДанныеСтроки[НомКол - 1];
				Если НЕ ЗначениеЗаполнено(ЗначениеКолонки) Тогда
					Продолжить;
				КонецЕсли;
				ИмяЛистаИСсылка.Ссылка = РегламентированнаяОтчетностьПреобразованиеОФД.СимвольныйКодИзПорядковогоНомера(
					НомКол) + Формат(НомСтр, "ЧГ=");
				
				РегламентированнаяОтчетностьПреобразованиеОФД.УстановитьЗначениеВЯчейкеЛиста(
					ИмяЛистаИСсылка, ЗначениеКолонки, ТЗОбработки, ПараметрыВыгрузки);
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	// Данные опроса.
	СписокДанныеОпроса = Неопределено;
	
	Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("Survey_Meta", СписокДанныеОпроса) Тогда
		ИмяЛистаИСсылка = Новый Структура("ИмяЛиста,Ссылка", "Survey_Meta", "");
		КодКолонкиЛиста = РегламентированнаяОтчетностьПреобразованиеОФД.СимвольныйКодИзПорядковогоНомера(2);
		
		КодПериода = "";
		ГодПериода = "2023";
		ДатаВерсииШаблона = '00010101';
		
		Для НомСтр = 1 По СписокДанныеОпроса.Количество() Цикл
			ЭлементДанных = СписокДанныеОпроса[НомСтр - 1];
			Если ЭлементДанных.Представление = "SURVEY_DATE" Тогда
				ДатаВерсииШаблона = РегламентированнаяОтчетностьЗагрузка.ДатаИзСтрокиЛюбогоФормата(ЭлементДанных.Значение);
			ИначеЕсли ЭлементДанных.Представление = "PERIODVALUE" Тогда
				КодПериода = ЭлементДанных.Значение;
			ИначеЕсли ЭлементДанных.Представление = "PERIODYEAR" Тогда
				ГодПериода = ЭлементДанных.Значение;
			КонецЕсли;
			Если НЕ ЭлементДанных.Пометка Тогда
				Продолжить;
			КонецЕсли;
			ИмяЛистаИСсылка.Ссылка = КодКолонкиЛиста + Формат(НомСтр, "ЧГ=");
			
			РегламентированнаяОтчетностьПреобразованиеОФД.УстановитьЗначениеВЯчейкеЛиста(
				ИмяЛистаИСсылка, ЭлементДанных.Значение, ТЗОбработки, ПараметрыВыгрузки);
		КонецЦикла;
		
		// Данные отчетного периода.
		Если ДатаВерсииШаблона >= '20230420' Тогда
			ИмяЛистаИСсылка.ИмяЛиста = "Meta";
			ИмяЛистаИСсылка.Ссылка = "E1";
			РегламентированнаяОтчетностьПреобразованиеОФД.УстановитьЗначениеВЯчейкеЛиста(
				ИмяЛистаИСсылка, КодПериода, ТЗОбработки, ПараметрыВыгрузки);
			ИмяЛистаИСсылка.Ссылка = "F1";
			РегламентированнаяОтчетностьПреобразованиеОФД.УстановитьЗначениеВЯчейкеЛиста(
				ИмяЛистаИСсылка, ГодПериода, ТЗОбработки, ПараметрыВыгрузки);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьДополнительнуюИнформациюВДокументыШаблона(ИмяРедактора, ТЗОбработки)
	
	ФайлОсновной = ТЗОбработки.Найти("core-properties", "ТипФайла");
	Если ФайлОсновной <> Неопределено Тогда
		ФайлОсновной.Статус = 1; // будет модифицирован
		
		УзлыИмяРедактора = ФайлОсновной.Документ.ПолучитьЭлементыПоИмени("cp:lastModifiedBy");
		Если УзлыИмяРедактора.Количество() > 0 Тогда
			УзлыИмяРедактора[0].ТекстовоеСодержимое = ИмяРедактора;
		КонецЕсли;
		УзлыВремяРедактирования = ФайлОсновной.Документ.ПолучитьЭлементыПоИмени("dcterms:modified");
		Если УзлыВремяРедактирования.Количество() > 0 Тогда
			УзлыВремяРедактирования[0].ТекстовоеСодержимое = XMLСтрока(ТекущаяУниверсальнаяДата()) + "Z";
		КонецЕсли;
	КонецЕсли;
	
	// Снимаем защиту у модифицированных листов.
	ФайлыЛистаСтроки = ТЗОбработки.НайтиСтроки(Новый Структура("ЭтоЛист,Статус", Истина, 1));
	Для Каждого ФайлЛистаСтрока Из ФайлыЛистаСтроки Цикл
		УзелЗащитыЛиста = Неопределено;
		Если ФайлЛистаСтрока.КэшЭлем.Свойство("sheetProtection", УзелЗащитыЛиста) Тогда
			УзелЗащитыЛиста.Док.РодительскийУзел.УдалитьДочерний(УзелЗащитыЛиста.Док);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция КоординатыОбласти(СсылкаНаОбласть) Экспорт
	
	Координаты = Новый Структура("Строка1,Столбец1,Строка2,Столбец2", 0, 0, 0, 0);
	
	ЧастиСтрСсылки = СтрРазделить(СтрЗаменить(СсылкаНаОбласть, "$", ""), ":");
	
	СтрЦифры = "0123456789";
	
	Для Ном = 1 По Мин(ЧастиСтрСсылки.Количество(), 2) Цикл
		
		СтрСтрока = "";
		СтрСтолбец = "";
		
		ЧастьСтрСсылки = СокрЛП(ЧастиСтрСсылки[Ном - 1]);
		Для НомСим = 1 По СтрДлина(ЧастьСтрСсылки) Цикл
			Сим = Сред(ЧастьСтрСсылки, НомСим, 1);
			Если СтрНайти(СтрЦифры, Сим) > 0 Тогда
				СтрСтрока = СтрСтрока + Сим;
			Иначе
				СтрСтолбец = СтрСтолбец + Сим;
			КонецЕсли;
		КонецЦикла;
		
		ИмяКлючаСтрока  = "Строка"  + СокрЛ(Ном);
		ИмяКлючаСтолбец = "Столбец" + СокрЛ(Ном);
		
		Координаты[ИмяКлючаСтрока]  = Число(" " + СтрСтрока);
		Координаты[ИмяКлючаСтолбец] = ПорядковыйНомерИзСимвольногоКода(СтрСтолбец);
		
	КонецЦикла;
	
	Возврат Координаты;
	
КонецФункции

Функция ПорядковыйНомерИзСимвольногоКода(Знач СимвольныйКод)
	
	ПорядковыйНомер = 0;
	
	НаборСимволов = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	
	ДлинаКода   = СтрДлина(СимвольныйКод);
	ДлинаНабора = СтрДлина(НаборСимволов);
	
	ВесРазряда = 1;
	Для Инд = 0 По ДлинаКода - 1 Цикл
		Сим = ВРег(Сред(СимвольныйКод, ДлинаКода - Инд, 1));
		ПорядковыйНомер = ПорядковыйНомер + ВесРазряда * СтрНайти(НаборСимволов, Сим);
		ВесРазряда = ВесРазряда * ДлинаНабора;
	КонецЦикла;
	
	Возврат ПорядковыйНомер;
	
КонецФункции

#КонецОбласти

#Область ОбщиеПроцедурыИФункции

Функция НайтиЭлементСпискаПоСтроковомуЗначению(СписокЭлементов, ЗначениеЭлемента)
	
	Для Каждого ЭлементСписка Из СписокЭлементов Цикл
		Если ВРег(ЭлементСписка.Значение) = ВРег(ЗначениеЭлемента) Тогда
			Возврат ЭлементСписка;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция НайтиЭлементСпискаПоПредставлению(СписокЭлементов, Представление) Экспорт
	
	Для Каждого ЭлементСписка Из СписокЭлементов Цикл
		Если ВРег(ЭлементСписка.Представление) = ВРег(Представление) Тогда
			Возврат ЭлементСписка;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПериодАнкеты(ДатаВПериоде, КодПериодичности = 3, РП = Истина, Римскими = Истина) Экспорт
	
	СтрПериод = "";
	
	СтрНомерГода = Формат(Год(ДатаВПериоде), "ЧЦ=4; ЧВН=; ЧГ=");
	
	Если КодПериодичности = 1 Тогда // неделя
		
		СтрНомерНедели = Строка(НеделяГода(ДатаВПериоде));
		СтрПериод = СтрНомерНедели + " " + ?(РП, НСтр("ru = 'недели';
														|en = 'недели'"), НСтр("ru = 'неделя';
																			|en = 'неделя'")) + " " + СтрНомерГода;
		
	ИначеЕсли КодПериодичности = 2 Тогда // месяц
		
		СтрНомерМесяца = Строка(Месяц(ДатаВПериоде));
		Если СтрНомерМесяца = "1" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Января';
									|en = 'Января'"), НСтр("ru = 'Январь';
														|en = 'Январь'"));
		ИначеЕсли СтрНомерМесяца = "2" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Февраля';
									|en = 'Февраля'"), НСтр("ru = 'Февраль';
														|en = 'Февраль'"));
		ИначеЕсли СтрНомерМесяца = "3" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Марта';
									|en = 'Марта'"), НСтр("ru = 'Март';
														|en = 'Март'"));
		ИначеЕсли СтрНомерМесяца = "4" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Апреля';
									|en = 'Апреля'"), НСтр("ru = 'Апрель';
														|en = 'Апрель'"));
		ИначеЕсли СтрНомерМесяца = "5" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Мая';
									|en = 'Мая'"), НСтр("ru = 'Май';
													|en = 'Май'"));
		ИначеЕсли СтрНомерМесяца = "6" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Июня';
									|en = 'Июня'"), НСтр("ru = 'Июнь';
														|en = 'Июнь'"));
		ИначеЕсли СтрНомерМесяца = "7" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Июля';
									|en = 'Июля'"), НСтр("ru = 'Июль';
														|en = 'Июль'"));
		ИначеЕсли СтрНомерМесяца = "8" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Августа';
									|en = 'Августа'"), НСтр("ru = 'Август';
														|en = 'Август'"));
		ИначеЕсли СтрНомерМесяца = "9" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Сентября';
									|en = 'Сентября'"), НСтр("ru = 'Сентабрь';
															|en = 'Сентабрь'"));
		ИначеЕсли СтрНомерМесяца = "10" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Октября';
									|en = 'Октября'"), НСтр("ru = 'Октябрь';
														|en = 'Октябрь'"));
		ИначеЕсли СтрНомерМесяца = "11" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Ноября';
									|en = 'Ноября'"), НСтр("ru = 'Ноябрь';
														|en = 'Ноябрь'"));
		ИначеЕсли СтрНомерМесяца = "12" Тогда
			СтрПериод = ?(РП, НСтр("ru = 'Декабря';
									|en = 'Декабря'"), НСтр("ru = 'Декабрь';
														|en = 'Декабрь'"));
		КонецЕсли;
		СтрПериод = СтрПериод + " " + СтрНомерГода;
		
	ИначеЕсли КодПериодичности = 3 Тогда // квартал
		
		СтрНомерКвартала = Формат(ДатаВПериоде, "ДФ=""к""");
		СтрПериод = СтрНомерКвартала;
		Если Римскими Тогда
			Если СтрНомерКвартала = "1" Тогда
				СтрПериод = "I";
			ИначеЕсли СтрНомерКвартала = "2" Тогда
				СтрПериод = "II";
			ИначеЕсли СтрНомерКвартала = "3" Тогда
				СтрПериод = "III";
			ИначеЕсли СтрНомерКвартала = "4" Тогда
				СтрПериод = "IV";
			КонецЕсли;
		КонецЕсли;
		СтрПериод = СтрПериод + " " + ?(РП, НСтр("ru = 'квартала';
												|en = 'квартала'"), НСтр("ru = 'квартал';
																		|en = 'квартал'")) + " " + СтрНомерГода;
		
	ИначеЕсли КодПериодичности = 4 Тогда // полугодие
		
		СтрНомерПолугодия = ?(Месяц(ДатаВПериоде) <= 6, "1", "2");
		СтрПериод = СтрНомерПолугодия;
		Если Римскими Тогда
			Если СтрНомерПолугодия = "1" Тогда
				СтрПериод = "I";
			ИначеЕсли СтрНомерПолугодия = "2" Тогда
				СтрПериод = "II";
			КонецЕсли;
		КонецЕсли;
		СтрПериод = СтрПериод + " " + ?(РП, НСтр("ru = 'полугодия';
												|en = 'полугодия'"), НСтр("ru = 'полугодие';
																		|en = 'полугодие'")) + " " + СтрНомерГода;
		
	ИначеЕсли КодПериодичности = 5 Тогда // 9 месяцев
		
		СтрПериод = НСтр("ru = 'За 9 месяцев';
						|en = 'За 9 месяцев'") + " " + СтрНомерГода;
		
	ИначеЕсли КодПериодичности = 6 Тогда // год
		
		СтрПериод = СтрНомерГода;
		
	КонецЕсли;
	
	Возврат СтрПериод;
	
КонецФункции

Функция ЭтоМногострочныйРаздел(СтруктураРаздела)
	
	Для Каждого ЭлементСтруктуры Из СтруктураРаздела Цикл
		
		Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("Массив") Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции
 
#КонецОбласти

#Область ФорматноЛогическийКонтроль

Функция ПреобразоватьЗначениеЕслиНеобходимо(ЗначениеОтвета, ВопросАнкеты) Экспорт
	
	ЗначениеПреобразовано = Ложь;
	
	ТипЗначения = ВопросАнкеты["QUESTION_VALUE_TYPE"];
	
	Если ТипЗначения = "Numeric" Тогда
		
		ОбязательностьЗаполнения = ВопросАнкеты["QUESTION_IS_MANDATORY"] = "True";
		ДопПроверкаЧисла         = СокрЛП(ВопросАнкеты["QUESTION_LOGICCONTROL"]);
		
		Если НЕ ОбязательностьЗаполнения Тогда
			Если СтрНайти(ДопПроверкаЧисла, "0") > 0 ИЛИ ПустаяСтрока(ДопПроверкаЧисла) Тогда
				Если ТипЗнч(ЗначениеОтвета) = Тип("Строка") Тогда
					ПроверяемоеЗначение = СтрЗаменить(СтрЗаменить(ЗначениеОтвета, " ", ""), Символы.НПП, "");
					Если ОбщегоНазначенияКлиентСервер.ЭтоЧисло(ПроверяемоеЗначение) Тогда
						ЗначениеОтвета = Число(" " + СтрЗаменить(ЗначениеОтвета, ",", "."));
					Иначе
						ЗначениеОтвета = "";
					КонецЕсли;
					ЗначениеПреобразовано = Истина;
				КонецЕсли;
			Иначе
				Если ТипЗнч(ЗначениеОтвета) = Тип("Число") Тогда
					Если НЕ ЗначениеЗаполнено(ЗначениеОтвета) Тогда
						ЗначениеОтвета = "";
						ЗначениеПреобразовано = Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ЗначениеПреобразовано;
	
КонецФункции

Функция ВыполнитьПроверкуЗначения(Форма, ПараметрыВыгрузки, Описание, ВопросАнкеты, Знач ЗначениеОтвета, НомСтроки = 0) Экспорт
	
	РезультатПроверки = 0;
	
	ВариантыПроверок         = Число(" " + ВопросАнкеты["QUESTION_IS_WARNING"]);
	РазмерностьЗначения      = Число(" " + ВопросАнкеты["QUESTION_VALUE_SIZE"]);
	РазмерностьДробнойЧасти  = Число(" " + ВопросАнкеты["QUESTION_FRACTION_SIZE"]);
	
	ТипЗначения              = ВопросАнкеты["QUESTION_VALUE_TYPE"];
	ДопПроверкаЧисла         = СокрЛП(ВопросАнкеты["QUESTION_LOGICCONTROL"]);
	ОбязательностьЗаполнения = ВопросАнкеты["QUESTION_IS_MANDATORY"] = "True";
	
	ИмяСправочника           = ВопросАнкеты["QUESTION_DICTNAMEID"];
	ИмяСправочникаНСИ        = ВопросАнкеты["QUESTION_NSI"];
	
	ЗначениеОтветаСтр = ЗначениеПоФорматуВопроса(ЗначениеОтвета, ВопросАнкеты, ПараметрыВыгрузки);
	
	Если ПустаяСтрока(ЗначениеОтветаСтр) Тогда
		ТекстОписания = НСтр("ru = 'Поле не заполнено';
							|en = 'Поле не заполнено'");
		Если ТребуетсяПроверка(ВариантыПроверок, 1) Тогда // предупреждение об обязательном заполнении
			РезультатПроверки = 1;
			Описание = ТекстОписания;
		ИначеЕсли ОбязательностьЗаполнения Тогда
			РезультатПроверки = 2;
			Описание = ТекстОписания;
		КонецЕсли;
	КонецЕсли;
	
	Если РезультатПроверки = 0 И РазмерностьЗначения > 0 И СтрДлина(ЗначениеОтветаСтр) > РазмерностьЗначения Тогда
		// Предупреждение о несоответствии формату.
		РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 16), 1, 2);
		Описание = СтрШаблон(НСтр("ru = 'Значение поля превышает допустимый размер в %1 символов';
									|en = 'Значение поля превышает допустимый размер в %1 символов'"),
			СокрЛ(РазмерностьЗначения));
	КонецЕсли;
	
	Если РезультатПроверки = 0 Тогда
		Если ТипЗначения = "Numeric" Тогда
			
			Если СтрДлина(ЗначениеОтветаСтр) > 0 Тогда
				Если СтроковыеФункцииКлиентСервер.СтрокаВЧисло(
						СтрЗаменить(СтрЗаменить(ЗначениеОтветаСтр, ",", ""), ".", "")) = Неопределено Тогда
					// Предупреждение о несоответствии формату.
					РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 16), 1, 2);
					Описание = НСтр("ru = 'Значение поля не соответствует типу <число> или значение слишком большое';
									|en = 'Значение поля не соответствует типу <число> или значение слишком большое'");
				КонецЕсли;
			КонецЕсли;
			Если РезультатПроверки = 0 Тогда
				ЗначениеОтветаЧисло = Число(" " + ЗначениеОтветаСтр);
				Если ДопПроверкаЧисла = "+" Тогда
					Если ЗначениеОтветаЧисло <= 0 Тогда
						// Предупреждение об ошибке логического контроля.
						РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 4), 1, 2);
						Описание = НСтр("ru = 'Число должно быть положительным';
										|en = 'Число должно быть положительным'");
					КонецЕсли; 
				ИначеЕсли ДопПроверкаЧисла = "-" Тогда
					Если ЗначениеОтветаЧисло >= 0 Тогда
						// Предупреждение об ошибке логического контроля.
						РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 4), 1, 2);
						Описание = НСтр("ru = 'Число должно быть отрицательным';
										|en = 'Число должно быть отрицательным'");
					КонецЕсли; 
				ИначеЕсли ДопПроверкаЧисла = "0+" Тогда
					Если ЗначениеОтветаЧисло < 0 Тогда
						// Предупреждение об ошибке логического контроля.
						РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 4), 1, 2);
						Описание = НСтр("ru = 'Число должно быть положительным или равным 0';
										|en = 'Число должно быть положительным или равным 0'");
					КонецЕсли; 
				ИначеЕсли ДопПроверкаЧисла = "-0" Тогда
					Если ЗначениеОтветаЧисло > 0 Тогда
						// Предупреждение об ошибке логического контроля.
						РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 4), 1, 2);
						Описание = НСтр("ru = 'Число должно быть отрицательным или равным 0';
										|en = 'Число должно быть отрицательным или равным 0'");
					КонецЕсли; 
				ИначеЕсли ДопПроверкаЧисла = "-+" Тогда
					Если ЗначениеОтветаЧисло = 0 Тогда
						// Предупреждение об ошибке логического контроля.
						РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 4), 1, 2);
						Описание = НСтр("ru = 'Число должно быть положительным или отрицательным, не равным 0';
										|en = 'Число должно быть положительным или отрицательным, не равным 0'");
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
			Если РезультатПроверки = 0 Тогда
				ПозРазделителя = СтрНайти(СтрЗаменить(ЗначениеОтветаСтр, ",", "."), ".", НаправлениеПоиска.СКонца);
				Если ПозРазделителя > 0 И (СтрДлина(ЗначениеОтветаСтр) - ПозРазделителя) > РазмерностьДробнойЧасти Тогда
					Если РазмерностьДробнойЧасти = 0 Тогда
						// Предупреждение о несоответствии формату.
						РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 16), 1, 2);
						Описание = НСтр("ru = 'Значение должно быть целым числом';
										|en = 'Значение должно быть целым числом'");
					Иначе
						// Предупреждение о несоответствии формату.
						РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 16), 1, 2);
						СловоИП = НСтр("ru = 'знак';
										|en = 'знак'"); СловоРПЕЧ = НСтр("ru = 'знака';
																		|en = 'знака'"); СловоРПМЧ = НСтр("ru = 'знаков';
																										|en = 'знаков'");
						Слово = СтрокаСЧислом(";" + СловоИП + ";;" + СловоРПЕЧ + ";" + СловоРПМЧ + ";" + СловоРПЕЧ,
							РазмерностьДробнойЧасти, ВидЧисловогоЗначения.Количественное, "L=ru");
						Описание = СтрШаблон(НСтр("ru = 'Допустимо %1 %2 после запятой';
													|en = 'Допустимо %1 %2 после запятой'"), СокрЛ(РазмерностьДробнойЧасти), Слово);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли ТипЗначения = "Date" Тогда
			
			Если СтрДлина(ЗначениеОтветаСтр) > 0
			   И РегламентированнаяОтчетностьЗагрузка.ДатаИзСтрокиЛюбогоФормата(ЗначениеОтветаСтр) = '00010101' Тогда
				// Предупреждение о несоответствии формату.
				РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, 16), 1, 2);
				Описание = НСтр("ru = 'Значение поля не соответствует типу <дата>';
								|en = 'Значение поля не соответствует типу <дата>'");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если РезультатПроверки = 0 И СтрДлина(ЗначениеОтветаСтр) > 0 Тогда
		
		ТаблСправочник = Неопределено;
		СправочникиШаблона = Неопределено;
		ВариантПроверки = 0;
		Если ЗначениеЗаполнено(ИмяСправочника) Тогда
			Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("KeyValuePair_Meta", СправочникиШаблона) Тогда
				СправочникиШаблона.Свойство(ИмяСправочника, ТаблСправочник);
				ВариантПроверки = 2;
			КонецЕсли;
		ИначеЕсли ЗначениеЗаполнено(ИмяСправочникаНСИ) Тогда
			Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("NSI_Meta", СправочникиШаблона) Тогда
				СправочникиШаблона.Свойство(ИмяСправочникаНСИ, ТаблСправочник);
				ВариантПроверки = 8;
			КонецЕсли;
		КонецЕсли;
		
		Если ТаблСправочник <> Неопределено Тогда
			Если ТаблСправочник.Найти(ЗначениеОтветаСтр, "Ключ") = Неопределено Тогда
				// Предупреждение об отсутствии в справочнике.
				РезультатПроверки = ?(ТребуетсяПроверка(ВариантыПроверок, ВариантПроверки), 1, 2);
				Описание = НСтр("ru = 'Указанное значение отсутствует в справочнике';
								|en = 'Указанное значение отсутствует в справочнике'");
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	ОбъектОтчета = Форма.ОбъектОтчета(Форма.ИмяФормы);
	ОбъектОтчета.ВыполнитьПроверкуЗначения(
		РезультатПроверки, Описание, ВопросАнкеты, ПараметрыВыгрузки, ЗначениеОтветаСтр, НомСтроки);
	
	Если РезультатПроверки = 1 Тогда
		Описание = "ПРЕДУПРЕЖДЕНИЕ: " + Описание;
	ИначеЕсли РезультатПроверки = 2 Тогда
		Описание = "ОШИБКА: " + Описание;
	КонецЕсли;
	
	Если РезультатПроверки > 0 Тогда
		ЗаписатьСообщениеОбОшибке(ВопросАнкеты, ПараметрыВыгрузки, Описание, НомСтроки);
	КонецЕсли;
	Если ЗначениеЗаполнено(ЗначениеОтветаСтр) Тогда
		ЗаписатьЗначениеОтвета(ВопросАнкеты, ПараметрыВыгрузки, ЗначениеОтветаСтр, НомСтроки);
	КонецЕсли;
	
	Возврат РезультатПроверки;
	
КонецФункции

Функция ЗначениеПоФорматуВопроса(Знач Значение, ВопросАнкеты, ПараметрыВыгрузки) Экспорт
	
	ИмяВопроса               = ВопросАнкеты["QUESTION_NAME_ID"];
	ТипЗначения              = ВопросАнкеты["QUESTION_VALUE_TYPE"];
	РазмерностьДробнойЧасти  = ВопросАнкеты["QUESTION_FRACTION_SIZE"];
	ИмяСправочника           = ВопросАнкеты["QUESTION_DICTNAMEID"];
	ИмяСправочникаНСИ        = ВопросАнкеты["QUESTION_NSI"];
	
	ПредставлениеСправочника = "";
	КолонкиАнкеты = ВопросАнкеты.Владелец().Колонки;
	КолонкаПредставлениеСправочника = КолонкиАнкеты.Найти("QUESTION_NSIVIEWTYPE");
	Если КолонкаПредставлениеСправочника = Неопределено Тогда
		КолонкаПредставлениеСправочника = КолонкиАнкеты.Найти("QUESTION_NSIVIEW");
	КонецЕсли;
	Если КолонкаПредставлениеСправочника <> Неопределено Тогда
		ПредставлениеСправочника = ВопросАнкеты[КолонкаПредставлениеСправочника.Имя];
	КонецЕсли;
	
	ОбязательностьЗаполнения = ВопросАнкеты["QUESTION_IS_MANDATORY"] = "True";
	ДопПроверкаЧисла         = СокрЛП(ВопросАнкеты["QUESTION_LOGICCONTROL"]);
	
	Если НЕ ЗначениеЗаполнено(Значение)
		 И (СтрЧислоВхождений(ИмяВопроса, "RowID") = 1 ИЛИ СтрЧислоВхождений(ИмяВопроса, "RowNum") = 1)
		 И  ВопросАнкеты["QUESTION_TYPE"] = "TABLE" Тогда
		Возврат "";
	КонецЕсли;
	
	Если ОбязательностьЗаполнения И ТипЗначения = "Numeric"
	  И (СтрНайти(ДопПроверкаЧисла, "0") > 0 ИЛИ ПустаяСтрока(ДопПроверкаЧисла)) Тогда
		СтрокаФормата = "ЧН=; ЧГ=";
	Иначе
		СтрокаФормата = "ЧГ=";
	КонецЕсли;
	Если НЕ ПустаяСтрока(РазмерностьДробнойЧасти) Тогда
		СтрокаФормата = "ЧДЦ=" + СокрЛП(РазмерностьДробнойЧасти) + "; " + СтрокаФормата;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Число") Тогда
		Значение = Формат(Значение, СтрокаФормата);
	ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда
		Значение = Формат(Значение, "ДФ=dd.MM.yyyy");
	Иначе
		Значение = Строка(Значение);
		Если ТипЗначения = "Numeric" Тогда
			Значение = СтрЗаменить(СтрЗаменить(Значение, " ", ""), Символы.НПП, "");
			Если ОбщегоНазначенияКлиентСервер.ЭтоЧисло(Значение) Тогда
				Значение = Формат(Число(" " + СтрЗаменить(Значение, ",", ".")), СтрокаФормата);
			Иначе
				Значение = "";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Значение = СокрЛП(Значение);
	
	Если (ЗначениеЗаполнено(ИмяСправочника) ИЛИ ЗначениеЗаполнено(ИмяСправочникаНСИ))
		И ЗначениеЗаполнено(Значение) И СокрЛП(ПредставлениеСправочника) <> "1" Тогда
		
		ТаблСправочник = Неопределено;
		СправочникиШаблона = Неопределено;
		Если ЗначениеЗаполнено(ИмяСправочника) Тогда
			Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("KeyValuePair_Meta", СправочникиШаблона) Тогда
				СправочникиШаблона.Свойство(ИмяСправочника, ТаблСправочник);
			КонецЕсли;
		ИначеЕсли ЗначениеЗаполнено(ИмяСправочникаНСИ) Тогда
			Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("NSI_Meta", СправочникиШаблона) Тогда
				СправочникиШаблона.Свойство(ИмяСправочникаНСИ, ТаблСправочник);
			КонецЕсли;
		КонецЕсли;
		
		Если ТаблСправочник <> Неопределено Тогда
			НайденнаяСтрока = ТаблСправочник.Найти(Значение, "Значение");
			Если НайденнаяСтрока <> Неопределено Тогда
				Значение = НайденнаяСтрока.Ключ;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

Функция ТребуетсяПроверка(Знач ВариантыПроверок, ВариантПроверки, Знач МаксимальныйВесРазряда = 16) Экспорт
	
	Если ВариантПроверки > ВариантыПроверок Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Пока МаксимальныйВесРазряда > ВариантыПроверок Цикл
		МаксимальныйВесРазряда = Цел(МаксимальныйВесРазряда / 2);
	КонецЦикла;
	
	ВариантыПроверок = ВариантыПроверок - МаксимальныйВесРазряда;
	Если ВариантыПроверок >= 0 И ВариантПроверки = МаксимальныйВесРазряда Тогда
		Возврат Истина;
	КонецЕсли;
	
	Пока ВариантыПроверок >= ВариантПроверки Цикл
		МаксимальныйВесРазряда = Цел(МаксимальныйВесРазряда / 2);
		ВариантыПроверок = ВариантыПроверок - МаксимальныйВесРазряда;
		Если ВариантыПроверок >= 0 И ВариантПроверки = МаксимальныйВесРазряда Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Процедура ЗаписатьСообщениеОбОшибке(ВопросАнкеты, ПараметрыВыгрузки, Описание, НомСтроки = 0) Экспорт
	
	ТаблицаОшибок = Неопределено;
	Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("Errors_Meta", ТаблицаОшибок) Тогда
		
		ИмяПоказателя = ВопросАнкеты["QUESTION_NAME_ID"];
		ОписаниеПоказателя = ВопросАнкеты["QUESTION_TEXT"];
		
		АдресОшибки = ИмяПоказателя + "#" + Формат(НомСтроки, "ЧН=; ЧГ=");
		МестоОшибки = ?(НомСтроки > 0, "[Cтрока " + Формат(НомСтроки, "ЧГ=") + "] ", "") + ОписаниеПоказателя;
		
		НовСтрока = ТаблицаОшибок.Добавить();
		
		НовСтрока.АдресОшибки    = АдресОшибки;
		НовСтрока.МестоОшибки    = МестоОшибки;
		НовСтрока.ОписаниеОшибки = Описание;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьЗначениеОтвета(ВопросАнкеты, ПараметрыВыгрузки, ЗначениеОтвета, НомСтроки = 0)
	
	ТаблицаОтветов = Неопределено;
	
	Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("Answer_Meta", ТаблицаОтветов) Тогда
		
		КПВопроса = СокрЛП(ВопросАнкеты["QUESTION_KEYFIELD"]);
		
		Если КПВопроса <> "" Тогда
			ЗаписатьДанныеОпросаПоКлючу(ПараметрыВыгрузки, КПВопроса, ЗначениеОтвета);
		КонецЕсли;
		
		ИДВопроса = СокрЛП(ВопросАнкеты["QUESTION_ID"]);
		
		НовСтрока = ТаблицаОтветов.Добавить();
		
		НовСтрока.ИДВопроса      = ИДВопроса;
		НовСтрока.ЗначениеОтвета = ЗначениеОтвета;
		Если НомСтроки > 0 Тогда
			НовСтрока.НомСтрокиЛиста = НомСтроки;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьРезультатФорматноЛогическогоКонтроля(ПараметрыВыгрузки, ЕстьОшибки, ЕстьПредупреждения) Экспорт
	
	КлючРезультата = "FLK";
	
	ЗначениеРезультата = ?(ЕстьОшибки, 2, 1);
	
	ЗаписатьДанныеОпросаПоКлючу(ПараметрыВыгрузки, КлючРезультата, ЗначениеРезультата);
	
КонецПроцедуры

Процедура ЗаписатьДанныеОпросаПоКлючу(ПараметрыВыгрузки, Ключ, Значение) Экспорт
	
	СвойстваОпроса = Неопределено;
	
	Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("Survey_Meta", СвойстваОпроса) Тогда
		
		ЭлементСвойства = НайтиЭлементСпискаПоПредставлению(СвойстваОпроса, Ключ);
		
		Если ЭлементСвойства = Неопределено Тогда
			СвойстваОпроса.Добавить(Значение, Ключ, Истина);
		Иначе
			ЭлементСвойства.Значение = Значение;
			ЭлементСвойства.Пометка = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ЗначениеДанныхОпросаПоКлючу(ПараметрыВыгрузки, Ключ) Экспорт
	
	СвойстваОпроса = Неопределено;
	
	Если ПараметрыВыгрузки.МетаданныеШаблона.Свойство("Survey_Meta", СвойстваОпроса) Тогда
		
		ЭлементСвойства = НайтиЭлементСпискаПоПредставлению(СвойстваОпроса, Ключ);
		
		Если ЭлементСвойства <> Неопределено Тогда
			
			Возврат ЭлементСвойства.Значение;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ФИОСоответствуетТребованиям(ФИО) Экспорт
	
	Возврат СтроковыеФункцииКлиентСерверРФ.ТолькоКириллицаВСтроке(ФИО, Истина, " -.");
	
КонецФункции

Функция КодПоОКПОСоответствуетТребованиям(ОКПО) Экспорт
	
	Перем ЭтоЮридическоеЛицо;
	
	Если СтрДлина(ОКПО) = 8 Тогда
		ЭтоЮридическоеЛицо = Истина;
	ИначеЕсли СтрДлина(ОКПО) = 10 Тогда
		ЭтоЮридическоеЛицо = Ложь;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
	Возврат РегламентированныеДанныеКлиентСервер.КодПоОКПОСоответствуетТребованиям(ОКПО, ЭтоЮридическоеЛицо);
	
КонецФункции

Функция ИННСоответствуетТребованиям(ИНН) Экспорт
	
	Возврат РегламентированнаяОтчетностьВызовСервера.ИННСоответствуетТребованиямНаСервере(ИНН, Ложь);
	
КонецФункции

Функция ОГРНСоответствуетТребованиям(ОГРН) Экспорт
	
	Перем ТекстСообщения;
	
	Возврат РегламентированныеДанныеКлиентСервер.ОГРНСоответствуетТребованиям(ОГРН, Истина, ТекстСообщения);
	
КонецФункции

Функция ОКТМОСоответствуетТребованиям(ОКТМО) Экспорт
	
	Если НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ОКТМО)
		ИЛИ (СтрДлина(ОКТМО) <> 8 И СтрДлина(ОКТМО) <> 11) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция НомерТелефонаСоответствуетТребованиям(СтрокаНомера) Экспорт
	
	ДлинаНомера = СтрДлина(СтрокаНомера);
	
	Для НомСимв = 1 По ДлинаНомера Цикл
		Сим = Сред(СтрокаНомера, НомСимв, 1);
		Если СтрНайти("0123456789()- +", Сим) = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция АдресВебСервераСоответствуетТребованиям(Адрес) Экспорт
	
	ДлинаАдреса  = СтрДлина(Адрес);
	ПозицияТочки = СтрНайти(Адрес, ".", НаправлениеПоиска.СКонца);
	
	Если ДлинаАдреса < 4 ИЛИ ДлинаАдреса - ПозицияТочки < 2 ИЛИ ПозицияТочки < 2 Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат Истина;
	
КонецФункции

Функция АдресЭлектроннойПочтыСоответствуетТребованиям(Адрес) Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.АдресЭлектроннойПочтыСоответствуетТребованиям(Адрес);
	
КонецФункции

Функция СтрокаПредставляетЛокДату(СтрДата) Экспорт
	
	ЧастиСтроки = СтрРазделить(СтрДата, ".");
	
	Если ЧастиСтроки.Количество() <> 3 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтрДлина(ЧастиСтроки[0]) <> 2 ИЛИ НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастиСтроки[0]) Тогда
		Возврат Ложь;
	КонецЕсли;
	Если СтрДлина(ЧастиСтроки[1]) <> 2 ИЛИ НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастиСтроки[1]) Тогда
		Возврат Ложь;
	КонецЕсли;
	Если СтрДлина(ЧастиСтроки[2]) <> 4 ИЛИ НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастиСтроки[2]) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция НетЦифрВСтроке(Стр) Экспорт
	
	Возврат СтрРазделить(Стр, "0123456789", Истина).Количество() <= 1;
	
КонецФункции

// Проверяет правильность кода ценной бумаги по контрольной цифре.
//
// Пример расчета контрольной цифры.
//
// Преобразуем любые латинские буквы в цифры :
// A = 10, G = 16, U = 30, V = 31, X = 33, Z = 35. AU0000XVGZA -> 10 30 0000 33 31 16 35 10
// Соберем нечетные и четные символы в группы:
// 103000003331163510 = (1, 3, 0, 0, 3, 3, 1, 3, 1), (0, 0, 0, 0, 3, 1, 6, 5, 0)
// Умножим цифры группы, содержащей крайний правый символ (это ВТОРАЯ группа) на 2:
// (0, 0, 0, 0, 6, 2, 12, 10, 0)
// Суммируем отдельные цифры:
// (1 + 3 + 0 + 0 + 3 + 3 + 1 + 3 + 1) + (0 + 0 + 0 + 0 + 6 + 2 + (1 + 2) + (1 + 0) + 0) = 27
// Получаем остаток от деления по модулю 10:
// 27 mod 10 = 7
// Вычтем цифру остатка из 10:
// 10 - 7 = 3
// Получаем остаток от деления результата по модулю 10 (этот последний шаг важен в случае,
// когда остаток от деления суммы равен 0, так как результирующее контрольное число будет равно 10):
// 3 mod 10 = 3
// Таким образом, контрольная цифра кода ценной бумаги равна трем.
//
// Параметры:
//  КодЦеннойБумаги - Строка - код для проверки.
//  Описание - Строка - возвращаемое описание ошибки в случае некорректного кода.
//
// Возвращаемое значение:
//  Булево - Истина, если верный.
//
Функция КодЦеннойБумагиСоответствуетТребованиям(Знач КодЦеннойБумаги, ТекстСообщения) Экспорт
	
	ДлинаКода = СтрДлина(КодЦеннойБумаги);
	
	Если ДлинаКода <> 12 Тогда
		ТекстСообщения = НСтр("ru = 'Если данный код является кодом ISIN, то он должен состоять из 12 символов!';
								|en = 'Если данный код является кодом ISIN, то он должен состоять из 12 символов!'");
		Возврат Ложь;
	КонецЕсли;
	
	ПоследнийСимвол = Прав(КодЦеннойБумаги, 1);
	
	Если СтрНайти("0123456789", ПоследнийСимвол) = 0 Тогда
		ТекстСообщения = НСтр("ru = 'Если данный код является кодом ISIN, то последний символ всегда число!';
								|en = 'Если данный код является кодом ISIN, то последний символ всегда число!'");
		Возврат Ложь;
	КонецЕсли;
	
	ОшСим = "";
	Для НС = 1 По 11 Цикл
		Сим = Сред(КодЦеннойБумаги, НС, 1);
		КодСим = КодСимвола(Сим); 
		Если НЕ ((КодСим >= 48 И КодСим <= 57) ИЛИ (КодСим >= 65 И КодСим <= 90) ИЛИ (КодСим >= 97 И КодСим <= 122)) Тогда
			ОшСим = ОшСим + Сим + " ";
		КонецЕсли;
	КонецЦикла;
	
	Если ОшСим <> "" Тогда
		ТекстСообщения = НСтр("ru = 'Если данный код является кодом ISIN, то он содержит некорректные символы: ';
								|en = 'Если данный код является кодом ISIN, то он содержит некорректные символы: '") + ОшСим;
		Возврат Ложь;
	КонецЕсли;
	
	ПоследняяЦифраКода = Число(ПоследнийСимвол);
	
	КодЦеннойБумаги = ВРег(КодЦеннойБумаги);
	
	Цифры = Новый Массив;
	Для НС = 1 По 11 Цикл
		Сим = Сред(КодЦеннойБумаги, НС, 1);
		КодСим = КодСимвола(Сим);
		
		Если КодСим >= 48 И КодСим <= 57 Тогда
			ЧС = Число(Сим);
		Иначе
			ЧС = КодСим - 55;
		КонецЕсли;
		
		Если ЧС > 9 Тогда
			Цифры.Добавить(Цел(ЧС / 10));
			Цифры.Добавить(ЧС % 10);
		Иначе
			Цифры.Добавить(ЧС);
		КонецЕсли;
	КонецЦикла;
	
	СуммаЦифр = 0;
	
	КвоЦифр = Цифры.Количество();
	ПослЧет = (КвоЦифр % 2) = 0;
	Для Инд = 0 По КвоЦифр - 1 Цикл
		ЧС = Цифры[Инд];
		
		ПослЧет = НЕ ПослЧет;
		Если ПослЧет Тогда
			ЧС = ЧС * 2;
			Если ЧС > 9 Тогда
				СуммаЦифр = СуммаЦифр + Цел(ЧС / 10) + (ЧС % 10);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СуммаЦифр = СуммаЦифр + ЧС;
	КонецЦикла; 
	
	КонтрольнаяЦифра = (10 - (СуммаЦифр % 10)) % 10;
	
	Если КонтрольнаяЦифра <> ПоследняяЦифраКода Then
		ТекстСообщения = НСтр("ru = 'Если данный код является кодом ISIN, то он содержит ошибку. Проверьте правильность ввода!';
								|en = 'Если данный код является кодом ISIN, то он содержит ошибку. Проверьте правильность ввода!'");
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция КодЭмитентаСоответствуетТребованиям(Знач КодЭмитента, ТекстСообщения) Экспорт
	
	ДлинаКода = СтрДлина(КодЭмитента);
	
	Если ДлинаКода <> 20 Тогда
		ТекстСообщения = НСтр("ru = 'Код LEI должен состоять из 20 символов!';
								|en = 'Код LEI должен состоять из 20 символов!'");
		Возврат Ложь;
	КонецЕсли;
	
	ЧастиКода = Новый Массив(20);
	
	ОшСим = "";
	Для НС = 1 По 20 Цикл
		Сим = Сред(КодЭмитента, НС, 1);
		КодСим = КодСимвола(Сим); 
		Если НЕ (КодСим >= 48 И КодСим <= 57) Тогда
			Если НЕ ((КодСим >= 65 И КодСим <= 90) ИЛИ (КодСим >= 97 И КодСим <= 122)) Тогда
				ОшСим = ОшСим + Сим + " ";
			КонецЕсли;
			ЧастиКода[НС - 1] = КодСим - 55;
		Иначе
			ЧастиКода[НС - 1] = Число(Сим);
		КонецЕсли;
	КонецЦикла;
	
	Если ОшСим <> "" Тогда
		ТекстСообщения = НСтр("ru = 'Код LEI содержит некорректные символы: ';
								|en = 'Код LEI содержит некорректные символы: '") + ОшСим;
		Возврат Ложь;
	КонецЕсли;
	
	КЦ = 0;
	Для Каждого ЧК Из ЧастиКода Цикл
		Если  ЧК < 10 Then
			КЦ = (КЦ * 10 + ЧК) % 97;
		Иначе
			КЦ = (КЦ * 100 + ЧК) % 97;
		КонецЕсли;
	КонецЦикла;
	
	Если КЦ <> 1 Then
		ТекстСообщения = НСтр("ru = 'Некорректный код. Проверьте правильность кода.';
								|en = 'Некорректный код. Проверьте правильность кода.'");
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#КонецОбласти