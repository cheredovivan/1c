#Область ПрограммныйИнтерфейс

Процедура ДобавитьИнструменты(Инструменты) Экспорт

	ДобавитьИнструментСодержимоеДокумента(Инструменты);

КонецПроцедуры

Функция ВыполнитьИнструмент(ИмяИнструмента, Аргументы) Экспорт

	Попытка
		Если ИмяИнструмента = "get_document_content" Тогда
			Возврат ПолучитьСодержимоеДокумента(Аргументы);
		Иначе
			Возврат СформироватьОтветСОшибкой("UNKNOWN_TOOL", "Неизвестный инструмент: " + ИмяИнструмента);
		КонецЕсли;
	Исключение
		ОписаниеОшибкиТекст = ОписаниеОшибки();
		ПодробноеОписание = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		Попытка
			ЗаписьЖурналаРегистрации("MCP.get_document_content", УровеньЖурналаРегистрации.Ошибка, , , 
				ОписаниеОшибкиТекст + Символы.ПС + ПодробноеОписание);
		Исключение
			// Игнорируем ошибки логирования
		КонецПопытки;
		
		Возврат СформироватьОтветСОшибкой("INTERNAL_ERROR", ОписаниеОшибкиТекст);
	КонецПопытки;

КонецФункции

#КонецОбласти

#Область ОписаниеИнструмента

Процедура ДобавитьИнструментСодержимоеДокумента(Инструменты)

	МассивПараметров = Новый Массив;
	
	// documentType - тип документа (без префикса "Документ.")
	МассивПараметров.Добавить(mcp_Метаданные.ПараметрИнструмента(
		"documentType",
		"string",
		"Имя документа БЕЗ префикса 'Документ.' (например: 'ЗаказПоставщику', 'РеализацияТоваровУслуг')",
		,
		Истина
	));
	
	// searchBy - способ поиска
	МассивПараметров.Добавить(mcp_Метаданные.ПараметрИнструмента(
		"searchBy",
		"string",
		"Способ поиска: 'number' (по номеру), 'ref' (по UUID ссылки)",
		"number",
		Ложь,
		"number,ref"
	));
	
	// searchValue - значение для поиска
	МассивПараметров.Добавить(mcp_Метаданные.ПараметрИнструмента(
		"searchValue",
		"string",
		"Номер документа или UUID ссылки",
		,
		Истина
	));
	
	// date - дата для уточнения поиска
	МассивПараметров.Добавить(mcp_Метаданные.ПараметрИнструмента(
		"date",
		"string",
		"Дата документа для уточнения поиска (формат: YYYY-MM-DD). Опционально."
	));
	
	// includeTabularParts - включить табличные части
	МассивПараметров.Добавить(mcp_Метаданные.ПараметрИнструмента(
		"includeTabularParts",
		"boolean",
		"Включить табличные части документа в результат (по умолчанию true)",
		Истина
	));
	
	// tabularPartsFilter - фильтр табличных частей
	МассивПараметров.Добавить(mcp_Метаданные.ПараметрИнструментаМассив(
		"tabularPartsFilter",
		"string",
		"Список имён табличных частей для выборки. Если не указан - возвращаются все."
	));
	
	// maxTabularRows - лимит строк табличной части
	МассивПараметров.Добавить(mcp_Метаданные.ПараметрИнструмента(
		"maxTabularRows",
		"number",
		"Максимальное количество строк в каждой табличной части (по умолчанию 100)",
		100
	));
	
	СхемаПараметров = mcp_Метаданные.СхемаПараметровИнструмента(МассивПараметров);
	
	mcp_Метаданные.ДобавитьИнструмент(
		Инструменты,
		"get_document_content",
		"Получение полного содержимого документа: шапка + все табличные части. Универсальный инструмент для любого типа документа.",
		СхемаПараметров
	);

КонецПроцедуры

#КонецОбласти

#Область ОсновнаяЛогика

Функция ПолучитьСодержимоеДокумента(Аргументы)

	// Приводим аргументы к структуре
	Если ТипЗнч(Аргументы) = Тип("Соответствие") Тогда
		АргументыСтруктура = Новый Структура;
		Для Каждого КлючЗначение Из Аргументы Цикл
			АргументыСтруктура.Вставить(Строка(КлючЗначение.Ключ), КлючЗначение.Значение);
		КонецЦикла;
		Аргументы = АргументыСтруктура;
	КонецЕсли;
	
	// Извлекаем параметры
	ТипДокумента = ?(Аргументы.Свойство("documentType"), Аргументы.documentType, "");
	СпособПоиска = ?(Аргументы.Свойство("searchBy"), Аргументы.searchBy, "number");
	ЗначениеПоиска = ?(Аргументы.Свойство("searchValue"), Аргументы.searchValue, "");
	ДатаДокумента = ?(Аргументы.Свойство("date"), Аргументы.date, "");
	ВключитьТЧ = ?(Аргументы.Свойство("includeTabularParts"), Аргументы.includeTabularParts, Истина);
	ФильтрТЧ = ?(Аргументы.Свойство("tabularPartsFilter"), Аргументы.tabularPartsFilter, Неопределено);
	МаксСтрокТЧ = ?(Аргументы.Свойство("maxTabularRows"), Аргументы.maxTabularRows, 100);
	
	// Валидация
	Если НЕ ЗначениеЗаполнено(ТипДокумента) Тогда
		Возврат СформироватьОтветСОшибкой("MISSING_PARAMETER", 
			"Не указан параметр documentType",
			"Укажите тип документа, например: 'ЗаказПоставщику'");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ЗначениеПоиска) Тогда
		Возврат СформироватьОтветСОшибкой("MISSING_PARAMETER", 
			"Не указан параметр searchValue",
			"Укажите номер документа или UUID ссылки");
	КонецЕсли;
	
	// Проверяем существование типа документа
	МетаданныеДокумента = Метаданные.Документы.Найти(ТипДокумента);
	Если МетаданныеДокумента = Неопределено Тогда
		Возврат СформироватьОтветСОшибкой("INVALID_DOCUMENT_TYPE", 
			СтрШаблон("Тип документа '%1' не найден в конфигурации", ТипДокумента),
			"Проверьте правильность имени документа. Используйте list_metadata_objects для получения списка документов.");
	КонецЕсли;
	
	// Ищем документ
	РезультатПоиска = НайтиДокумент(ТипДокумента, СпособПоиска, ЗначениеПоиска, ДатаДокумента);
	
	Если НЕ РезультатПоиска.Успешно Тогда
		Возврат СформироватьОтветСОшибкой(РезультатПоиска.КодОшибки, 
			РезультатПоиска.Ошибка, 
			РезультатПоиска.Подсказки);
	КонецЕсли;
	
	ДокументОбъект = РезультатПоиска.Документ;
	
	// Формируем результат
	Результат = Новый Структура;
	Результат.Вставить("success", Истина);
	
	// Шапка документа
	ШапкаДокумента = ПолучитьШапкуДокумента(ДокументОбъект, МетаданныеДокумента);
	Результат.Вставить("document", ШапкаДокумента);
	
	// Табличные части
	Если ВключитьТЧ Тогда
		ТабличныеЧасти = ПолучитьТабличныеЧасти(ДокументОбъект, МетаданныеДокумента, ФильтрТЧ, МаксСтрокТЧ);
		Результат.Вставить("tabularParts", ТабличныеЧасти.Данные);
		
		// Метаданные
		МетаИнфо = Новый Структура;
		МетаИнфо.Вставить("documentType", "Документ." + ТипДокумента);
		МетаИнфо.Вставить("tabularPartsFound", ТабличныеЧасти.Найденные);
		МетаИнфо.Вставить("rowCounts", ТабличныеЧасти.КоличествоСтрок);
		Результат.Вставить("metadata", МетаИнфо);
	КонецЕсли;
	
	// Формируем ответ MCP
	МассивСодержимого = Новый Массив;
	МассивСодержимого.Добавить(mcp_Содержимое.ТекстовоеСодержимое(БезопаснаяСериализацияJSON(Результат)));
	
	Возврат МассивСодержимого;

КонецФункции

#КонецОбласти

#Область ПоискДокумента

Функция НайтиДокумент(ТипДокумента, СпособПоиска, ЗначениеПоиска, ДатаДокумента)
	
	Результат = Новый Структура("Успешно, Документ, КодОшибки, Ошибка, Подсказки", Ложь);
	
	МенеджерДокумента = Документы[ТипДокумента];
	
	// Поиск по UUID
	Если СпособПоиска = "ref" Тогда
		Попытка
			УИД = Новый УникальныйИдентификатор(ЗначениеПоиска);
			СсылкаДокумента = МенеджерДокумента.ПолучитьСсылку(УИД);
			ДокументОбъект = СсылкаДокумента.ПолучитьОбъект();
			Если ДокументОбъект = Неопределено Тогда
				Результат.КодОшибки = "NOT_FOUND";
				Результат.Ошибка = СтрШаблон("Документ с UUID '%1' не найден", ЗначениеПоиска);
				Результат.Подсказки = "Проверьте правильность UUID ссылки";
				Возврат Результат;
			КонецЕсли;
			Результат.Успешно = Истина;
			Результат.Документ = ДокументОбъект;
			Возврат Результат;
		Исключение
			Результат.КодОшибки = "INVALID_UUID";
			Результат.Ошибка = СтрШаблон("Некорректный UUID: '%1'", ЗначениеПоиска);
			Результат.Подсказки = "Укажите корректный UUID в формате XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
			Возврат Результат;
		КонецПопытки;
	КонецЕсли;
	
	// Поиск по номеру
	Запрос = Новый Запрос;
	
	// Формируем условия
	ТекстУсловий = "Док.Номер ПОДОБНО &Номер";
	Запрос.УстановитьПараметр("Номер", "%" + ЗначениеПоиска);
	
	// Добавляем условие по дате, если указана
	Если ЗначениеЗаполнено(ДатаДокумента) Тогда
		Попытка
			ДатаЗначение = mcp_ОбщегоНазначения.ПреобразоватьДатуИзJSON(ДатаДокумента);
			Если ЗначениеЗаполнено(ДатаЗначение) Тогда
				ТекстУсловий = ТекстУсловий + " И Док.Дата >= &ДатаНачала И Док.Дата <= &ДатаОкончания";
				Запрос.УстановитьПараметр("ДатаНачала", НачалоДня(ДатаЗначение));
				Запрос.УстановитьПараметр("ДатаОкончания", КонецДня(ДатаЗначение));
			КонецЕсли;
		Исключение
			// Игнорируем ошибки парсинга даты
		КонецПопытки;
	КонецЕсли;
	
	Запрос.Текст = СтрШаблон(
		"ВЫБРАТЬ
		|	Док.Ссылка КАК Ссылка,
		|	Док.Номер КАК Номер,
		|	Док.Дата КАК Дата
		|ИЗ
		|	Документ.%1 КАК Док
		|ГДЕ
		|	%2
		|УПОРЯДОЧИТЬ ПО
		|	Док.Дата УБЫВ", ТипДокумента, ТекстУсловий);
	
	Попытка
		РезультатЗапроса = Запрос.Выполнить();
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если mcp_ОбщегоНазначения.ЭтоОшибкаПравДоступа(ТекстОшибки) Тогда
			Результат.КодОшибки = "ACCESS_DENIED";
			Результат.Ошибка = mcp_ОбщегоНазначения.СформироватьСообщениеОбОшибкеПрав(ТекстОшибки);
			Результат.Подсказки = "Обратитесь к администратору для получения доступа к документам этого типа.";
		Иначе
			Результат.КодОшибки = "QUERY_ERROR";
			Результат.Ошибка = СтрШаблон("Ошибка поиска документа: %1", ТекстОшибки);
		КонецЕсли;
		Возврат Результат;
	КонецПопытки;
	
	Если РезультатЗапроса.Пустой() Тогда
		Результат.КодОшибки = "NOT_FOUND";
		Результат.Ошибка = СтрШаблон("Документ '%1' с номером '%2' не найден", ТипДокумента, ЗначениеПоиска);
		Результат.Подсказки = "Проверьте номер документа. Если номер содержит дефис, убедитесь что указан полный номер.";
		Возврат Результат;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	
	// Проверяем количество найденных
	КоличествоНайденных = 0;
	Пока Выборка.Следующий() Цикл
		КоличествоНайденных = КоличествоНайденных + 1;
	КонецЦикла;
	
	Если КоличествоНайденных > 1 И НЕ ЗначениеЗаполнено(ДатаДокумента) Тогда
		// Несколько документов - просим уточнить дату
		Выборка.Сбросить();
		СписокДат = "";
		СчетчикСтрок = 0;
		Пока Выборка.Следующий() И СчетчикСтрок < 5 Цикл
			СчетчикСтрок = СчетчикСтрок + 1;
			СписокДат = СписокДат + Формат(Выборка.Дата, "ДФ=dd.MM.yyyy") + ", ";
		КонецЦикла;
		СписокДат = Лев(СписокДат, СтрДлина(СписокДат) - 2);
		
		Результат.КодОшибки = "MULTIPLE_FOUND";
		Результат.Ошибка = СтрШаблон("Найдено %1 документов с номером '%2'", КоличествоНайденных, ЗначениеПоиска);
		Результат.Подсказки = СтрШаблон("Уточните дату документа. Найденные даты: %1", СписокДат);
		Возврат Результат;
	КонецЕсли;
	
	// Берём первый (самый свежий) документ
	Выборка.Сбросить();
	Выборка.Следующий();
	
	ДокументОбъект = Выборка.Ссылка.ПолучитьОбъект();
	Если ДокументОбъект = Неопределено Тогда
		Результат.КодОшибки = "NOT_FOUND";
		Результат.Ошибка = "Документ не найден (возможно, удалён)";
		Возврат Результат;
	КонецЕсли;
	
	Результат.Успешно = Истина;
	Результат.Документ = ДокументОбъект;
	Возврат Результат;

КонецФункции

#КонецОбласти

#Область ФормированиеРезультата

Функция ПолучитьШапкуДокумента(ДокументОбъект, МетаданныеДокумента)
	
	Шапка = Новый Структура;
	
	// Стандартные реквизиты
	Шапка.Вставить("Ссылка", Строка(ДокументОбъект.Ссылка.УникальныйИдентификатор()));
	Шапка.Вставить("Номер", ДокументОбъект.Номер);
	Шапка.Вставить("Дата", Формат(ДокументОбъект.Дата, "ДФ=yyyy-MM-ddTHH:mm:ss"));
	Шапка.Вставить("Проведен", ДокументОбъект.Проведен);
	Шапка.Вставить("ПометкаУдаления", ДокументОбъект.ПометкаУдаления);
	
	// Реквизиты документа
	Для Каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		Попытка
			Значение = ДокументОбъект[Реквизит.Имя];
			Шапка.Вставить(Реквизит.Имя, ПреобразоватьЗначениеДляJSON(Значение));
		Исключение
			// Пропускаем недоступные реквизиты
		КонецПопытки;
	КонецЦикла;
	
	Возврат Шапка;

КонецФункции

Функция ПолучитьТабличныеЧасти(ДокументОбъект, МетаданныеДокумента, ФильтрТЧ, МаксСтрокТЧ)
	
	Результат = Новый Структура;
	Результат.Вставить("Данные", Новый Структура);
	Результат.Вставить("Найденные", Новый Массив);
	Результат.Вставить("КоличествоСтрок", Новый Структура);
	
	// Преобразуем фильтр в массив, если нужно
	МассивФильтра = Неопределено;
	Если ФильтрТЧ <> Неопределено Тогда
		Если ТипЗнч(ФильтрТЧ) = Тип("Массив") Тогда
			МассивФильтра = ФильтрТЧ;
		ИначеЕсли ТипЗнч(ФильтрТЧ) = Тип("Строка") Тогда
			МассивФильтра = СтрРазделить(ФильтрТЧ, ",");
		КонецЕсли;
	КонецЕсли;
	
	// Перебираем табличные части из метаданных
	Для Каждого МетаТЧ Из МетаданныеДокумента.ТабличныеЧасти Цикл
		ИмяТЧ = МетаТЧ.Имя;
		
		// Проверяем фильтр
		Если МассивФильтра <> Неопределено Тогда
			Пропустить = Истина;
			Для Каждого ИмяФильтра Из МассивФильтра Цикл
				Если СокрЛП(ИмяФильтра) = ИмяТЧ Тогда
					Пропустить = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Пропустить Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Результат.Найденные.Добавить(ИмяТЧ);
		
		// Получаем данные табличной части
		ТЧДанные = Новый Массив;
		ТабличнаяЧасть = ДокументОбъект[ИмяТЧ];
		КоличествоСтрок = Мин(ТабличнаяЧасть.Количество(), МаксСтрокТЧ);
		
		Для НомерСтроки = 0 По КоличествоСтрок - 1 Цикл
			СтрокаТЧ = ТабличнаяЧасть[НомерСтроки];
			СтрокаДанных = Новый Структура;
			СтрокаДанных.Вставить("НомерСтроки", НомерСтроки + 1);
			
			// Добавляем все колонки табличной части
			Для Каждого Колонка Из МетаТЧ.Реквизиты Цикл
				Попытка
					Значение = СтрокаТЧ[Колонка.Имя];
					СтрокаДанных.Вставить(Колонка.Имя, ПреобразоватьЗначениеДляJSON(Значение));
				Исключение
					// Пропускаем недоступные колонки
				КонецПопытки;
			КонецЦикла;
			
			ТЧДанные.Добавить(СтрокаДанных);
		КонецЦикла;
		
		Результат.Данные.Вставить(ИмяТЧ, ТЧДанные);
		Результат.КоличествоСтрок.Вставить(ИмяТЧ, ТабличнаяЧасть.Количество());
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

Функция ПреобразоватьЗначениеДляJSON(Значение)
	
	Если Значение = Неопределено ИЛИ Значение = Null Тогда
		Возврат "";
	КонецЕсли;
	
	ТипЗначения = ТипЗнч(Значение);
	
	// Примитивные типы
	Если ТипЗначения = Тип("Строка") 
		ИЛИ ТипЗначения = Тип("Число") 
		ИЛИ ТипЗначения = Тип("Булево") Тогда
		Возврат Значение;
	КонецЕсли;
	
	// Дата
	Если ТипЗначения = Тип("Дата") Тогда
		Возврат Формат(Значение, "ДФ=yyyy-MM-ddTHH:mm:ss");
	КонецЕсли;
	
	// Ссылочные типы и перечисления - приводим к строковому представлению
	// Проверяем по имени типа
	ИмяТипа = Строка(ТипЗначения);
	Если СтрНачинаетсяС(ИмяТипа, "Справочник")
		ИЛИ СтрНачинаетсяС(ИмяТипа, "Документ")
		ИЛИ СтрНачинаетсяС(ИмяТипа, "ПеречислениеСсылка")
		ИЛИ СтрНачинаетсяС(ИмяТипа, "СправочникСсылка")
		ИЛИ СтрНачинаетсяС(ИмяТипа, "ДокументСсылка")
		ИЛИ СтрНачинаетсяС(ИмяТипа, "ПланВидов")
		ИЛИ СтрНачинаетсяС(ИмяТипа, "Задача")
		ИЛИ СтрНачинаетсяС(ИмяТипа, "БизнесПроцесс")
		ИЛИ СтрНачинаетсяС(ИмяТипа, "ПланОбмена") Тогда
		Если ЗначениеЗаполнено(Значение) Тогда
			Возврат Строка(Значение);
		Иначе
			Возврат "";
		КонецЕсли;
	КонецЕсли;
	
	// Остальное - приводим к строке
	Возврат Строка(Значение);

КонецФункции

#КонецОбласти

#Область Вспомогательные

// Безопасная сериализация структуры в JSON
// Рекурсивно преобразует все значения в типы, поддерживаемые JSON
Функция БезопаснаяСериализацияJSON(Объект)
	
	// Сначала преобразуем объект в безопасную структуру
	БезопасныйОбъект = ПреобразоватьОбъектДляJSON(Объект);
	
	// Теперь сериализуем
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, БезопасныйОбъект);
	
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

// Рекурсивно преобразует объект для безопасной JSON-сериализации
Функция ПреобразоватьОбъектДляJSON(Объект)
	
	Если Объект = Неопределено ИЛИ Объект = Null Тогда
		Возврат "";
	КонецЕсли;
	
	ТипОбъекта = ТипЗнч(Объект);
	
	// Примитивные типы
	Если ТипОбъекта = Тип("Строка") 
		ИЛИ ТипОбъекта = Тип("Число") 
		ИЛИ ТипОбъекта = Тип("Булево") Тогда
		Возврат Объект;
	КонецЕсли;
	
	// Дата
	Если ТипОбъекта = Тип("Дата") Тогда
		Возврат Формат(Объект, "ДФ=yyyy-MM-ddTHH:mm:ss");
	КонецЕсли;
	
	// Структура
	Если ТипОбъекта = Тип("Структура") Тогда
		НоваяСтруктура = Новый Структура;
		Для Каждого КлючЗначение Из Объект Цикл
			НоваяСтруктура.Вставить(КлючЗначение.Ключ, ПреобразоватьОбъектДляJSON(КлючЗначение.Значение));
		КонецЦикла;
		Возврат НоваяСтруктура;
	КонецЕсли;
	
	// Соответствие
	Если ТипОбъекта = Тип("Соответствие") Тогда
		НовоеСоответствие = Новый Соответствие;
		Для Каждого КлючЗначение Из Объект Цикл
			НовоеСоответствие.Вставить(Строка(КлючЗначение.Ключ), ПреобразоватьОбъектДляJSON(КлючЗначение.Значение));
		КонецЦикла;
		Возврат НовоеСоответствие;
	КонецЕсли;
	
	// Массив
	Если ТипОбъекта = Тип("Массив") Тогда
		НовыйМассив = Новый Массив;
		Для Каждого Элемент Из Объект Цикл
			НовыйМассив.Добавить(ПреобразоватьОбъектДляJSON(Элемент));
		КонецЦикла;
		Возврат НовыйМассив;
	КонецЕсли;
	
	// Остальное - приводим к строке
	Возврат Строка(Объект);
	
КонецФункции

Функция СформироватьОтветСОшибкой(КодОшибки, ТекстОшибки, Подсказки = Неопределено)
	
	Результат = Новый Структура;
	Результат.Вставить("success", Ложь);
	Результат.Вставить("error", ТекстОшибки);
	Результат.Вставить("errorCode", КодОшибки);
	
	Если Подсказки <> Неопределено Тогда
		Если ТипЗнч(Подсказки) = Тип("Массив") Тогда
			Результат.Вставить("suggestions", Подсказки);
		Иначе
			МассивПодсказок = Новый Массив;
			МассивПодсказок.Добавить(Строка(Подсказки));
			Результат.Вставить("suggestions", МассивПодсказок);
		КонецЕсли;
	КонецЕсли;
	
	МассивСодержимого = Новый Массив;
	МассивСодержимого.Добавить(mcp_Содержимое.ТекстовоеСодержимое(БезопаснаяСериализацияJSON(Результат)));
	
	Возврат МассивСодержимого;

КонецФункции

#КонецОбласти

