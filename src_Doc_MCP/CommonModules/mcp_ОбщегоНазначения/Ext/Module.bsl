// Репозиторий проекта: 
// https://github.com/vladimir-kharin/1c_mcp
// 
// Харин Владимир (С) 2025. https://vharin.ru
// Telegram - https://t.me/vladimir_kharin

#Область ПрограммныйИнтерфейс

// Преобразует строку в формате JSON в структуру.
// 
// Параметры:
//  СтрокаJSON - Строка - строка в формате JSON.
// 
// Возвращаемое значение:
//  Структура -
Функция JSONВСтруктуру(СтрокаJSON) Экспорт
	// Выделяем в строке JSON часть именно JSON
	// Находим позицию первого открывающего фигурного скобки
	ПозицияНачала = СтрНайти(СтрокаJSON, "{");
	Если ПозицияНачала = 0 Тогда
		// Если не найдено, возвращаем Неопределено или можно вызвать ошибку
		Возврат Неопределено;
	КонецЕсли;

	// Находим позицию последнего закрывающего фигурного скобки, используя поиск с конца
	ПозицияКонца = СтрНайти(СтрокаJSON, "}", НаправлениеПоиска.СКонца);
	Если ПозицияКонца = 0 Тогда
		// Если закрывающая скобка не найдена, возвращаем Неопределено
		Возврат Неопределено;
	КонецЕсли;

	// Вычисляем длину фрагмента с JSON: от первого "{" до последнего "}" включительно
	ДлинаФрагмента = ПозицияКонца - ПозицияНачала + 1;

	// Извлекаем корректную часть JSON из строки
	ЧистыйJSON = Сред(СтрокаJSON, ПозицияНачала, ДлинаФрагмента);

	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ЧистыйJSON);

	Попытка
		// Пытаемся прочитать JSON в структуру
		Результат = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		Возврат Результат;
	Исключение
		// Если не удалось, то читаем в соответствие
		ЧтениеJSON.Закрыть();

		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ЧистыйJSON);

		Соответствие = ПрочитатьJSON(ЧтениеJSON, Истина);
		ЧтениеJSON.Закрыть();

		// Преобразуем соответствие в структуру с нормализацией ключей
		Возврат СоответствиеВСтруктуруСНормализациейКлючей(Соответствие);
	КонецПопытки;
КонецФункции

// Разбирает URL на составляющие: схема, хост, порт и путь
// 
// Параметры:
//  URL - Строка - URL для разбора
// 
// Возвращаемое значение:
//  Структура - Разобранные части URL (схема, хост, порт, путь)
Функция РазобратьURL(Знач URL) Экспорт
	РезультатРазбора = Новый Структура("Схема, Хост, Порт, Путь");
	    
	    // Проверка и удаление протокола
	    Если НРег(Лев(URL, 8)) = "https://" Тогда
	        РезультатРазбора.Схема = "https";
	        URL = Сред(URL, 9);
	    ИначеЕсли НРег(Лев(URL, 7)) = "http://" Тогда
	        РезультатРазбора.Схема = "http";
	        URL = Сред(URL, 8);
	    Иначе
	        ВызватьИсключение "Неверный формат URL: отсутствует протокол http или https";
	    КонецЕсли;
	    
	    // Разделение хоста, порта и пути
	    ПозицияСлеш = СтрНайти(URL, "/");
	    Если ПозицияСлеш > 0 Тогда
	        ХостИПорт = Лев(URL, ПозицияСлеш - 1);
	        РезультатРазбора.Путь = Сред(URL, ПозицияСлеш);
	    Иначе
	        ХостИПорт = URL;
	        РезультатРазбора.Путь = "/";
	    КонецЕсли;
	    
	    // Разделение хоста и порта
	    ПозицияДвоеточие = СтрНайти(ХостИПорт, ":");
	    Если ПозицияДвоеточие > 0 Тогда
	        РезультатРазбора.Хост = Лев(ХостИПорт, ПозицияДвоеточие - 1);
	        РезультатРазбора.Порт = Число(Сред(ХостИПорт, ПозицияДвоеточие + 1));
	    Иначе
	        РезультатРазбора.Хост = ХостИПорт;
	        РезультатРазбора.Порт = ?(РезультатРазбора.Схема = "https", 443, 80);
	    КонецЕсли;
	    
	    Возврат РезультатРазбора;
КонецФункции

// Преобразует структура в строку JSON
// 
// Параметры:
//  Объект - Структура - которую необходимо преобразовать в строку JSON.
// 
// Возвращаемое значение:
//  Строка - в формате JSON.
Функция СтруктураВJSON(Объект) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Объект);
	
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

// Форматирует значение в строку для вывода
//
// Параметры:
//  Значение - Произвольный - значение для форматирования
//
// Возвращаемое значение:
//  Строка - отформатированное значение
Функция ФорматироватьЗначение(Значение) Экспорт
	
	Если ТипЗнч(Значение) = Тип("Булево") Тогда
		Возврат ?(Значение, "Да", "Нет");
	ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда
		Возврат Формат(Значение, "ДФ=dd.MM.yyyy HH:mm:ss");
	ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
		Возврат Формат(Значение, "ЧГ=");
	ИначеЕсли Значение = Неопределено Тогда
		Возврат "";
	Иначе
		Возврат Строка(Значение);
	КонецЕсли;
	
КонецФункции

// Преобразует результат запроса в Markdown таблицу
//
// Параметры:
//  РезультатЗапроса - РезультатЗапроса - результат выполнения запроса
//  МаксСтрок - Число - максимальное количество строк (по умолчанию 1000)
//
// Возвращаемое значение:
//  Строка - Markdown таблица
Функция РезультатЗапросаВMarkdown(РезультатЗапроса, МаксСтрок = 1000) Экспорт
	
	Выборка = РезультатЗапроса.Выбрать();
	
	// Получаем имена колонок
	Колонки = РезультатЗапроса.Колонки;
	МассивКолонок = Новый Массив;
	Для Каждого Колонка Из Колонки Цикл
		МассивКолонок.Добавить(Колонка.Имя);
	КонецЦикла;
	
	Если МассивКолонок.Количество() = 0 Тогда
		Возврат "Запрос выполнен успешно. Результатов не найдено.";
	КонецЕсли;
	
	// Формируем заголовок таблицы
	МассивСтрок = Новый Массив;
	СтрокаЗаголовка = "| " + СтрСоединить(МассивКолонок, " | ") + " |";
	МассивСтрок.Добавить(СтрокаЗаголовка);
	
	// Разделитель заголовка
	МассивРазделителей = Новый Массив;
	Пока МассивРазделителей.Количество() < МассивКолонок.Количество() Цикл
		МассивРазделителей.Добавить("---");
	КонецЦикла;
	МассивСтрок.Добавить("| " + СтрСоединить(МассивРазделителей, " | ") + " |");
	
	// Формируем строки данных
	Счетчик = 0;
	Пока Выборка.Следующий() И Счетчик < МаксСтрок Цикл
		
		МассивЗначений = Новый Массив;
		Для Каждого ИмяКолонки Из МассивКолонок Цикл
			Значение = Выборка[ИмяКолонки];
			СтрокаЗначения = ФорматироватьЗначение(Значение);
			// Экранируем символы для Markdown
			СтрокаЗначения = СтрЗаменить(СтрокаЗначения, "|", "\|");
			МассивЗначений.Добавить(СтрокаЗначения);
		КонецЦикла;
		
		СтрокаДанных = "| " + СтрСоединить(МассивЗначений, " | ") + " |";
		МассивСтрок.Добавить(СтрокаДанных);
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	// Если нет данных, добавляем сообщение
	Если Счетчик = 0 Тогда
		// Формируем строку с сообщением, которая занимает все колонки
		МассивПустыхЯчеек = Новый Массив;
		Пока МассивПустыхЯчеек.Количество() < МассивКолонок.Количество() - 1 Цикл
			МассивПустыхЯчеек.Добавить("");
		КонецЦикла;
		СтрокаСообщения = "| *Запрос выполнен успешно. Результатов не найдено.*";
		Если МассивПустыхЯчеек.Количество() > 0 Тогда
			СтрокаСообщения = СтрокаСообщения + " | " + СтрСоединить(МассивПустыхЯчеек, " | ") + " |";
		Иначе
			СтрокаСообщения = СтрокаСообщения + " |";
		КонецЕсли;
		МассивСтрок.Добавить(СтрокаСообщения);
	КонецЕсли;
	
	Результат = СтрСоединить(МассивСтрок, Символы.ПС);
	
	Если Счетчик >= МаксСтрок Тогда
		Результат = Результат + Символы.ПС + Символы.ПС + СтрШаблон("*(Показано максимум %1 строк из результата запроса)*", МаксСтрок);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Преобразует результат запроса в JSON структуру
//
// Параметры:
//  РезультатЗапроса - РезультатЗапроса - результат выполнения запроса
//  МаксСтрок - Число - максимальное количество строк (по умолчанию 1000)
//  ВключитьСхему - Булево - включить схему колонок в результат
//
// Возвращаемое значение:
//  Структура - содержит поля columns (массив колонок) и rows (массив строк)
Функция РезультатЗапросаВJSON(РезультатЗапроса, МаксСтрок = 1000, ВключитьСхему = Ложь) Экспорт
	
	Выборка = РезультатЗапроса.Выбрать();
	
	// Получаем имена колонок
	Колонки = РезультатЗапроса.Колонки;
	МассивКолонок = Новый Массив;
	МассивКолонокСоСхемой = Новый Массив;
	Для Каждого Колонка Из Колонки Цикл
		МассивКолонок.Добавить(Колонка.Имя);
		Если ВключитьСхему Тогда
			КолонкаСхема = Новый Структура;
			КолонкаСхема.Вставить("name", Колонка.Имя);
			КолонкаСхема.Вставить("type", Строка(Колонка.ТипЗначения));
			МассивКолонокСоСхемой.Добавить(КолонкаСхема);
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Структура;
	
	Если ВключитьСхему Тогда
		Результат.Вставить("columns", МассивКолонокСоСхемой);
	Иначе
		Результат.Вставить("columns", МассивКолонок);
	КонецЕсли;
	
	// Формируем строки данных
	МассивСтрок = Новый Массив;
	Счетчик = 0;
	Пока Выборка.Следующий() И Счетчик < МаксСтрок Цикл
		
		СтрокаДанных = Новый Структура;
		Для Каждого ИмяКолонки Из МассивКолонок Цикл
			Значение = Выборка[ИмяКолонки];
			// Преобразуем значение в JSON-совместимый формат
			Если ТипЗнч(Значение) = Тип("Булево") Тогда
				СтрокаДанных.Вставить(ИмяКолонки, Значение);
			ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда
				СтрокаДанных.Вставить(ИмяКолонки, Формат(Значение, "ДФ=yyyy-MM-ddTHH:mm:ss"));
			ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
				СтрокаДанных.Вставить(ИмяКолонки, Значение);
			ИначеЕсли Значение = Неопределено Тогда
				СтрокаДанных.Вставить(ИмяКолонки, "");
			Иначе
				СтрокаДанных.Вставить(ИмяКолонки, Строка(Значение));
			КонецЕсли;
		КонецЦикла;
		
		МассивСтрок.Добавить(СтрокаДанных);
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Результат.Вставить("rows", МассивСтрок);
	
	Если Счетчик >= МаксСтрок Тогда
		Результат.Вставить("truncated", Истина);
		Результат.Вставить("maxRows", МаксСтрок);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Преобразует таблицу значений в Markdown таблицу
//
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений - таблица значений
//  МаксСтрок - Число - максимальное количество строк (по умолчанию 1000)
//
// Возвращаемое значение:
//  Строка - Markdown таблица
Функция ТаблицаЗначенийВMarkdown(ТаблицаЗначений, МаксСтрок = 1000) Экспорт
	
	Если ТаблицаЗначений.Количество() = 0 Тогда
		Возврат "Данные не найдены.";
	КонецЕсли;
	
	// Получаем имена колонок
	МассивКолонок = Новый Массив;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		МассивКолонок.Добавить(Колонка.Имя);
	КонецЦикла;
	
	// Формируем заголовок таблицы
	МассивСтрок = Новый Массив;
	СтрокаЗаголовка = "| " + СтрСоединить(МассивКолонок, " | ") + " |";
	МассивСтрок.Добавить(СтрокаЗаголовка);
	
	// Разделитель заголовка
	МассивРазделителей = Новый Массив;
	Пока МассивРазделителей.Количество() < МассивКолонок.Количество() Цикл
		МассивРазделителей.Добавить("---");
	КонецЦикла;
	МассивСтрок.Добавить("| " + СтрСоединить(МассивРазделителей, " | ") + " |");
	
	// Формируем строки данных
	Счетчик = 0;
	Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		
		Если Счетчик >= МаксСтрок Тогда
			Прервать;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Для Каждого ИмяКолонки Из МассивКолонок Цикл
			Значение = СтрокаТаблицы[ИмяКолонки];
			СтрокаЗначения = ФорматироватьЗначение(Значение);
			// Экранируем символы для Markdown
			СтрокаЗначения = СтрЗаменить(СтрокаЗначения, "|", "\|");
			МассивЗначений.Добавить(СтрокаЗначения);
		КонецЦикла;
		
		СтрокаДанных = "| " + СтрСоединить(МассивЗначений, " | ") + " |";
		МассивСтрок.Добавить(СтрокаДанных);
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Результат = СтрСоединить(МассивСтрок, Символы.ПС);
	
	Если Счетчик >= МаксСтрок И Счетчик < ТаблицаЗначений.Количество() Тогда
		Результат = Результат + Символы.ПС + Символы.ПС + СтрШаблон("*(Показано максимум %1 строк из %2)*", МаксСтрок, ТаблицаЗначений.Количество());
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Преобразует таблицу значений в JSON структуру
//
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений - таблица значений
//  МаксСтрок - Число - максимальное количество строк (по умолчанию 1000)
//  ВключитьСхему - Булево - включить схему колонок в результат
//
// Возвращаемое значение:
//  Структура - содержит поля columns (массив колонок) и rows (массив строк)
Функция ТаблицаЗначенийВJSON(ТаблицаЗначений, МаксСтрок = 1000, ВключитьСхему = Ложь) Экспорт
	
	// Получаем имена колонок
	МассивКолонок = Новый Массив;
	МассивКолонокСоСхемой = Новый Массив;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		МассивКолонок.Добавить(Колонка.Имя);
		Если ВключитьСхему Тогда
			КолонкаСхема = Новый Структура;
			КолонкаСхема.Вставить("name", Колонка.Имя);
			КолонкаСхема.Вставить("type", Строка(Колонка.ТипЗначения));
			МассивКолонокСоСхемой.Добавить(КолонкаСхема);
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Структура;
	
	Если ВключитьСхему Тогда
		Результат.Вставить("columns", МассивКолонокСоСхемой);
	Иначе
		Результат.Вставить("columns", МассивКолонок);
	КонецЕсли;
	
	// Формируем строки данных
	МассивСтрок = Новый Массив;
	Счетчик = 0;
	Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		
		Если Счетчик >= МаксСтрок Тогда
			Прервать;
		КонецЕсли;
		
		СтрокаДанных = Новый Структура;
		Для Каждого ИмяКолонки Из МассивКолонок Цикл
			Значение = СтрокаТаблицы[ИмяКолонки];
			// Преобразуем значение в JSON-совместимый формат
			Если ТипЗнч(Значение) = Тип("Булево") Тогда
				СтрокаДанных.Вставить(ИмяКолонки, Значение);
			ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда
				СтрокаДанных.Вставить(ИмяКолонки, Формат(Значение, "ДФ=yyyy-MM-ddTHH:mm:ss"));
			ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
				СтрокаДанных.Вставить(ИмяКолонки, Значение);
			ИначеЕсли Значение = Неопределено Тогда
				СтрокаДанных.Вставить(ИмяКолонки, "");
			Иначе
				СтрокаДанных.Вставить(ИмяКолонки, Строка(Значение));
			КонецЕсли;
		КонецЦикла;
		
		МассивСтрок.Добавить(СтрокаДанных);
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Результат.Вставить("rows", МассивСтрок);
	
	Если Счетчик >= МаксСтрок И Счетчик < ТаблицаЗначений.Количество() Тогда
		Результат.Вставить("truncated", Истина);
		Результат.Вставить("maxRows", МаксСтрок);
		Результат.Вставить("totalRows", ТаблицаЗначений.Количество());
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает метаданные объекта по типу и имени
//
// Параметры:
//  МетаТип - Строка - тип объекта метаданных
//  ИмяОбъекта - Строка - имя объекта
//
// Возвращаемое значение:
//  МетаданныеОбъекта - метаданные объекта или Неопределено
Функция ПолучитьМетаданныеОбъекта(МетаТип, ИмяОбъекта) Экспорт
	
	Попытка
		КоллекцияМД = Метаданные[МетаТип];
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	МетаданныеОбъекта = КоллекцияМД.Найти(ИмяОбъекта);
	
	Возврат МетаданныеОбъекта;
	
КонецФункции

// Преобразует объект справочника в таблицу значений
//
// Параметры:
//  ОбъектСправочника - ОбъектСправочника - объект справочника
//  Поля - Массив - список полей для выборки (Неопределено - все поля)
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица с данными объекта
Функция ОбъектСправочникаВТаблицу(ОбъектСправочника, Поля = Неопределено) Экспорт
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	
	// Определяем список полей
	МассивПолей = Новый Массив;
	Если Поля = Неопределено Или ТипЗнч(Поля) <> Тип("Массив") Или Поля.Количество() = 0 Тогда
		// Добавляем все реквизиты
		Для Каждого Реквизит Из ОбъектСправочника.Метаданные().Реквизиты Цикл
			МассивПолей.Добавить(Реквизит.Имя);
		КонецЦикла;
		// Добавляем стандартные реквизиты
		МассивПолей.Добавить("Ссылка");
		МассивПолей.Добавить("Код");
		МассивПолей.Добавить("Наименование");
		МассивПолей.Добавить("ПометкаУдаления");
		МассивПолей.Добавить("Родитель");
	Иначе
		МассивПолей = Поля;
	КонецЕсли;
	
	// Создаем колонки
	Для Каждого ИмяПоля Из МассивПолей Цикл
		ТаблицаДанных.Колонки.Добавить(ИмяПоля);
	КонецЦикла;
	
	// Добавляем строку с данными
	СтрокаДанных = ТаблицаДанных.Добавить();
	Для Каждого ИмяПоля Из МассивПолей Цикл
		Попытка
			СтрокаДанных[ИмяПоля] = ОбъектСправочника[ИмяПоля];
		Исключение
			// Реквизит не существует - пропускаем
			Продолжить;
		КонецПопытки;
	КонецЦикла;
	
	Возврат ТаблицаДанных;
	
КонецФункции

// Преобразует объект документа в таблицу значений
//
// Параметры:
//  ОбъектДокумента - ОбъектДокумента - объект документа
//  Поля - Массив - список полей для выборки (Неопределено - все поля)
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица с данными объекта
Функция ОбъектДокументаВТаблицу(ОбъектДокумента, Поля = Неопределено) Экспорт
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	
	// Определяем список полей
	МассивПолей = Новый Массив;
	Если Поля = Неопределено Или ТипЗнч(Поля) <> Тип("Массив") Или Поля.Количество() = 0 Тогда
		// Добавляем все реквизиты
		Для Каждого Реквизит Из ОбъектДокумента.Метаданные().Реквизиты Цикл
			МассивПолей.Добавить(Реквизит.Имя);
		КонецЦикла;
		// Добавляем стандартные реквизиты
		МассивПолей.Добавить("Ссылка");
		МассивПолей.Добавить("Номер");
		МассивПолей.Добавить("Дата");
		МассивПолей.Добавить("ПометкаУдаления");
	Иначе
		МассивПолей = Поля;
	КонецЕсли;
	
	// Создаем колонки
	Для Каждого ИмяПоля Из МассивПолей Цикл
		ТаблицаДанных.Колонки.Добавить(ИмяПоля);
	КонецЦикла;
	
	// Добавляем строку с данными
	СтрокаДанных = ТаблицаДанных.Добавить();
	Для Каждого ИмяПоля Из МассивПолей Цикл
		Попытка
			СтрокаДанных[ИмяПоля] = ОбъектДокумента[ИмяПоля];
		Исключение
			// Реквизит не существует - пропускаем
			Продолжить;
		КонецПопытки;
	КонецЦикла;
	
	Возврат ТаблицаДанных;
	
КонецФункции

// Преобразует табличную часть в таблицу значений
//
// Параметры:
//  ТабличнаяЧасть - ТабличнаяЧастьДокумента - табличная часть
//  Поля - Массив - список полей для выборки (Неопределено - все поля)
//  МаксСтрок - Число - максимальное количество строк
//  МетаданныеТЧ - МетаданныеОбъекта - метаданные табличной части (опционально)
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица с данными табличной части
Функция ТабличнаяЧастьВТаблицу(ТабличнаяЧасть, Поля = Неопределено, МаксСтрок = 1000, МетаданныеТЧ = Неопределено) Экспорт
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	
	// Определяем список полей
	МассивПолей = Новый Массив;
	Если Поля = Неопределено Или ТипЗнч(Поля) <> Тип("Массив") Или Поля.Количество() = 0 Тогда
		// Добавляем все реквизиты из метаданных
		Если МетаданныеТЧ <> Неопределено Тогда
			Для Каждого Реквизит Из МетаданныеТЧ.Реквизиты Цикл
				МассивПолей.Добавить(Реквизит.Имя);
			КонецЦикла;
		Иначе
			// Если метаданные не переданы, пробуем получить имена полей из первой строки
			Если ТабличнаяЧасть.Количество() > 0 Тогда
				ПерваяСтрока = ТабличнаяЧасть[0];
				// Получаем владельца и его метаданные
				Попытка
					Владелец = ПерваяСтрока.Ссылка;
					Если Владелец <> Неопределено Тогда
						МетаданныеВладельца = Владелец.Метаданные();
						Для Каждого ТЧ Из МетаданныеВладельца.ТабличныеЧасти Цикл
							Попытка
								// Проверяем, это ли нужная табличная часть
								Если Владелец.ПолучитьОбъект()[ТЧ.Имя] = ТабличнаяЧасть Тогда
									Для Каждого Реквизит Из ТЧ.Реквизиты Цикл
										МассивПолей.Добавить(Реквизит.Имя);
									КонецЦикла;
									Прервать;
								КонецЕсли;
							Исключение
								Продолжить;
							КонецПопытки;
						КонецЦикла;
					КонецЕсли;
				Исключение
					// Не удалось получить метаданные - используем типичные поля
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	Иначе
		МассивПолей = Поля;
	КонецЕсли;
	
	// Если поля так и не определены - пробуем типичные поля
	Если МассивПолей.Количество() = 0 Тогда
		МассивПолей.Добавить("Номенклатура");
		МассивПолей.Добавить("Количество");
		МассивПолей.Добавить("Цена");
		МассивПолей.Добавить("Сумма");
	КонецЕсли;
	
	// Создаем колонки
	Для Каждого ИмяПоля Из МассивПолей Цикл
		ТаблицаДанных.Колонки.Добавить(ИмяПоля);
	КонецЦикла;
	
	// Добавляем строки с данными
	Счетчик = 0;
	Для Каждого СтрокаТЧ Из ТабличнаяЧасть Цикл
		
		Если Счетчик >= МаксСтрок Тогда
			Прервать;
		КонецЕсли;
		
		СтрокаДанных = ТаблицаДанных.Добавить();
		Для Каждого ИмяПоля Из МассивПолей Цикл
			Попытка
				СтрокаДанных[ИмяПоля] = СтрокаТЧ[ИмяПоля];
			Исключение
				// Поле не существует — пропускаем
			КонецПопытки;
		КонецЦикла;
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Возврат ТаблицаДанных;
	
КонецФункции

// Строит запрос к регистру
//
// Параметры:
//  МетаданныеОбъекта - МетаданныеОбъекта - метаданные регистра
//  Селектор - Структура - условия выборки (измерения, период, условия)
//  Поля - Массив - список полей для выборки (Неопределено - все поля)
//  МаксСтрок - Число - максимальное количество строк
//
// Возвращаемое значение:
//  Строка - текст запроса
Функция ПостроитьЗапросКРегистру(МетаданныеОбъекта, Селектор = Неопределено, Поля = Неопределено, МаксСтрок = 1000) Экспорт
	
	ИмяРегистра = МетаданныеОбъекта.Имя;
	
	// Определяем тип регистра
	ТипРегистра = "РегистрСведений";
	Если Метаданные.РегистрыНакопления.Содержит(МетаданныеОбъекта) Тогда
		ТипРегистра = "РегистрНакопления";
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(МетаданныеОбъекта) Тогда
		ТипРегистра = "РегистрБухгалтерии";
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(МетаданныеОбъекта) Тогда
		ТипРегистра = "РегистрРасчета";
	КонецЕсли;
	
	// Определяем список полей
	МассивПолей = Новый Массив;
	Если Поля = Неопределено Или ТипЗнч(Поля) <> Тип("Массив") Или Поля.Количество() = 0 Тогда
		// Добавляем измерения
		Для Каждого Измерение Из МетаданныеОбъекта.Измерения Цикл
			МассивПолей.Добавить("Регистр." + Измерение.Имя);
		КонецЦикла;
		// Добавляем ресурсы
		Для Каждого Ресурс Из МетаданныеОбъекта.Ресурсы Цикл
			МассивПолей.Добавить("Регистр." + Ресурс.Имя);
		КонецЦикла;
	Иначе
		Для Каждого ИмяПоля Из Поля Цикл
			МассивПолей.Добавить("Регистр." + ИмяПоля);
		КонецЦикла;
	КонецЕсли;
	
	// Строим запрос
	ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ " + Формат(МаксСтрок, "ЧГ=") + " ";
	
	Если МассивПолей.Количество() > 0 Тогда
		ТекстЗапроса = ТекстЗапроса + СтрСоединить(МассивПолей, ", ");
	Иначе
		ТекстЗапроса = ТекстЗапроса + "Регистр.*";
	КонецЕсли;
	
	ТекстЗапроса = ТекстЗапроса + " ИЗ " + ТипРегистра + "." + ИмяРегистра + " КАК Регистр";
	
	// Добавляем условия из селектора
	Если Селектор <> Неопределено И ТипЗнч(Селектор) = Тип("Структура") Тогда
		Условия = Новый Массив;
		Для Каждого Параметр Из Селектор Цикл
			ИмяПоля = Параметр.Ключ;
			Значение = Параметр.Значение;
			Если ЗначениеЗаполнено(Значение) Тогда
				Условия.Добавить("Регистр." + ИмяПоля + " = &" + ИмяПоля);
			КонецЕсли;
		КонецЦикла;
		Если Условия.Количество() > 0 Тогда
			ТекстЗапроса = ТекстЗапроса + " ГДЕ " + СтрСоединить(Условия, " И ");
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Проверяет, является ли символ буквой.
//
// Параметры:
//  Символ - Строка - символ для проверки.
//
// Возвращаемое значение:
//  Булево - Истина, если символ является буквой.
Функция ЭтоБуква(Символ)

	КодСимвола = КодСимвола(Символ);

	// Латинские буквы A-Z (65-90) и a-z (97-122)
	Если (КодСимвола >= 65 И КодСимвола <= 90)
		Или (КодСимвола >= 97 И КодСимвола <= 122) Тогда
		Возврат Истина;
	КонецЕсли;

	// Кириллические буквы А-Я (1040-1103), включая Ё (1025, 1105)
	Если (КодСимвола >= 1040 И КодСимвола <= 1103)
		Или КодСимвола = 1025
		Или КодСимвола = 1105 Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;

КонецФункции

// Проверяет, является ли символ цифрой.
//
// Параметры:
//  Символ - Строка - символ для проверки.
//
// Возвращаемое значение:
//  Булево - Истина, если символ является цифрой.
Функция ЭтоЦифра(Символ)

	КодСимвола = КодСимвола(Символ);

	// Цифры 0-9 (48-57)
	Возврат КодСимвола >= 48 И КодСимвола <= 57;

КонецФункции

// Нормализует ключ для использования в структуре.
// Заменяет недопустимые символы на "_" и обеспечивает,
// что первый символ - буква или "_".
//
// Параметры:
//  Ключ - Строка - исходный ключ.
//
// Возвращаемое значение:
//  Строка - нормализованный ключ.
Функция НормализоватьКлюч(Ключ)

	Если НЕ ЗначениеЗаполнено(Ключ) Тогда
		Возврат "_";
	КонецЕсли;

	НормализованныйКлюч = "";

	Для Индекс = 1 По СтрДлина(Ключ) Цикл
		Символ = Сред(Ключ, Индекс, 1);

		Если Индекс = 1 Тогда
			// Первый символ должен быть буквой или "_"
			Если ЭтоБуква(Символ) Или Символ = "_" Тогда
				НормализованныйКлюч = НормализованныйКлюч + Символ;
			Иначе
				НормализованныйКлюч = НормализованныйКлюч + "_";
			КонецЕсли;
		Иначе
			// Последующие символы могут быть буквами, цифрами или "_"
			Если ЭтоБуква(Символ) Или ЭтоЦифра(Символ) Или Символ = "_" Тогда
				НормализованныйКлюч = НормализованныйКлюч + Символ;
			Иначе
				НормализованныйКлюч = НормализованныйКлюч + "_";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Возврат НормализованныйКлюч;

КонецФункции

// Преобразует соответствие в структуру с нормализацией ключей.
// Рекурсивно обрабатывает вложенные объекты.
//
// Параметры:
//  Значение - Произвольный - значение для преобразования.
//
// Возвращаемое значение:
//  Произвольный - преобразованное значение.
Функция СоответствиеВСтруктуруСНормализациейКлючей(Значение)

	Если ТипЗнч(Значение) = Тип("Соответствие") Тогда

		Структура = Новый Структура;

		Для Каждого КлючЗначение Из Значение Цикл

			НормализованныйКлюч = НормализоватьКлюч(Строка(КлючЗначение.Ключ));

			// Рекурсивно обрабатываем значение
			ОбработанноеЗначение = СоответствиеВСтруктуруСНормализациейКлючей(КлючЗначение.Значение);

			Структура.Вставить(НормализованныйКлюч, ОбработанноеЗначение);

		КонецЦикла;

		Возврат Структура;

	ИначеЕсли ТипЗнч(Значение) = Тип("Массив") Тогда

		Массив = Новый Массив;

		Для Каждого Элемент Из Значение Цикл
			// Рекурсивно обрабатываем элементы массива
			Массив.Добавить(СоответствиеВСтруктуруСНормализациейКлючей(Элемент));
		КонецЦикла;

		Возврат Массив;

	Иначе

		// Простое значение - возвращаем как есть
		Возврат Значение;

	КонецЕсли;

КонецФункции

#КонецОбласти

#Область ПреобразованиеJSONВОбъекты1С

// Преобразует значение из JSON в тип 1С
//
// Параметры:
//  ЗначениеJSON - Произвольный - значение из JSON
//  РеквизитМД - МетаданныеРеквизита - метаданные реквизита (может быть Неопределено)
//
// Возвращаемое значение:
//  Произвольный - значение в формате 1С
//
Функция ПреобразоватьЗначениеИзJSON(ЗначениеJSON, РеквизитМД = Неопределено)
	
	Если ЗначениеJSON = Неопределено Или ЗначениеJSON = "" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Если есть метаданные реквизита, используем их для преобразования
	Если РеквизитМД <> Неопределено Тогда
		ТипЗначения = РеквизитМД.Тип;
		
		// Сначала проверяем простые типы (они не вызывают ошибок)
		Если ТипЗначения.СодержитТип(Тип("Дата")) Тогда
			Возврат ПреобразоватьДатуИзJSON(ЗначениеJSON);
		ИначеЕсли ТипЗначения.СодержитТип(Тип("Число")) Тогда
			Возврат ПреобразоватьЧислоИзJSON(ЗначениеJSON);
		ИначеЕсли ТипЗначения.СодержитТип(Тип("Булево")) Тогда
			Возврат ПреобразоватьБулевоИзJSON(ЗначениеJSON);
		ИначеЕсли ТипЗначения.СодержитТип(Тип("Строка")) Тогда
			Возврат Строка(ЗначениеJSON);
		Иначе
			// Для ссылочных типов пробуем преобразовать
			Попытка
				Возврат ПреобразоватьСсылкуИзJSON(ЗначениеJSON, ТипЗначения);
			Исключение
				// Если не удалось - возвращаем как есть
				Возврат ЗначениеJSON;
			КонецПопытки;
		КонецЕсли;
	Иначе
		// Пытаемся определить тип по значению
		Если ТипЗнч(ЗначениеJSON) = Тип("Строка") Тогда
			// Пытаемся преобразовать в дату
			Попытка
				Возврат ПреобразоватьДатуИзJSON(ЗначениеJSON);
			Исключение
				// Не дата, возвращаем как строку
				Возврат ЗначениеJSON;
			КонецПопытки;
		ИначеЕсли ТипЗнч(ЗначениеJSON) = Тип("Число") Тогда
			Возврат ЗначениеJSON;
		ИначеЕсли ТипЗнч(ЗначениеJSON) = Тип("Булево") Тогда
			Возврат ЗначениеJSON;
		Иначе
			Возврат ЗначениеJSON;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеJSON;

КонецФункции

// Преобразует строку JSON в ссылку 1С
//
// Параметры:
//  ЗначениеJSON - Строка - UUID ссылки или код/наименование
//  ТипЗначения - ОписаниеТипов - тип ссылки
//
// Возвращаемое значение:
//  Ссылка - ссылка на объект
//
Функция ПреобразоватьСсылкуИзJSON(ЗначениеJSON, ТипЗначения)
	
	Если НЕ ЗначениеЗаполнено(ЗначениеJSON) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеJSON) <> Тип("Строка") Тогда
		ЗначениеJSON = Строка(ЗначениеJSON);
	КонецЕсли;
	
	// Определяем тип ссылки через метаданные
	Для Каждого ТипСсылки Из ТипЗначения.Типы() Цикл
		ТипМД = Метаданные.НайтиПоТипу(ТипСсылки);
		
		Если ТипМД = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверяем, является ли это справочником
		Если Метаданные.Справочники.Содержит(ТипМД) Тогда
			ИмяСправочника = ТипМД.Имя;
			МенеджерСправочника = Справочники[ИмяСправочника];
			
			// Пытаемся получить по UUID
			Попытка
				Возврат МенеджерСправочника.ПолучитьСсылку(Новый УникальныйИдентификатор(ЗначениеJSON));
			Исключение
				// Пытаемся получить по коду
				Попытка
					Возврат МенеджерСправочника.НайтиПоКоду(ЗначениеJSON);
				Исключение
					// Пытаемся получить по наименованию
					Возврат МенеджерСправочника.НайтиПоНаименованию(ЗначениеJSON);
				КонецПопытки;
			КонецПопытки;
		ИначеЕсли Метаданные.Документы.Содержит(ТипМД) Тогда
			ИмяДокумента = ТипМД.Имя;
			МенеджерДокумента = Документы[ИмяДокумента];
			
			// Пытаемся получить по UUID
			Попытка
				Возврат МенеджерДокумента.ПолучитьСсылку(Новый УникальныйИдентификатор(ЗначениеJSON));
			Исключение
				// Пытаемся получить по номеру
				Возврат МенеджерДокумента.НайтиПоНомеру(ЗначениеJSON);
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;

КонецФункции

// Преобразует строку JSON в дату
//
// Параметры:
//  ЗначениеJSON - Строка - дата в формате строки
//
// Возвращаемое значение:
//  Дата - дата
//
Функция ПреобразоватьДатуИзJSON(ЗначениеJSON)
	
	Если НЕ ЗначениеЗаполнено(ЗначениеJSON) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеJSON) = Тип("Дата") Тогда
		Возврат ЗначениеJSON;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеJSON) <> Тип("Строка") Тогда
		ЗначениеJSON = Строка(ЗначениеJSON);
	КонецЕсли;
	
	// Пытаемся преобразовать из различных форматов
	Попытка
		// Формат ISO 8601: "2024-01-15T10:30:00" или "2024-01-15T10:30:00Z"
		Если СтрДлина(ЗначениеJSON) >= 10 Тогда
			Год = Число(Лев(ЗначениеJSON, 4));
			Месяц = Число(Сред(ЗначениеJSON, 6, 2));
			День = Число(Сред(ЗначениеJSON, 9, 2));
			
			Час = 0;
			Минута = 0;
			Секунда = 0;
			
			Если СтрДлина(ЗначениеJSON) >= 19 Тогда
				Час = Число(Сред(ЗначениеJSON, 12, 2));
				Минута = Число(Сред(ЗначениеJSON, 15, 2));
				Секунда = Число(Сред(ЗначениеJSON, 18, 2));
			КонецЕсли;
			
			Возврат Дата(Год, Месяц, День, Час, Минута, Секунда);
		КонецЕсли;
	Исключение
		// Если не удалось преобразовать, возвращаем Неопределено
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат Неопределено;

КонецФункции

// Преобразует значение JSON в число
//
// Параметры:
//  ЗначениеJSON - Произвольный - значение из JSON
//
// Возвращаемое значение:
//  Число - число
//
Функция ПреобразоватьЧислоИзJSON(ЗначениеJSON)
	
	Если НЕ ЗначениеЗаполнено(ЗначениеJSON) Тогда
		Возврат 0;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеJSON) = Тип("Число") Тогда
		Возврат ЗначениеJSON;
	КонецЕсли;
	
	Попытка
		Возврат Число(ЗначениеJSON);
	Исключение
		Возврат 0;
	КонецПопытки;

КонецФункции

// Преобразует значение JSON в булево
//
// Параметры:
//  ЗначениеJSON - Произвольный - значение из JSON
//
// Возвращаемое значение:
//  Булево - булево значение
//
Функция ПреобразоватьБулевоИзJSON(ЗначениеJSON)
	
	Если НЕ ЗначениеЗаполнено(ЗначениеJSON) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеJSON) = Тип("Булево") Тогда
		Возврат ЗначениеJSON;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеJSON) = Тип("Строка") Тогда
		ЗначениеJSON = ВРег(ЗначениеJSON);
		Если ЗначениеJSON = "TRUE" Или ЗначениеJSON = "1" Или ЗначениеJSON = "ДА" Или ЗначениеJSON = "YES" Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеJSON) = Тип("Число") Тогда
		Возврат ЗначениеJSON <> 0;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

// Заполняет объект справочника данными из JSON структуры
//
// Параметры:
//  ОбъектСправочника - ОбъектСправочника - объект справочника для заполнения
//  Данные - Структура - данные в формате JSON структуры
//
Процедура JSONВОбъектСправочника(ОбъектСправочника, Данные) Экспорт
	
	Если ТипЗнч(Данные) <> Тип("Структура") Тогда
		ВызватьИсключение "Параметр 'data' должен быть объектом (структурой)";
	КонецЕсли;
	
	// Заполняем реквизиты объекта
	Для Каждого Параметр Из Данные Цикл
		ИмяРеквизита = Параметр.Ключ;
		ЗначениеJSON = Параметр.Значение;
		
		// Пропускаем служебные поля
		Если ИмяРеквизита = "Ссылка" Или ИмяРеквизита = "ПометкаУдаления" Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверяем наличие реквизита
		Если ОбъектСправочника.Свойство(ИмяРеквизита) Тогда
			Попытка
				РеквизитМД = ОбъектСправочника.Метаданные().Реквизиты.Найти(ИмяРеквизита);
				Значение1С = ПреобразоватьЗначениеИзJSON(ЗначениеJSON, РеквизитМД);
				ОбъектСправочника[ИмяРеквизита] = Значение1С;
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				ВызватьИсключение СтрШаблон("Ошибка установки реквизита '%1': %2", 
					ИмяРеквизита, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Заполняет объект документа данными из JSON структуры
//
// Параметры:
//  ОбъектДокумента - ОбъектДокумента - объект документа для заполнения
//  Данные - Структура - данные в формате JSON структуры
//
Процедура JSONВОбъектДокумента(ОбъектДокумента, Данные) Экспорт
	
	Если ТипЗнч(Данные) <> Тип("Структура") Тогда
		ВызватьИсключение "Параметр 'data' должен быть объектом (структурой)";
	КонецЕсли;
	
	// Заполняем реквизиты объекта
	Для Каждого Параметр Из Данные Цикл
		ИмяРеквизита = Параметр.Ключ;
		ЗначениеJSON = Параметр.Значение;
		
		// Пропускаем служебные поля
		Если ИмяРеквизита = "Ссылка" Или ИмяРеквизита = "Номер" Или ИмяРеквизита = "ПометкаУдаления" Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверяем наличие реквизита в метаданных
		РеквизитМД = ОбъектДокумента.Метаданные().Реквизиты.Найти(ИмяРеквизита);
		Если РеквизитМД <> Неопределено Тогда
			Попытка
				Значение1С = ПреобразоватьЗначениеИзJSON(ЗначениеJSON, РеквизитМД);
				ОбъектДокумента[ИмяРеквизита] = Значение1С;
			Исключение
				ВызватьИсключение СтрШаблон("Ошибка установки реквизита '%1': %2", 
					ИмяРеквизита, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Заполняет табличную часть документа данными из JSON массива
//
// Параметры:
//  ТабличнаяЧасть - ТабличнаяЧастьДокумента - табличная часть для заполнения
//  Данные - Массив - массив объектов с данными строк табличной части
//  МетаданныеТЧ - ОбъектМетаданныхТабличнаяЧасть - метаданные табличной части (необязательно)
//  Режим - Строка - режим работы: "replace" (по умолчанию), "update", "append"
//  КлючевоеПоле - Строка - имя ключевого поля для поиска строк в режиме "update" (необязательно)
//
Процедура JSONВТабличнуюЧасть(ТабличнаяЧасть, Данные, МетаданныеТЧ = Неопределено, Режим = "replace", КлючевоеПоле = "") Экспорт
	
	Если ТипЗнч(Данные) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр 'data' для табличной части должен быть массивом";
	КонецЕсли;
	
	// Очищаем табличную часть только в режиме replace
	Если Режим = "replace" Тогда
		ТабличнаяЧасть.Очистить();
	КонецЕсли;
	
	// Заполняем строки
	Для Каждого СтрокаДанных Из Данные Цикл
		// Поддержка как Структуры, так и Соответствия
		Если ТипЗнч(СтрокаДанных) <> Тип("Структура") И ТипЗнч(СтрокаДанных) <> Тип("Соответствие") Тогда
			Продолжить;
		КонецЕсли;
		
		// Определяем целевую строку в зависимости от режима
		ЦелеваяСтрока = Неопределено;
		
		Если Режим = "update" Тогда
			// Ищем существующую строку для обновления
			НомерСтроки = Неопределено;
			ЗначениеКлюча = Неопределено;
			
			// Извлекаем номер строки или значение ключа
			Если ТипЗнч(СтрокаДанных) = Тип("Соответствие") Тогда
				НомерСтроки = СтрокаДанных.Получить("НомерСтроки");
				Если НомерСтроки = Неопределено Тогда
					НомерСтроки = СтрокаДанных.Получить("rowIndex");
				КонецЕсли;
				Если ЗначениеЗаполнено(КлючевоеПоле) Тогда
					ЗначениеКлюча = СтрокаДанных.Получить(КлючевоеПоле);
				КонецЕсли;
			Иначе
				Если СтрокаДанных.Свойство("НомерСтроки") Тогда
					НомерСтроки = СтрокаДанных.НомерСтроки;
				ИначеЕсли СтрокаДанных.Свойство("rowIndex") Тогда
					НомерСтроки = СтрокаДанных.rowIndex;
				КонецЕсли;
				Если ЗначениеЗаполнено(КлючевоеПоле) И СтрокаДанных.Свойство(КлючевоеПоле) Тогда
					ЗначениеКлюча = СтрокаДанных[КлючевоеПоле];
				КонецЕсли;
			КонецЕсли;
			
			// Ищем строку по номеру (индекс начинается с 1)
			Если НомерСтроки <> Неопределено Тогда
				ИндексСтроки = Число(НомерСтроки) - 1;
				Если ИндексСтроки >= 0 И ИндексСтроки < ТабличнаяЧасть.Количество() Тогда
					ЦелеваяСтрока = ТабличнаяЧасть[ИндексСтроки];
				КонецЕсли;
			// Или ищем по ключевому полю
			ИначеЕсли ЗначениеЗаполнено(КлючевоеПоле) И ЗначениеКлюча <> Неопределено Тогда
				Для Индекс = 0 По ТабличнаяЧасть.Количество() - 1 Цикл
					ТекущаяСтрока = ТабличнаяЧасть[Индекс];
					Попытка
						Если ТекущаяСтрока[КлючевоеПоле] = ЗначениеКлюча Тогда
							ЦелеваяСтрока = ТекущаяСтрока;
							Прервать;
						КонецЕсли;
					Исключение
						// Поле не существует - продолжаем поиск
					КонецПопытки;
				КонецЦикла;
			КонецЕсли;
			
			// Если строка не найдена, создаём новую
			Если ЦелеваяСтрока = Неопределено Тогда
				ЦелеваяСтрока = ТабличнаяЧасть.Добавить();
			КонецЕсли;
		Иначе
			// Режимы replace и append - всегда создаём новую строку
			ЦелеваяСтрока = ТабличнаяЧасть.Добавить();
		КонецЕсли;
		
		// Заполняем реквизиты строки
		Для Каждого Параметр Из СтрокаДанных Цикл
			ИмяРеквизита = Параметр.Ключ;
			ЗначениеJSON = Параметр.Значение;
			
			// Пропускаем служебные поля
			Если ИмяРеквизита = "НомерСтроки" Или ИмяРеквизита = "rowIndex" Или ИмяРеквизита = "_key" Тогда
				Продолжить;
			КонецЕсли;
			
			// Проверяем наличие реквизита в метаданных табличной части
			РеквизитМД = Неопределено;
			Если МетаданныеТЧ <> Неопределено Тогда
				РеквизитМД = МетаданныеТЧ.Реквизиты.Найти(ИмяРеквизита);
			КонецЕсли;
			
			Если РеквизитМД <> Неопределено Тогда
				Попытка
					Значение1С = ПреобразоватьЗначениеИзJSON(ЗначениеJSON, РеквизитМД);
					ЦелеваяСтрока[ИмяРеквизита] = Значение1С;
				Исключение
					ВызватьИсключение СтрШаблон("Ошибка установки реквизита '%1' в табличной части: %2", 
						ИмяРеквизита, 
						ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				КонецПопытки;
			Иначе
				// Пробуем установить значение напрямую без преобразования
				Попытка
					ЦелеваяСтрока[ИмяРеквизита] = ЗначениеJSON;
				Исключение
					// Игнорируем ошибку — возможно, поле не существует
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

// Создает движения регистра из JSON данных
//
// Параметры:
//  НаборЗаписей - НаборЗаписейРегистра - набор записей регистра
//  Данные - Массив - массив объектов с данными движений
//
Процедура JSONВДвиженияРегистра(НаборЗаписей, Данные) Экспорт
	
	Если ТипЗнч(Данные) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр 'data' для регистра должен быть массивом";
	КонецЕсли;
	
	// Создаем движения
	Для Каждого ДвижениеДанных Из Данные Цикл
		Если ТипЗнч(ДвижениеДанных) <> Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;
		
		НовоеДвижение = НаборЗаписей.Добавить();
		
		// Заполняем измерения и ресурсы
		Для Каждого Параметр Из ДвижениеДанных Цикл
			ИмяПоля = Параметр.Ключ;
			ЗначениеJSON = Параметр.Значение;
			
			Если НовоеДвижение.Свойство(ИмяПоля) Тогда
				Попытка
					// Определяем тип поля (измерение или ресурс)
					МетаданныеРегистра = НаборЗаписей.Метаданные();
					РеквизитМД = Неопределено;
					
					Если МетаданныеРегистра.Измерения.Найти(ИмяПоля) <> Неопределено Тогда
						РеквизитМД = МетаданныеРегистра.Измерения.Найти(ИмяПоля);
					ИначеЕсли МетаданныеРегистра.Ресурсы.Найти(ИмяПоля) <> Неопределено Тогда
						РеквизитМД = МетаданныеРегистра.Ресурсы.Найти(ИмяПоля);
					КонецЕсли;
					
					Значение1С = ПреобразоватьЗначениеИзJSON(ЗначениеJSON, РеквизитМД);
					НовоеДвижение[ИмяПоля] = Значение1С;
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
					ВызватьИсключение СтрШаблон("Ошибка установки поля '%1' в движении регистра: %2", 
						ИмяПоля, 
						ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

// Проверяет, является ли ошибка проблемой прав доступа
//
// Параметры:
//  ТекстОшибки - Строка - текст ошибки для проверки
//
// Возвращаемое значение:
//  Булево - Истина, если это ошибка прав доступа
//
Функция ЭтоОшибкаПравДоступа(ТекстОшибки) Экспорт
	
	ТекстВРег = ВРег(ТекстОшибки);
	
	// Типичные маркеры ошибок прав доступа в 1С
	Если СтрНайти(ТекстВРег, "НЕДОСТАТОЧНО ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "НЕДОСТАТОЧНО_ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "НЕТ ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "ДОСТУП ЗАПРЕЩЕН") > 0
		ИЛИ СтрНайти(ТекстВРег, "ДОСТУП ЗАКРЫТ") > 0
		ИЛИ СтрНайти(ТекстВРег, "ОШИБКА ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "ПРАВА ДОСТУПА") > 0
		ИЛИ СтрНайти(ТекстВРег, "НЕ ИМЕЕТ ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "ACCESS DENIED") > 0
		ИЛИ СтрНайти(ТекстВРег, "PERMISSION DENIED") > 0
		ИЛИ СтрНайти(ТекстВРег, "INSUFFICIENT RIGHTS") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Проверяем ошибки RLS (ограничения на уровне записей)
	Если СтрНайти(ТекстВРег, "RLS") > 0
		ИЛИ СтрНайти(ТекстВРег, "ОГРАНИЧЕНИЕ ДАННЫХ") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Извлекает имя объекта метаданных из текста ошибки прав доступа
//
// Параметры:
//  ТекстОшибки - Строка - текст ошибки
//
// Возвращаемое значение:
//  Строка - имя объекта или пустая строка
//
Функция ИзвлечьИмяОбъектаИзОшибкиПрав(ТекстОшибки) Экспорт
	
	// Паттерны для поиска имён объектов в ошибках 1С
	// Например: "Справочник.Номенклатура", "Документ.ЗаказПоставщику"
	Паттерны = Новый Массив;
	Паттерны.Добавить("Справочник.");
	Паттерны.Добавить("Документ.");
	Паттерны.Добавить("РегистрСведений.");
	Паттерны.Добавить("РегистрНакопления.");
	Паттерны.Добавить("РегистрБухгалтерии.");
	Паттерны.Добавить("РегистрРасчета.");
	Паттерны.Добавить("ПланВидовХарактеристик.");
	Паттерны.Добавить("ПланСчетов.");
	Паттерны.Добавить("ПланВидовРасчета.");
	Паттерны.Добавить("БизнесПроцесс.");
	Паттерны.Добавить("Задача.");
	Паттерны.Добавить("Перечисление.");
	Паттерны.Добавить("Константа.");
	
	Для Каждого Паттерн Из Паттерны Цикл
		Позиция = СтрНайти(ТекстОшибки, Паттерн);
		Если Позиция > 0 Тогда
			// Ищем конец имени объекта (пробел, точка, скобка, кавычка)
			Начало = Позиция;
			ПозицияКонца = Начало + СтрДлина(Паттерн);
			Пока ПозицияКонца <= СтрДлина(ТекстОшибки) Цикл
				Символ = Сред(ТекстОшибки, ПозицияКонца, 1);
				Если Символ = " " ИЛИ Символ = "." ИЛИ Символ = "(" ИЛИ Символ = ")"
					ИЛИ Символ = "'" ИЛИ Символ = """" ИЛИ Символ = Символы.ПС 
					ИЛИ Символ = Символы.ВК ИЛИ Символ = "," ИЛИ Символ = ";" Тогда
					Прервать;
				КонецЕсли;
				ПозицияКонца = ПозицияКонца + 1;
			КонецЦикла;
			
			ИмяОбъекта = Сред(ТекстОшибки, Начало, ПозицияКонца - Начало);
			Если ЗначениеЗаполнено(ИмяОбъекта) Тогда
				Возврат ИмяОбъекта;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат "";
	
КонецФункции

// Формирует понятное сообщение об ошибке прав доступа
//
// Параметры:
//  ТекстОшибки - Строка - исходный текст ошибки
//
// Возвращаемое значение:
//  Строка - понятное сообщение для пользователя
//
Функция СформироватьСообщениеОбОшибкеПрав(ТекстОшибки) Экспорт
	
	ИмяОбъекта = ИзвлечьИмяОбъектаИзОшибкиПрав(ТекстОшибки);
	
	Если ЗначениеЗаполнено(ИмяОбъекта) Тогда
		Возврат СтрШаблон(
			"НЕДОСТАТОЧНО ПРАВ: У текущего пользователя нет прав на чтение объекта '%1'. " +
			"Обратитесь к администратору для получения доступа." + Символы.ПС + Символы.ПС +
			"Техническая информация: %2",
			ИмяОбъекта, ТекстОшибки);
	Иначе
		Возврат СтрШаблон(
			"НЕДОСТАТОЧНО ПРАВ: У текущего пользователя недостаточно прав для выполнения операции. " +
			"Обратитесь к администратору для получения доступа." + Символы.ПС + Символы.ПС +
			"Техническая информация: %1",
			ТекстОшибки);
	КонецЕсли;
	
КонецФункции

#КонецОбласти

