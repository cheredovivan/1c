#Область ОбщийИнтерфейс

Функция rpcPOST(Запрос)
	// Обрабатываем через унифицированную функцию
	Возврат ОбработатьJSONRPCЗапрос(Запрос);
КонецФункции

Функция healthGET(Запрос)
	ОтветДанные = Новый Структура;
	ОтветДанные.Вставить("status", "ok");
	
	JSONСтрока = mcp_ОбщегоНазначения.СтруктураВJSON(ОтветДанные);
	
	Ответ = Новый HTTPСервисОтвет(200);
	Ответ.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
	Ответ.УстановитьТелоИзСтроки(JSONСтрока, КодировкаТекста.UTF8);
	
	Возврат Ответ;
КонецФункции

Функция mcpPOST(Запрос)
	// Обрабатываем MCP Streamable HTTP запросы через унифицированную функцию
	Возврат ОбработатьJSONRPCЗапрос(Запрос);
КонецФункции

Функция mcpGET(Запрос)
	// GET не поддерживается для MCP эндпоинта согласно спецификации
	Ответ = Новый HTTPСервисОтвет(405);
	Ответ.Заголовки.Вставить("Allow", "POST");
	Возврат Ответ;
КонецФункции

#КонецОбласти

#Область УнифицированнаяОбработкаJSONRPC

Функция ОбработатьJSONRPCЗапрос(Запрос)
	// Унифицированная обработка JSON-RPC запросов для /rpc и /mcp эндпоинтов
	
	Ответ = Новый HTTPСервисОтвет(200);
	Ответ.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
	
	// Добавляем CORS заголовки для совместимости с браузерными клиентами
	Ответ.Заголовки.Вставить("Access-Control-Allow-Origin", "*");
	
	// Инициализируем переменную для идентификатора запроса
	// Может быть не определена, если ошибка произойдет до парсинга JSON
	ИдентификаторЗапроса = Неопределено;
	
	Попытка
		// Получаем тело запроса
		ТелоЗапроса = Запрос.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
		
		// Парсим JSON-RPC запрос
		ЗапросДанные = mcp_ОбщегоНазначения.JSONВСтруктуру(ТелоЗапроса);
		
		// Для notifications (запросы без id) сразу возвращаем 204 No Content
		Если НЕ ЗапросДанные.Свойство("id") Тогда
			Возврат СформироватьОтвет204();
		КонецЕсли;
		
		ИдентификаторЗапроса = ЗапросДанные.id;
		
		// Проверяем версию JSON-RPC
		Если ЗапросДанные.Свойство("jsonrpc") И ЗапросДанные.jsonrpc <> "2.0" Тогда
			Возврат СформироватьJSONОшибку(Ответ, ИдентификаторЗапроса, -32600, "Неподдерживаемая версия JSON-RPC");
		КонецЕсли;
		
		// Получаем метод
		Метод = "";
		Если ЗапросДанные.Свойство("method") Тогда
			Метод = ЗапросДанные.method;
		КонецЕсли;
		
		// Получаем параметры
		Параметры = Новый Структура;
		Если ЗапросДанные.Свойство("params") Тогда
			Параметры = ЗапросДанные.params;
		КонецЕсли;
		
		// Маршрутизация по методам
		Результат = Неопределено;
		
		Если Метод = "initialize" Тогда
			Результат = ОбработатьInitialize(Параметры);
		ИначеЕсли Метод = "tools/list" Тогда
			Результат = ПолучитьСписокИнструментов(Параметры);
		ИначеЕсли Метод = "tools/call" Тогда
			Результат = ВызватьИнструмент(Параметры);
		ИначеЕсли Метод = "resources/list" Тогда
			Результат = ПолучитьСписокРесурсов(Параметры);
		ИначеЕсли Метод = "resources/read" Тогда
			Результат = ПолучитьРесурс(Параметры);
		ИначеЕсли Метод = "prompts/list" Тогда
			Результат = ПолучитьСписокПромптов(Параметры);
		ИначеЕсли Метод = "prompts/get" Тогда
			Результат = ПолучитьПромпт(Параметры);
		Иначе
			// Неизвестный метод
			Возврат СформироватьJSONОшибку(Ответ, ИдентификаторЗапроса, -32601, "Неизвестный метод: " + Метод);
		КонецЕсли;
		
		// Формируем успешный ответ
		Возврат СформироватьJSONУспех(Ответ, ИдентификаторЗапроса, Результат);
		
	Исключение
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		// Если идентификатор запроса не был определен, оставляем Неопределено
		// При сериализации в JSON Неопределено корректно преобразуется в null
		
		Возврат СформироватьJSONОшибку(Ответ, ИдентификаторЗапроса, -32603, "Внутренняя ошибка сервера: " + ОписаниеОшибки);
	КонецПопытки;
КонецФункции

Функция ОбработатьInitialize(Параметры)
	// Обрабатывает метод initialize для MCP handshake
	
	Результат = Новый Структура;
	
	// Устанавливаем версию протокола
	Результат.Вставить("protocolVersion", "2025-03-26");
	
	// Описываем возможности сервера
	ВозможностиИнструментов = Новый Структура;
	ВозможностиИнструментов.Вставить("listChanged", Ложь);
	ВозможностиИнструментов.Вставить("call", Истина);
	
	ВозможностиРесурсов = Новый Структура;
	ВозможностиРесурсов.Вставить("listChanged", Ложь);
	ВозможностиРесурсов.Вставить("subscribe", Ложь);
	
	ВозможностиПромптов = Новый Структура;
	ВозможностиПромптов.Вставить("listChanged", Ложь);
	
	Возможности = Новый Структура;
	Возможности.Вставить("tools", ВозможностиИнструментов);
	Возможности.Вставить("resources", ВозможностиРесурсов);
	Возможности.Вставить("prompts", ВозможностиПромптов);
	
	Результат.Вставить("capabilities", Возможности);
	
	// Информация о сервере
	ИнформацияСервера = Новый Структура;
	ИнформацияСервера.Вставить("name", "1C MCP Server");
	ИнформацияСервера.Вставить("version", "1.0.0");
	
	Результат.Вставить("serverInfo", ИнформацияСервера);
	
	Возврат Результат;
КонецФункции

Функция СформироватьJSONУспех(HTTPОтвет, ИдентификаторЗапроса, Результат)
	// Формирует успешный JSON-RPC ответ
	
	ОтветУспех = Новый Структура;
	ОтветУспех.Вставить("jsonrpc", "2.0");
	ОтветУспех.Вставить("id", ИдентификаторЗапроса);
	ОтветУспех.Вставить("result", Результат);
	
	HTTPОтвет.УстановитьТелоИзСтроки(mcp_ОбщегоНазначения.СтруктураВJSON(ОтветУспех), КодировкаТекста.UTF8);
	
	Возврат HTTPОтвет;
КонецФункции

Функция СформироватьJSONОшибку(HTTPОтвет, ИдентификаторЗапроса, КодОшибки, СообщениеОшибки)
	// Формирует JSON-RPC ответ с ошибкой
	
	ОтветОшибка = СформироватьОтветОшибку(КодОшибки, СообщениеОшибки, ИдентификаторЗапроса);
	HTTPОтвет.УстановитьТелоИзСтроки(mcp_ОбщегоНазначения.СтруктураВJSON(ОтветОшибка), КодировкаТекста.UTF8);
	
	Возврат HTTPОтвет;
КонецФункции

Функция СформироватьОтвет204()
	// Формирует ответ 204 No Content для notifications
	
	Ответ = Новый HTTPСервисОтвет(204);
	Ответ.Заголовки.Вставить("Access-Control-Allow-Origin", "*");
	
	Возврат Ответ;
КонецФункции

#КонецОбласти

#Область РаботаСИнструментами

Функция ПолучитьСписокИнструментов(Параметры)
	// Получает список доступных инструментов из контейнеров
	// Возвращает структуру с полем "tools" - массив инструментов
	// Каждый инструмент содержит:
	// - name (строка): имя инструмента
	// - description (строка): описание инструмента
	// - inputSchema (структура): JSON схема входных параметров
	
	Результат = Новый Структура;
	Инструменты = Новый Массив;
	
	// Получаем таблицу инструментов из контейнеров
	ТаблицаИнструментов = mcp_КонтейнерыПовтИсп.Инструменты();
	
	// Преобразуем таблицу в массив структур для JSON-RPC ответа
	Для Каждого СтрокаИнструмента Из ТаблицаИнструментов Цикл
		
		Инструмент = Новый Структура;
		Инструмент.Вставить("name", СтрокаИнструмента.Имя);
		Инструмент.Вставить("description", СтрокаИнструмента.Описание);
		
		// Парсим JSON схему параметров
		СхемаПараметров = Новый Структура;
		Если ЗначениеЗаполнено(СтрокаИнструмента.СхемаПараметров) Тогда
			Попытка
				СхемаПараметров = mcp_ОбщегоНазначения.JSONВСтруктуру(СтрокаИнструмента.СхемаПараметров);
			Исключение
				ТекстОшибки = СтрШаблон("Ошибка чтения JSON схемы параметров для инструмента '%1': %2", 
					СтрокаИнструмента.Имя, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ВызватьИсключение ТекстОшибки;
			КонецПопытки;
		КонецЕсли;
		
		Инструмент.Вставить("inputSchema", СхемаПараметров);
		
		Инструменты.Добавить(Инструмент);
		
	КонецЦикла;
	
	Результат.Вставить("tools", Инструменты);
	
	Возврат Результат;
КонецФункции

Функция ВызватьИнструмент(Параметры)
	// Выполняет инструмент из контейнеров
	// Параметры содержат:
	// - name (строка): имя инструмента для вызова
	// - arguments (структура): аргументы для инструмента
	//
	// Возвращает структуру с полями:
	// - content (массив): содержимое результата
	//   Каждый элемент содержит:
	//   - type ("text" или "image"): тип содержимого
	//   - text (строка): текст для типа "text"
	//   - data (строка): данные изображения в base64 для типа "image"
	//   - mimeType (строка): MIME-тип для изображений
	// - isError (булево): признак ошибки
	
	ИмяИнструмента = "";
	Если ТипЗнч(Параметры) = Тип("Соответствие") Тогда
		Если Параметры.Получить("name") <> Неопределено Тогда
			ИмяИнструмента = Параметры.Получить("name");
		КонецЕсли;
	ИначеЕсли Параметры.Свойство("name") Тогда
		ИмяИнструмента = Параметры.name;
	КонецЕсли;
	
	АргументыИнструмента = Неопределено;
	Если ТипЗнч(Параметры) = Тип("Соответствие") Тогда
		АргументыИнструмента = Параметры.Получить("arguments");
	ИначеЕсли Параметры.Свойство("arguments") Тогда
		АргументыИнструмента = Параметры.arguments;
	КонецЕсли;
	
	Если АргументыИнструмента = Неопределено Тогда
		АргументыИнструмента = Новый Структура;
	КонецЕсли;
	
	// Проверяем обязательные параметры
	Если НЕ ЗначениеЗаполнено(ИмяИнструмента) Тогда
		ВызватьИсключение "Не указано имя инструмента для вызова";
	КонецЕсли;
	
	// Диагностика: логируем тип аргументов
	ЗаписьЖурналаРегистрации("MCP.Диагностика", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("Вызов инструмента '%1', тип аргументов: %2", ИмяИнструмента, ТипЗнч(АргументыИнструмента)));
	
	// Получаем таблицу инструментов и ищем нужный
	ТаблицаИнструментов = mcp_КонтейнерыПовтИсп.Инструменты();
	
	// Диагностика: количество инструментов
	ЗаписьЖурналаРегистрации("MCP.Диагностика", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("Загружено инструментов: %1", ТаблицаИнструментов.Количество()));
	
	СтрокаИнструмента = ТаблицаИнструментов.Найти(ИмяИнструмента, "Имя");
	
	Если СтрокаИнструмента = Неопределено Тогда
		// Выводим список доступных инструментов для диагностики
		СписокИнструментов = "";
		Для Каждого Стр Из ТаблицаИнструментов Цикл
			СписокИнструментов = СписокИнструментов + Стр.Имя + "; ";
		КонецЦикла;
		ВызватьИсключение СтрШаблон("Инструмент '%1' не найден. Доступные инструменты: %2", ИмяИнструмента, СписокИнструментов);
	КонецЕсли;
	
	Результат = Новый Структура;
	Содержимое = Новый Массив;
	ПризнакОшибки = Ложь;
	
	// Журналирование начала выполнения
	ВремяНачала = ТекущаяДатаСеанса();
	ЗаписьЖурналаРегистрации("MCP.Инструменты", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("Начало выполнения инструмента '%1'", ИмяИнструмента));
	
	Попытка
		// Выполняем инструмент через модуль выполнения
		РезультатВыполнения = mcp_Выполнение.ВыполнитьИнструмент(СтрокаИнструмента, АргументыИнструмента);
		
		// Журналирование успешного выполнения
		ВремяВыполнения = ТекущаяДатаСеанса() - ВремяНачала;
		ЗаписьЖурналаРегистрации("MCP.Инструменты", УровеньЖурналаРегистрации.Информация, , , 
			СтрШаблон("Инструмент '%1' выполнен успешно за %2 мс", ИмяИнструмента, ВремяВыполнения));
		
		// Преобразуем результат в формат MCP
		Если ТипЗнч(РезультатВыполнения) = Тип("Структура") И РезультатВыполнения.Свойство("content") Тогда
			// Инструмент вернул готовую структуру с content и isError
			Содержимое = РезультатВыполнения.content;
			Если РезультатВыполнения.Свойство("isError") Тогда
				ПризнакОшибки = РезультатВыполнения.isError;
			КонецЕсли;
		ИначеЕсли ТипЗнч(РезультатВыполнения) = Тип("Массив") Тогда
			Для Каждого Элемент Из РезультатВыполнения Цикл
				Если ТипЗнч(Элемент) = Тип("Структура") И Элемент.Свойство("type") Тогда
					Содержимое.Добавить(Элемент);
				Иначе
					ЭлементСодержимого = Новый Структура;
					ЭлементСодержимого.Вставить("type", "text");
					ЭлементСодержимого.Вставить("text", Строка(Элемент));
					Содержимое.Добавить(ЭлементСодержимого);
				КонецЕсли;
			КонецЦикла;
		Иначе
			ЭлементСодержимого = Новый Структура;
			ЭлементСодержимого.Вставить("type", "text");
			ЭлементСодержимого.Вставить("text", Строка(РезультатВыполнения));
			Содержимое.Добавить(ЭлементСодержимого);
		КонецЕсли;

	Исключение
		ПризнакОшибки = Истина;
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВремяВыполнения = ТекущаяДатаСеанса() - ВремяНачала;
		ЗаписьЖурналаРегистрации("MCP.Инструменты", УровеньЖурналаРегистрации.Ошибка, , , 
			СтрШаблон("Ошибка выполнения инструмента '%1' за %2 мс: %3", 
				ИмяИнструмента, 
				ВремяВыполнения,
				ТекстОшибки));
		
		// Определяем тип ошибки и формируем понятное сообщение
		ПрефиксОшибки = "";
		Если ЭтоОшибкаПравДоступа(ТекстОшибки) Тогда
			ПрефиксОшибки = "НЕДОСТАТОЧНО ПРАВ. ";
		ИначеЕсли СтрНайти(ВРег(ТекстОшибки), "СИНТАКСИС") > 0 
				ИЛИ СтрНайти(ВРег(ТекстОшибки), "ОШИБКА В ЗАПРОСЕ") > 0
				ИЛИ СтрНайти(ВРег(ТекстОшибки), "НЕВЕРНЫЙ ЗАПРОС") > 0 Тогда
			ПрефиксОшибки = "ОШИБКА СИНТАКСИСА ЗАПРОСА. ";
		КонецЕсли;

		ЭлементОшибки = Новый Структура;
		ЭлементОшибки.Вставить("type", "text");
		ЭлементОшибки.Вставить("text", 
			СтрШаблон("Ошибка выполнения инструмента '%1':%2%3%4", 
				ИмяИнструмента,
				Символы.ПС,
				ПрефиксОшибки,
				ТекстОшибки));
		Содержимое.Добавить(ЭлементОшибки);
	КонецПопытки;

	Результат.Вставить("content", Содержимое);
	Результат.Вставить("isError", ПризнакОшибки);
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область РаботаСРесурсами

Функция ПолучитьСписокРесурсов(Параметры)
	// Получает список доступных ресурсов из контейнеров
	// Возвращает структуру с полем "resources" - массив ресурсов
	// Каждый ресурс содержит:
	// - uri (строка): URI ресурса
	// - name (строка): имя ресурса
	// - description (строка): описание ресурса
	// - mimeType (строка): MIME-тип ресурса (опционально)
	
	Результат = Новый Структура;
	Ресурсы = Новый Массив;
	
	// Получаем таблицу ресурсов из контейнеров
	ТаблицаРесурсов = mcp_КонтейнерыПовтИсп.Ресурсы();
	
	// Преобразуем таблицу в массив структур для JSON-RPC ответа
	Для Каждого СтрокаРесурса Из ТаблицаРесурсов Цикл
		
		Ресурс = Новый Структура;
		Ресурс.Вставить("uri", СтрокаРесурса.Адрес);
		Ресурс.Вставить("name", СтрокаРесурса.Имя);
		Ресурс.Вставить("description", СтрокаРесурса.Описание);
		
		// mimeType не хранится в таблице ресурсов, поэтому не указываем
		// При необходимости можно будет добавить в схему таблицы
		
		Ресурсы.Добавить(Ресурс);
		
	КонецЦикла;
	
	Результат.Вставить("resources", Ресурсы);
	
	Возврат Результат;
КонецФункции

Функция ПолучитьРесурс(Параметры)
	// Читает содержимое ресурса из контейнеров
	// Параметры содержат:
	// - uri (строка): URI ресурса для получения
	//
	// Возвращает структуру с полем "contents" - массив содержимого
	// Каждый элемент содержит:
	// - type ("text" или "blob"): тип содержимого
	// - mimeType (строка): MIME-тип содержимого
	// - text (строка): текстовое содержимое для типа "text"
	// - blob (строка): двоичные данные в base64 для типа "blob"
	
	URIРесурса = "";
	Если Параметры.Свойство("uri") Тогда
		URIРесурса = Параметры.uri;
	КонецЕсли;
	
	// Проверяем обязательные параметры
	Если НЕ ЗначениеЗаполнено(URIРесурса) Тогда
		ВызватьИсключение "Не указан URI ресурса для чтения";
	КонецЕсли;
	
	// Получаем таблицу ресурсов и ищем нужный
	ТаблицаРесурсов = mcp_КонтейнерыПовтИсп.Ресурсы();
	СтрокаРесурса = ТаблицаРесурсов.Найти(URIРесурса, "Адрес");
	
	Если СтрокаРесурса = Неопределено Тогда
		ВызватьИсключение СтрШаблон("Ресурс '%1' не найден", URIРесурса);
	КонецЕсли;
	
	Результат = Новый Структура;
	Содержимое = Новый Массив;
	
	Попытка
		// Читаем ресурс через модуль выполнения
		СодержимоеРесурса = mcp_Выполнение.ПрочитатьРесурс(СтрокаРесурса, URIРесурса);
		
		// Преобразуем результат в формат MCP
	Если ТипЗнч(СодержимоеРесурса) = Тип("Массив") Тогда
		// Содержимое уже в формате массива элементов
		Для Каждого Элемент Из СодержимоеРесурса Цикл
			Если ТипЗнч(Элемент) = Тип("Структура") И Элемент.Свойство("type") Тогда
				// Добавляем uri, если его нет
				Если НЕ Элемент.Свойство("uri") Тогда
					Элемент.Вставить("uri", URIРесурса);
				КонецЕсли;
				Содержимое.Добавить(Элемент);
			Иначе
				// Преобразуем произвольный элемент в текстовый
				ЭлементСодержимого = Новый Структура;
				ЭлементСодержимого.Вставить("type", "text");
				ЭлементСодержимого.Вставить("uri", URIРесурса);
				ЭлементСодержимого.Вставить("mimeType", "text/plain");
				ЭлементСодержимого.Вставить("text", Строка(Элемент));
				Содержимое.Добавить(ЭлементСодержимого);
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(СодержимоеРесурса) = Тип("Структура") Тогда
		Если СодержимоеРесурса.Свойство("type") Тогда
			ЭлементСодержимого = Новый Структура;
			Для Каждого Свойство Из СодержимоеРесурса Цикл
				ЭлементСодержимого.Вставить(Свойство.Ключ, Свойство.Значение);
			КонецЦикла;
			Если НЕ ЭлементСодержимого.Свойство("uri") Тогда
				ЭлементСодержимого.Вставить("uri", URIРесурса);
			КонецЕсли;
			Если НЕ ЭлементСодержимого.Свойство("mimeType") Тогда
				ЭлементСодержимого.Вставить("mimeType", "text/plain");
			КонецЕсли;
			Содержимое.Добавить(ЭлементСодержимого);
		Иначе
			ЭлементСодержимого = Новый Структура;
			ЭлементСодержимого.Вставить("type", "text");
			ЭлементСодержимого.Вставить("uri", URIРесурса);
			ЭлементСодержимого.Вставить("mimeType", "text/plain");
			ЭлементСодержимого.Вставить("text", Строка(СодержимоеРесурса));
			Содержимое.Добавить(ЭлементСодержимого);
		КонецЕсли;
	Иначе
		// Содержимое - одиночное значение, преобразуем в текст
		ЭлементСодержимого = Новый Структура;
		ЭлементСодержимого.Вставить("type", "text");
		ЭлементСодержимого.Вставить("uri", URIРесурса);
		ЭлементСодержимого.Вставить("mimeType", "text/plain");
		ЭлементСодержимого.Вставить("text", Строка(СодержимоеРесурса));
		Содержимое.Добавить(ЭлементСодержимого);
	КонецЕсли;
		
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка чтения ресурса '%1': %2", 
			URIРесурса, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Результат.Вставить("contents", Содержимое);
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область РаботаСПромптами

Функция ПолучитьСписокПромптов(Параметры)
	// Получает список доступных промптов из контейнеров
	// Возвращает структуру с полем "prompts" - массив промптов
	// Каждый промпт содержит:
	// - name (строка): имя промпта
	// - description (строка): описание промпта
	// - arguments (массив): аргументы промпта (опционально)
	//   Каждый аргумент содержит:
	//   - name (строка): имя аргумента
	//   - description (строка): описание аргумента
	//   - required (булево): признак обязательности
	
	Результат = Новый Структура;
	Промпты = Новый Массив;
	
	// Получаем таблицу промптов из контейнеров
	ТаблицаПромптов = mcp_КонтейнерыПовтИсп.Промпты();
	
	// Преобразуем таблицу в массив структур для JSON-RPC ответа
	Для Каждого СтрокаПромпта Из ТаблицаПромптов Цикл
		
		Промпт = Новый Структура;
		Промпт.Вставить("name", СтрокаПромпта.Имя);
		Промпт.Вставить("description", СтрокаПромпта.Описание);
		
		// Парсим JSON параметров промпта
		АргументыПромпта = Новый Массив;
		Если ЗначениеЗаполнено(СтрокаПромпта.Параметры) Тогда
			Попытка
				АргументыПромпта = mcp_ОбщегоНазначения.JSONВСтруктуру(СтрокаПромпта.Параметры);
				// Если это не массив, а объект - генерируем ошибку
				Если ТипЗнч(АргументыПромпта) <> Тип("Массив") Тогда
					ТекстОшибки = СтрШаблон("Параметры промпта '%1' должны быть массивом, а получен %2", 
						СтрокаПромпта.Имя, 
						ТипЗнч(АргументыПромпта));
					ВызватьИсключение ТекстОшибки;
				КонецЕсли;
			Исключение
				ТекстОшибки = СтрШаблон("Ошибка чтения JSON параметров для промпта '%1': %2", 
					СтрокаПромпта.Имя, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ВызватьИсключение ТекстОшибки;
			КонецПопытки;
		КонецЕсли;
		
		Промпт.Вставить("arguments", АргументыПромпта);
		
		Промпты.Добавить(Промпт);
		
	КонецЦикла;
	
	Результат.Вставить("prompts", Промпты);
	
	Возврат Результат;
КонецФункции

Функция ПолучитьПромпт(Параметры)
	// Получает промпт из контейнеров
	// Параметры содержат:
	// - name (строка): имя промпта
	// - arguments (структура): аргументы промпта
	//
	// Возвращает структуру с полями:
	// - description (строка): описание промпта
	// - messages (массив): сообщения промпта
	//   Каждое сообщение содержит:
	//   - role (строка): роль ("user", "assistant", "system")
	//   - content (структура): содержимое сообщения
	//     - type ("text"): тип содержимого
	//     - text (строка): текст сообщения
	
	ИмяПромпта = "";
	Если Параметры.Свойство("name") Тогда
		ИмяПромпта = Параметры.name;
	КонецЕсли;
	
	АргументыПромпта = Новый Структура;
	Если Параметры.Свойство("arguments") Тогда
		АргументыПромпта = Параметры.arguments;
	КонецЕсли;
	
	// Проверяем обязательные параметры
	Если НЕ ЗначениеЗаполнено(ИмяПромпта) Тогда
		ВызватьИсключение "Не указано имя промпта для получения";
	КонецЕсли;
	
	// Получаем таблицу промптов и ищем нужный
	ТаблицаПромптов = mcp_КонтейнерыПовтИсп.Промпты();
	СтрокаПромпта = ТаблицаПромптов.Найти(ИмяПромпта, "Имя");
	
	Если СтрокаПромпта = Неопределено Тогда
		ВызватьИсключение СтрШаблон("Промпт '%1' не найден", ИмяПромпта);
	КонецЕсли;
	
	Результат = Новый Структура;
	Сообщения = Новый Массив;
	
	Попытка
		// Получаем промпт через модуль выполнения
		СодержимоеПромпта = mcp_Выполнение.ПолучитьПромпт(СтрокаПромпта, ИмяПромпта, АргументыПромпта);
		
		// Устанавливаем описание из таблицы или из результата
		ОписаниеПромпта = СтрокаПромпта.Описание;
		Если ТипЗнч(СодержимоеПромпта) = Тип("Структура") И СодержимоеПромпта.Свойство("description") Тогда
			ОписаниеПромпта = СодержимоеПромпта.description;
		КонецЕсли;
		
		// Преобразуем результат в формат MCP
		Если ТипЗнч(СодержимоеПромпта) = Тип("Структура") И СодержимоеПромпта.Свойство("messages") Тогда
			// Результат уже в формате MCP с полем messages
			Если ТипЗнч(СодержимоеПромпта.messages) = Тип("Массив") Тогда
				Сообщения = СодержимоеПромпта.messages;
			КонецЕсли;
		ИначеЕсли ТипЗнч(СодержимоеПромпта) = Тип("Массив") Тогда
			// Результат - массив сообщений
			Сообщения = СодержимоеПромпта;
		Иначе
			// Результат - одиночное значение, создаем сообщение пользователя
			Сообщение = Новый Структура;
			Сообщение.Вставить("role", "user");
			
			СодержимоеСообщения = Новый Структура;
			СодержимоеСообщения.Вставить("type", "text");
			СодержимоеСообщения.Вставить("text", Строка(СодержимоеПромпта));
			
			Сообщение.Вставить("content", СодержимоеСообщения);
			Сообщения.Добавить(Сообщение);
		КонецЕсли;
		
		Результат.Вставить("description", ОписаниеПромпта);
		
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка получения промпта '%1': %2", 
			ИмяПромпта, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Результат.Вставить("messages", Сообщения);
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область ВспомогательныеМетоды

// Проверяет, является ли ошибка проблемой прав доступа
//
// Параметры:
//  ТекстОшибки - Строка - текст ошибки для проверки
//
// Возвращаемое значение:
//  Булево - Истина, если это ошибка прав доступа
//
Функция ЭтоОшибкаПравДоступа(ТекстОшибки)
	
	ТекстВРег = ВРег(ТекстОшибки);
	
	// Типичные маркеры ошибок прав доступа в 1С
	Если СтрНайти(ТекстВРег, "НЕДОСТАТОЧНО ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "НЕДОСТАТОЧНО_ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "НЕТ ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "ДОСТУП ЗАПРЕЩЕН") > 0
		ИЛИ СтрНайти(ТекстВРег, "ДОСТУП ЗАКРЫТ") > 0
		ИЛИ СтрНайти(ТекстВРег, "ОШИБКА ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "ПРАВА ДОСТУПА") > 0
		ИЛИ СтрНайти(ТекстВРег, "НЕ ИМЕЕТ ПРАВ") > 0
		ИЛИ СтрНайти(ТекстВРег, "ACCESS DENIED") > 0
		ИЛИ СтрНайти(ТекстВРег, "PERMISSION DENIED") > 0
		ИЛИ СтрНайти(ТекстВРег, "INSUFFICIENT RIGHTS") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Проверяем ошибки RLS (ограничения на уровне записей)
	Если СтрНайти(ТекстВРег, "RLS") > 0
		ИЛИ СтрНайти(ТекстВРег, "ОГРАНИЧЕНИЕ ДАННЫХ") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция СформироватьОтветОшибку(КодОшибки, СообщениеОшибки, ИдентификаторЗапроса)
	ОтветОшибка = Новый Структура;
	ОтветОшибка.Вставить("jsonrpc", "2.0");
	ОтветОшибка.Вставить("id", ИдентификаторЗапроса);
	
	Ошибка = Новый Структура;
	Ошибка.Вставить("code", КодОшибки);
	Ошибка.Вставить("message", СообщениеОшибки);
	
	ОтветОшибка.Вставить("error", Ошибка);
	
	Возврат ОтветОшибка;
КонецФункции

#КонецОбласти

