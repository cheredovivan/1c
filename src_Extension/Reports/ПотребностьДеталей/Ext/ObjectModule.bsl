
&НаСервере
Процедура ПриКомпоновкеРезультата(ДокументРезультат, ДанныеРасшифровки, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	
	// Инициализация переменных параметров
	ВидыНоменклатуры = Неопределено;
	Период = Неопределено;
	ЗаказыНаПроизводство = Неопределено;
	Цех = Неопределено;
	
	// Получение параметра ВидыНоменклатуры
	НайденныйПараметрВарианта = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ВидыНоменклатуры");
	НайденныйПараметр = Неопределено;
	Если НайденныйПараметрВарианта <> Неопределено Тогда
		НайденныйПараметр = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(НайденныйПараметрВарианта.ИдентификаторПользовательскойНастройки);
	КонецЕсли;
	Если НайденныйПараметр <> Неопределено И НайденныйПараметр.Использование Тогда
		ВидыНоменклатуры = НайденныйПараметр.Значение;
	КонецЕсли;
	
	// Получение параметра Период (СтандартныйПериод)
	НайденныйПараметрВарианта = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("Период");
	НайденныйПараметр = Неопределено;
	Если НайденныйПараметрВарианта <> Неопределено Тогда
		НайденныйПараметр = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(НайденныйПараметрВарианта.ИдентификаторПользовательскойНастройки);
	КонецЕсли;
	Если НайденныйПараметр <> Неопределено И НайденныйПараметр.Использование Тогда
		Период = НайденныйПараметр.Значение;
	КонецЕсли;
	
	// Получение параметра ЗаказыНаПроизводство
	НайденныйПараметрВарианта = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ЗаказыНаПроизводство");
	НайденныйПараметр = Неопределено;
	Если НайденныйПараметрВарианта <> Неопределено Тогда
		НайденныйПараметр = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(НайденныйПараметрВарианта.ИдентификаторПользовательскойНастройки);
	КонецЕсли;
	Если НайденныйПараметр <> Неопределено И НайденныйПараметр.Использование Тогда
		ЗаказыНаПроизводство = НайденныйПараметр.Значение;
	КонецЕсли;
	
	// Получение параметра Цех (СправочникСсылка.СтруктураПредприятия)
	НайденныйПараметрВарианта = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("Цех");
	НайденныйПараметр = Неопределено;
	Если НайденныйПараметрВарианта <> Неопределено Тогда
		НайденныйПараметр = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(НайденныйПараметрВарианта.ИдентификаторПользовательскойНастройки);
	КонецЕсли;
	Если НайденныйПараметр <> Неопределено И НайденныйПараметр.Использование Тогда
		Цех = НайденныйПараметр.Значение;
	КонецЕсли;
	
	// Получение параметра ПериодЗаказа (СтандартныйПериод) - фильтр по дате документа заказа на производство
	ПериодЗаказа = Неопределено;
	НайденныйПараметрВарианта = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ПериодЗаказа");
	НайденныйПараметр = Неопределено;
	Если НайденныйПараметрВарианта <> Неопределено Тогда
		НайденныйПараметр = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(НайденныйПараметрВарианта.ИдентификаторПользовательскойНастройки);
	КонецЕсли;
	Если НайденныйПараметр <> Неопределено И НайденныйПараметр.Использование Тогда
		ПериодЗаказа = НайденныйПараметр.Значение;
	КонецЕсли;

	
	Попытка 
		
		ТаблицаДеталей = ТаблицаДляПотребностиДеталей(ВидыНоменклатуры, Период, ЗаказыНаПроизводство, Цех, ПериодЗаказа);
		
		ВнешниеНаборыДанных = Новый Структура;
		ВнешниеНаборыДанных.Вставить("ТаблицаДеталей", ТаблицаДеталей);
		
		Настройки = КомпоновщикНастроек.Настройки;
		
		КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
		МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Настройки, ДанныеРасшифровки);
		
		ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
		ПроцессорКомпоновки.Инициализировать(МакетКомпоновки, ВнешниеНаборыДанных, ДанныеРасшифровки);
		
		ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
		ПроцессорВывода.УстановитьДокумент(ДокументРезультат);
		ПроцессорВывода.Вывести(ПроцессорКомпоновки);
		
		// Вывод описания параметров под отчётом
		ВывестиОписаниеПараметров(ДокументРезультат);

	Исключение
		Сообщить("Ошибка получения данных: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;	

КонецПроцедуры

&НаСервере
Процедура ВывестиОписаниеПараметров(ДокументРезультат)
	
	// Текст описания
	ТекстОписания = "
	|
	|Описание параметров отчета
	|==========================
	|
	|ПЕРИОД (дата потребности) - фильтрует заказы по полю Дата потребности:
	|  * Указана только дата С - заказы с датой потребности ОТ указанной
	|  * Указана только дата По - заказы с датой потребности ДО указанной  
	|  * Указаны обе даты - заказы с датой потребности В ДИАПАЗОНЕ
	|  * Не указано - все заказы
	|  Также влияет на расчет остатков и поиск приоритетных спецификаций.
	|
	|ПЕРИОД ЗАКАЗА (дата документа) - фильтрует заказы по дате создания документа:
	|  * Указана только дата С - заказы, созданные ОТ указанной даты
	|  * Указана только дата По - заказы, созданные ДО указанной даты
	|  * Указаны обе даты - заказы, созданные В ДИАПАЗОНЕ
	|  * Не указано - все заказы
	|
	|ЗАКАЗЫ НА ПРОИЗВОДСТВО - ограничивает отчет конкретными заказами.
	|
	|ВИДЫ НОМЕНКЛАТУРЫ - фильтрует по виду номенклатуры ГОТОВОГО ИЗДЕЛИЯ (не детали).
	|
	|ЦЕХ - фильтрует детали по подразделению-исполнителю первого этапа их спецификации:
	|  Для каждой детали определяется приоритетная ресурсная спецификация.
	|  В этой спецификации находится этап с минимальным номером.
	|  Подразделение этого этапа сравнивается с указанным цехом.
	|
	|ОСОБЕННОСТИ ОТЧЕТА:
	|
	|Рекурсивный поиск вложенных деталей:
	|  Отчет выбирает не только детали из этапов производства (уровень 1),
	|  но и вложенные детали из ресурсных спецификаций найденных деталей.
	|  Вложенные детали определяются по условиям:
	|  - СпособПолученияМатериала = 'Обеспечивать' или 'ПроизвестиПоСпецификации'
	|  - ВидНоменклатуры В ИЕРАРХИИ '3. Детали, сборочные единицы'
	|  Поиск выполняется рекурсивно до тех пор, пока есть вложенные детали.
	|
	|Поле ГРУППА:
	|  Формируется как цепочка иерархии: 'Изделие-Деталь1-Деталь2-...'
	|  Позволяет упорядочивать результаты так, чтобы вложенные детали
	|  находились рядом с родительскими.
	|";
	
	// Вывод текста описания построчно
	СтрокиОписания = СтрРазделить(ТекстОписания, Символы.ПС, Ложь);
	Для Каждого СтрокаОписания Из СтрокиОписания Цикл
		// Создаём область для одной строки
		МакетСтроки = Новый ТабличныйДокумент;
		ОбластьСтроки = МакетСтроки.ПолучитьОбласть(1, 1, 1, 1);
		ОбластьСтроки.Область(1, 1).Текст = СтрокаОписания;
		ОбластьСтроки.Область(1, 1).ЦветТекста = WebЦвета.Серый;
		ДокументРезультат.Вывести(ОбластьСтроки);
	КонецЦикла;
	
КонецПроцедуры  

	//Использование
	//Отчет "Потребность деталей"    
	//Эта функция возвращает таблицу для потребности деталей, состоящую из:
	//Деталь - номенклатура детали, 
	//КоличествоУпаковокТребуется - количество деталей, суммарное требуемое для обеспечения заказов на производство готовых измелий,
	//КоличествоУпаковокВНаличииДК - количество деталей, которое есть в наличии на складе "ДК", 
	//КоличествоУпаковокВНаличииЦех - количество деталей, которое есть в наличии в цехорой кладовой подразделения,
	//которое является исполнителем обеспечиваемого заказа на производство готового изделия,
	//КоличествоУпаковокОжидается - количество деталей, которое уже заказано в заказах на производство деталей,
	//ЗаказНаПроизводство (ЭтапПроизводства.Распоряжение) - заказ на производство готовых изделий, который обеспечивается деталями,
	//Изделие - готовое изделие, которое обеспечивается деталями,
	//КоличествоУпаковокДефицит - разница КоличествоУпаковокТребуется - КоличествоУпаковокВНаличииДК - КоличествоУпаковокВНаличииЦех - КоличествоУпаковокОжидается,
	//Группа - строка вида "Изделие-Деталь1-Деталь2" для упорядочивания вложенных деталей рядом с родительскими,
	//параметры:
	//ВидыНоменклатуры, Период (СтандартныйПериод), ЗаказыНаПроизводство, Цех.
	//
	//Рекурсивный поиск: отчет выбирает не только детали из этапов производства (уровень 1),
	//но и вложенные детали из ресурсных спецификаций найденных деталей (уровни 2, 3 и т.д.).
	//Вложенные детали определяются по условиям:
	//- СпособПолученияМатериала = 'Обеспечивать' или 'ПроизвестиПоСпецификации'
	//- ВидНоменклатуры В ИЕРАРХИИ '3. Детали, сборочные единицы'
	//Количество вложенных деталей рассчитывается с учетом АлгоритмРасчетаКоличества (если заполнен).
	//
	//реализация:
	//для начала нужно выбрать все этапы производства, в которых получатель - это склад "СГП", со статусом "Сформирован" или "КВыполнению" или "Начат",
	//в которых количество упаковок план - количество упаковок факт - количество упаковок отменено > 0,
	//также нужно сделать отбор по ЭтапПроизводства.Распоряжение.ДатаПотребности <= Период.ДатаОкончания,
	//и по ЭтапПроизводства.Распоряжение в ЗаказыНаПроизводство,
	//и по Изделие.ВидНоменклатуры в ВидыНоменклатуры, где Изделие - это ЭтапПроизводства.ВыходныеИзделия.
	//Далее нужно в этих этапах производства пройтись по ТЧ "ОбеспечениеМатериаламиИРаботами", выбрать оттуда строки с ВариантОбеспечения=КОбеспечению 
	// или ВариантОбеспечения=СоСклада или ВариантОбеспечения=РезервироватьПоМереПоступления и Отменено = Ложь и Производится = Ложь,
	//выбрать их количество и номенклатуру, а также склад - это склад, по которому будем считать КоличествоУпаковокВНаличииЦех.
	//
	//Далее нужно по всем деталям посчитать их наличие на складе "ДК" и в цеховой кладовой подразделения,
	//которое является исполнителем обеспечиваемого заказа на производство готового изделия, по которому требуется эта деталь.
	//
	//Если указан Цех, то отбираются только детали, у которых подразделение-исполнитель первого этапа приоритетной спецификации
	//совпадает с указанным Цехом. Приоритетная спецификация определяется на дату конца периода.
	//
	//Если указан ПериодЗаказа, то отбираются только заказы на производство, у которых дата документа попадает в этот период.

&НаСервере
Функция ПолучитьВложенныеДеталиИзСпецификаций(ТаблицаРодительскихДеталей, СоответствиеНоменклатураСпецификация, ДатаАктуальности, ГруппаВидовНоменклатурыДеталей)
	
	// Возвращает таблицу вложенных деталей с полями:
	// Деталь, КоличествоУпаковокТребуется, ЗаказНаПроизводство, Изделие, ВидНоменклатурыИзделия, Группа
	//
	// ОПТИМИЗАЦИЯ: Вместо трёх запросов и вложенных циклов используется один запрос
	// с JOIN через временную таблицу родительских деталей
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Деталь", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Результат.Колонки.Добавить("КоличествоУпаковокТребуется", Новый ОписаниеТипов("Число"));
	Результат.Колонки.Добавить("ЗаказНаПроизводство", Новый ОписаниеТипов("ДокументСсылка.ЗаказНаПроизводство2_2"));
	Результат.Колонки.Добавить("Изделие", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Результат.Колонки.Добавить("ВидНоменклатурыИзделия", Новый ОписаниеТипов("СправочникСсылка.ВидыНоменклатуры"));
	Результат.Колонки.Добавить("Группа", Новый ОписаниеТипов("Строка"));
	
	Если ТаблицаРодительскихДеталей.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Подготовка таблицы родителей со спецификациями для передачи в запрос
	ТаблицаРодителейСоСпецификациями = Новый ТаблицаЗначений;
	ТаблицаРодителейСоСпецификациями.Колонки.Добавить("РодительскаяДеталь", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	ТаблицаРодителейСоСпецификациями.Колонки.Добавить("Спецификация", Новый ОписаниеТипов("СправочникСсылка.РесурсныеСпецификации"));
	ТаблицаРодителейСоСпецификациями.Колонки.Добавить("КоличествоРодителя", Новый ОписаниеТипов("Число"));
	ТаблицаРодителейСоСпецификациями.Колонки.Добавить("ЗаказНаПроизводство", Новый ОписаниеТипов("ДокументСсылка.ЗаказНаПроизводство2_2"));
	ТаблицаРодителейСоСпецификациями.Колонки.Добавить("Изделие", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	ТаблицаРодителейСоСпецификациями.Колонки.Добавить("ВидНоменклатурыИзделия", Новый ОписаниеТипов("СправочникСсылка.ВидыНоменклатуры"));
	ТаблицаРодителейСоСпецификациями.Колонки.Добавить("ГруппаРодителя", Новый ОписаниеТипов("Строка"));
	
	Для Каждого СтрокаРодителя Из ТаблицаРодительскихДеталей Цикл
		Спецификация = СоответствиеНоменклатураСпецификация.Получить(СтрокаРодителя.Деталь);
		Если Спецификация <> Неопределено Тогда
			НоваяСтрока = ТаблицаРодителейСоСпецификациями.Добавить();
			НоваяСтрока.РодительскаяДеталь = СтрокаРодителя.Деталь;
			НоваяСтрока.Спецификация = Спецификация;
			НоваяСтрока.КоличествоРодителя = СтрокаРодителя.КоличествоУпаковокТребуется;
			НоваяСтрока.ЗаказНаПроизводство = СтрокаРодителя.ЗаказНаПроизводство;
			НоваяСтрока.Изделие = СтрокаРодителя.Изделие;
			НоваяСтрока.ВидНоменклатурыИзделия = СтрокаРодителя.ВидНоменклатурыИзделия;
			НоваяСтрока.ГруппаРодителя = СтрокаРодителя.Группа;
		КонецЕсли;
	КонецЦикла;
	
	Если ТаблицаРодителейСоСпецификациями.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Один запрос с JOIN: родители + материалы спецификаций + наименования
	МассивСпособыПолучения = Новый Массив;
	МассивСпособыПолучения.Добавить(Перечисления.СпособыПолученияМатериаловВСпецификации.Обеспечивать);
	МассивСпособыПолучения.Добавить(Перечисления.СпособыПолученияМатериаловВСпецификации.ПроизвестиПоСпецификации);
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ТаблицаРодителей.РодительскаяДеталь КАК РодительскаяДеталь,
	|	ТаблицаРодителей.Спецификация КАК Спецификация,
	|	ТаблицаРодителей.КоличествоРодителя КАК КоличествоРодителя,
	|	ТаблицаРодителей.ЗаказНаПроизводство КАК ЗаказНаПроизводство,
	|	ТаблицаРодителей.Изделие КАК Изделие,
	|	ТаблицаРодителей.ВидНоменклатурыИзделия КАК ВидНоменклатурыИзделия,
	|	ТаблицаРодителей.ГруппаРодителя КАК ГруппаРодителя
	|ПОМЕСТИТЬ ВТРодители
	|ИЗ
	|	&ТаблицаРодителей КАК ТаблицаРодителей
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МатериалыСпецификации.Номенклатура КАК Деталь,
	|	МатериалыСпецификации.КоличествоУпаковок КАК КоличествоУпаковок,
	|	МатериалыСпецификации.АлгоритмРасчетаКоличества КАК АлгоритмРасчетаКоличества,
	|	РесурснаяСпецификация.ОсновноеИзделиеКоличествоУпаковок КАК ОсновноеИзделиеКоличествоУпаковок,
	|	Родители.КоличествоРодителя КАК КоличествоРодителя,
	|	Родители.ЗаказНаПроизводство КАК ЗаказНаПроизводство,
	|	Родители.Изделие КАК Изделие,
	|	Родители.ВидНоменклатурыИзделия КАК ВидНоменклатурыИзделия,
	|	Родители.ГруппаРодителя КАК ГруппаРодителя,
	|	НоменклатураРодителя.Наименование КАК НаименованиеРодителя
	|ИЗ
	|	ВТРодители КАК Родители
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.РесурсныеСпецификации КАК РесурснаяСпецификация
	|		ПО Родители.Спецификация = РесурснаяСпецификация.Ссылка
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.РесурсныеСпецификации.МатериалыИУслуги КАК МатериалыСпецификации
	|		ПО РесурснаяСпецификация.Ссылка = МатериалыСпецификации.Ссылка
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК НоменклатураРодителя
	|		ПО Родители.РодительскаяДеталь = НоменклатураРодителя.Ссылка
|ГДЕ
|	МатериалыСпецификации.СпособПолученияМатериала В(&СпособыПолучения)
|	И МатериалыСпецификации.Номенклатура.ВидНоменклатуры В ИЕРАРХИИ(&ГруппаВидовНоменклатурыДеталей)";
	
	Запрос.УстановитьПараметр("ТаблицаРодителей", ТаблицаРодителейСоСпецификациями);
	Запрос.УстановитьПараметр("СпособыПолучения", МассивСпособыПолучения);
	Запрос.УстановитьПараметр("ГруппаВидовНоменклатурыДеталей", ГруппаВидовНоменклатурыДеталей);
	
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	
	// Один простой цикл по результату запроса (вместо вложенных циклов)
	Пока Выборка.Следующий() Цикл
		
		// Рассчитываем количество
		КоличествоВложеннойДетали = 0;
		
		Если Выборка.АлгоритмРасчетаКоличества <> "" Тогда
			КоличествоВложеннойДетали = Расш1_ОбщийМодульКалькуляция.ВычислитьАлгоритмРасчетаКоличества(
				Выборка.АлгоритмРасчетаКоличества, 
				Выборка.КоличествоРодителя);
		ИначеЕсли Выборка.ОсновноеИзделиеКоличествоУпаковок <> 0 Тогда
			КоличествоВложеннойДетали = Выборка.КоличествоУпаковок / Выборка.ОсновноеИзделиеКоличествоУпаковок * Выборка.КоличествоРодителя;
		КонецЕсли;
		
		Если КоличествоВложеннойДетали <= 0 Тогда
			Продолжить;
		КонецЕсли;
		
		// Формируем группу
		ГруппаВложеннойДетали = ?(Выборка.ГруппаРодителя <> "", Выборка.ГруппаРодителя + "-", "") + Выборка.НаименованиеРодителя;
		
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Деталь = Выборка.Деталь;
		НоваяСтрока.КоличествоУпаковокТребуется = КоличествоВложеннойДетали;
		НоваяСтрока.ЗаказНаПроизводство = Выборка.ЗаказНаПроизводство;
		НоваяСтрока.Изделие = Выборка.Изделие;
		НоваяСтрока.ВидНоменклатурыИзделия = Выборка.ВидНоменклатурыИзделия;
		НоваяСтрока.Группа = ГруппаВложеннойДетали;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТаблицаДляПотребностиДеталей(ВидыНоменклатуры=Неопределено, Период=Неопределено, ЗаказыНаПроизводство=Неопределено, Цех=Неопределено, ПериодЗаказа=Неопределено)
	
	// Обработка параметра Период (СтандартныйПериод)
	// Фильтр по ДатаПотребности заказа и для получения остатков
	ПериодНачалоУказано = (Период <> Неопределено И ЗначениеЗаполнено(Период.ДатаНачала));
	ПериодОкончаниеУказано = (Период <> Неопределено И ЗначениеЗаполнено(Период.ДатаОкончания));
	Если ПериодНачалоУказано Тогда
		ДатаНачалаПериода = Период.ДатаНачала;
	Иначе
		ДатаНачалаПериода = Дата(1, 1, 1);
	КонецЕсли;
	Если ПериодОкончаниеУказано Тогда
		ДатаОкончанияПериода = Период.ДатаОкончания;
	Иначе
		// Если дата окончания не указана, устанавливаем значение по умолчанию
		ДатаОкончанияПериода = Дата(2099, 12, 31, 23, 59, 59);
	КонецЕсли;
	
	// Дата для определения актуальности спецификаций
	// Если период указан - используем дату окончания периода
	// Если период не указан - используем текущую дату (а не далёкую дату в будущем)
	// Это важно для спецификаций с ограниченным сроком действия (КонецДействия)
	Если ПериодОкончаниеУказано Тогда
		ДатаАктуальностиСпецификаций = Период.ДатаОкончания;
	Иначе
		ДатаАктуальностиСпецификаций = ТекущаяДатаСеанса();
	КонецЕсли;
	
	// Обработка параметра ПериодЗаказа (СтандартныйПериод)
	// Фильтр по дате документа заказа на производство
	ПериодЗаказаНачалоУказано = (ПериодЗаказа <> Неопределено И ЗначениеЗаполнено(ПериодЗаказа.ДатаНачала));
	ПериодЗаказаОкончаниеУказано = (ПериодЗаказа <> Неопределено И ЗначениеЗаполнено(ПериодЗаказа.ДатаОкончания));
	Если ПериодЗаказаНачалоУказано Тогда
		ДатаНачалаПериодаЗаказа = ПериодЗаказа.ДатаНачала;
	Иначе
		ДатаНачалаПериодаЗаказа = Дата(1, 1, 1);
	КонецЕсли;
	Если ПериодЗаказаОкончаниеУказано Тогда
		ДатаОкончанияПериодаЗаказа = ПериодЗаказа.ДатаОкончания;
	Иначе
		ДатаОкончанияПериодаЗаказа = Дата(2099, 12, 31, 23, 59, 59);
	КонецЕсли;
	
	// Преобразование СписокЗначений в Массив для использования в запросе
	ЗаказыНаПроизводствоПараметрМассив = Ложь;
	Если ЗаказыНаПроизводство = Неопределено Тогда
		ЗаказыНаПроизводствоПараметр = Документы.ЗаказНаПроизводство2_2.ПустаяСсылка();
	ИначеЕсли ТипЗнч(ЗаказыНаПроизводство) = Тип("Массив") Тогда
		Если ЗаказыНаПроизводство.Количество() = 0 Тогда
			ЗаказыНаПроизводствоПараметр = Документы.ЗаказНаПроизводство2_2.ПустаяСсылка();
		Иначе
			ЗаказыНаПроизводствоПараметр = ЗаказыНаПроизводство;
			ЗаказыНаПроизводствоПараметрМассив = Истина;
		КонецЕсли;
	ИначеЕсли ТипЗнч(ЗаказыНаПроизводство) = Тип("СписокЗначений") Тогда
		Если ЗаказыНаПроизводство.Количество() = 0 Тогда
			ЗаказыНаПроизводствоПараметр = Документы.ЗаказНаПроизводство2_2.ПустаяСсылка();
		Иначе
			ЗаказыНаПроизводствоПараметр = Новый Массив;
			Для Каждого ЭлементСписка Из ЗаказыНаПроизводство Цикл
				Если ЗначениеЗаполнено(ЭлементСписка.Значение) Тогда
					ЗаказыНаПроизводствоПараметр.Добавить(ЭлементСписка.Значение);
				КонецЕсли;
			КонецЦикла;
			Если ЗаказыНаПроизводствоПараметр.Количество() = 0 Тогда
				ЗаказыНаПроизводствоПараметр = Документы.ЗаказНаПроизводство2_2.ПустаяСсылка();
			Иначе
				ЗаказыНаПроизводствоПараметрМассив = Истина;
			КонецЕсли;
		КонецЕсли;
	Иначе
		// Одно значение тоже преобразуем в массив для использования оператора В() в запросе
		// Но если это пустая ссылка, используем её напрямую
		Если ЗначениеЗаполнено(ЗаказыНаПроизводство) Тогда
			ЗаказыНаПроизводствоПараметр = Новый Массив;
			ЗаказыНаПроизводствоПараметр.Добавить(ЗаказыНаПроизводство);
			ЗаказыНаПроизводствоПараметрМассив = Истина;
		Иначе
			ЗаказыНаПроизводствоПараметр = Документы.ЗаказНаПроизводство2_2.ПустаяСсылка();
		КонецЕсли;
	КонецЕсли;
	
	ВидыНоменклатурыПараметрМассив = Ложь;
	Если ВидыНоменклатуры = Неопределено Тогда
		ВидыНоменклатурыПараметр = Справочники.ВидыНоменклатуры.ПустаяСсылка();
	ИначеЕсли ТипЗнч(ВидыНоменклатуры) = Тип("Массив") Тогда
		Если ВидыНоменклатуры.Количество() = 0 Тогда
			ВидыНоменклатурыПараметр = Справочники.ВидыНоменклатуры.ПустаяСсылка();
		Иначе
			ВидыНоменклатурыПараметр = ВидыНоменклатуры;
			ВидыНоменклатурыПараметрМассив = Истина;
		КонецЕсли;
	ИначеЕсли ТипЗнч(ВидыНоменклатуры) = Тип("СписокЗначений") Тогда
		Если ВидыНоменклатуры.Количество() = 0 Тогда
			ВидыНоменклатурыПараметр = Справочники.ВидыНоменклатуры.ПустаяСсылка();
		Иначе
			ВидыНоменклатурыПараметр = Новый Массив;
			Для Каждого ЭлементСписка Из ВидыНоменклатуры Цикл
				Если ЗначениеЗаполнено(ЭлементСписка.Значение) Тогда
					ВидыНоменклатурыПараметр.Добавить(ЭлементСписка.Значение);
				КонецЕсли;
			КонецЦикла;
			Если ВидыНоменклатурыПараметр.Количество() = 0 Тогда
				ВидыНоменклатурыПараметр = Справочники.ВидыНоменклатуры.ПустаяСсылка();
			Иначе
				ВидыНоменклатурыПараметрМассив = Истина;
			КонецЕсли;
		КонецЕсли;
	Иначе
		// Одно значение тоже преобразуем в массив для использования оператора В() в запросе
		// Но если это пустая ссылка, используем её напрямую
		Если ЗначениеЗаполнено(ВидыНоменклатуры) Тогда
			ВидыНоменклатурыПараметр = Новый Массив;
			ВидыНоменклатурыПараметр.Добавить(ВидыНоменклатуры);
			ВидыНоменклатурыПараметрМассив = Истина;
		Иначе
			ВидыНоменклатурыПараметр = Справочники.ВидыНоменклатуры.ПустаяСсылка();
		КонецЕсли;
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.Текст = 
	"// ШАГ 2: Получение выходных изделий из отобранных этапов производства
	|// Для исходных этапов (из ВТЭтапыДляОтбора) используется их собственное изделие (первое из ВыходныеИзделия)
	|// Для предшественников (НЕ из ВТЭтапыДляОтбора) используется изделие исходного этапа из таблицы связей ВТСвязиЭтапов
	|// ВАЖНО: Соединение с ВТСвязиЭтапов используется ТОЛЬКО для чистых предшественников, чтобы избежать задвоения
	|// исходных этапов, которые одновременно являются предшественниками других этапов
	|// ВАЖНО: Используются ЛЕВЫЕ СОЕДИНЕНИЯ, чтобы включить этапы-предшественники без ВыходныеИзделия
	|// (промежуточные этапы могут не иметь записей в ВыходныеИзделия, но иметь материалы в ОбеспечениеМатериаламиИРаботами)
	|// Результат: исходные этапы (уже отфильтрованные) и все предшественники с изделиями исходных этапов
	|ВЫБРАТЬ
	|	Этапы.Ссылка КАК ЭтапПроизводства,
	|	Этапы.Распоряжение КАК ЗаказНаПроизводство,
	|	Этапы.Подразделение КАК Подразделение,
	|	ВЫБОР
	|		КОГДА ВТСвязиЭтапов.ИзделиеИсходногоЭтапа ЕСТЬ NULL
	|		ТОГДА ПервоеВыходноеИзделие.Номенклатура
	|		ИНАЧЕ ВТСвязиЭтапов.ИзделиеИсходногоЭтапа
	|	КОНЕЦ КАК Изделие
	|ПОМЕСТИТЬ ВТЭтапыПроизводстваОтфильтрованные
	|ИЗ
	|	Документ.ЭтапПроизводства2_2 КАК Этапы
	|		ЛЕВОЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
	|			ВыходныеИзделия.Ссылка КАК Ссылка,
	|			МИНИМУМ(ВыходныеИзделия.НомерСтроки) КАК МинимальныйНомерСтроки
	|		ИЗ
	|			Документ.ЭтапПроизводства2_2.ВыходныеИзделия КАК ВыходныеИзделия
	|		ГДЕ
	|			ВыходныеИзделия.Ссылка В(ВЫБРАТЬ ВТЭтапыДляОтбораСПредшественниками.Ссылка ИЗ ВТЭтапыДляОтбораСПредшественниками КАК ВТЭтапыДляОтбораСПредшественниками)
	|		СГРУППИРОВАТЬ ПО
	|			ВыходныеИзделия.Ссылка) КАК ПервыеСтрокиВыходныхИзделий
	|		ПО Этапы.Ссылка = ПервыеСтрокиВыходныхИзделий.Ссылка
	|		ЛЕВОЕ СОЕДИНЕНИЕ Документ.ЭтапПроизводства2_2.ВыходныеИзделия КАК ПервоеВыходноеИзделие
	|		ПО ПервоеВыходноеИзделие.Ссылка = ПервыеСтрокиВыходныхИзделий.Ссылка
	|			И ПервоеВыходноеИзделие.НомерСтроки = ПервыеСтрокиВыходныхИзделий.МинимальныйНомерСтроки
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТСвязиЭтапов КАК ВТСвязиЭтапов
	|		ПО Этапы.Ссылка = ВТСвязиЭтапов.Этап
	|			И Этапы.Ссылка НЕ В (ВЫБРАТЬ ВТЭтапыДляОтбора.Ссылка ИЗ ВТЭтапыДляОтбора КАК ВТЭтапыДляОтбора)
	|ГДЕ
	|	Этапы.Ссылка В(ВЫБРАТЬ ВТЭтапыДляОтбораСПредшественниками.Ссылка ИЗ ВТЭтапыДляОтбораСПредшественниками КАК ВТЭтапыДляОтбораСПредшественниками)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 3: Получение потребности в деталях из обеспечения материалами отфильтрованных этапов
	|// Из табличной части ОбеспечениеМатериаламиИРаботами этапов извлекаются:
	|// - номенклатура детали (материала)
	|// - склад цеха, где требуется деталь
	|// - заказ на производство изделия
	|// - изделие, для которого требуется деталь
	|// - подразделение-исполнитель этапа
	|// - суммарное количество требуемых деталей
	|// Условия отбора строк обеспечения:
	|// - вариант обеспечения: КОбеспечению, СоСклада, РезервироватьПоМереПоступления
	|// - строка не отменена
	|// - деталь не производится (не Производится)
	|// Результат: потребность в деталях с группировкой по номенклатуре, складу, заказу, изделию и подразделению
	|ВЫБРАТЬ
	|	Обеспечение.Номенклатура КАК Деталь,
	|	Обеспечение.Склад КАК СкладЦех,
	|	ВТЭтапыПроизводстваОтфильтрованные.ЗаказНаПроизводство КАК ЗаказНаПроизводство,
	|	ВТЭтапыПроизводстваОтфильтрованные.Изделие КАК Изделие,
	|	ВТЭтапыПроизводстваОтфильтрованные.Подразделение КАК Подразделение,
	|	СУММА(Обеспечение.Количество) КАК КоличествоУпаковокТребуется
	|ПОМЕСТИТЬ ВТПотребностьДеталей
	|ИЗ
	|	ВТЭтапыПроизводстваОтфильтрованные КАК ВТЭтапыПроизводстваОтфильтрованные
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ЭтапПроизводства2_2.ОбеспечениеМатериаламиИРаботами КАК Обеспечение
	|		ПО ВТЭтапыПроизводстваОтфильтрованные.ЭтапПроизводства = Обеспечение.Ссылка
|ГДЕ
|	Обеспечение.ВариантОбеспечения В(&ВариантыОбеспечения)
|	И НЕ Обеспечение.Отменено
|	И НЕ Обеспечение.Производится
|	И Обеспечение.Номенклатура.ВидНоменклатуры В ИЕРАРХИИ(&ГруппаВидовНоменклатурыДеталей)
	|
	|СГРУППИРОВАТЬ ПО
	|	Обеспечение.Номенклатура,
	|	Обеспечение.Склад,
	|	ВТЭтапыПроизводстваОтфильтрованные.ЗаказНаПроизводство,
	|	ВТЭтапыПроизводстваОтфильтрованные.Изделие,
	|	ВТЭтапыПроизводстваОтфильтрованные.Подразделение
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 4: Дополнительная группировка потребности в деталях
	|// Выполняется повторная группировка для суммирования количества по одинаковым комбинациям:
	|// - номенклатура детали
	|// - склад цеха
	|// - заказ на производство
	|// - изделие
	|// - подразделение
	|// Это необходимо, так как одна и та же деталь может требоваться в нескольких строках обеспечения одного этапа
	|// Результат: окончательно сгруппированная потребность в деталях
	|ВЫБРАТЬ
	|	Потребность.Деталь КАК Номенклатура,
	|	Потребность.СкладЦех КАК СкладЦех,
	|	Потребность.ЗаказНаПроизводство КАК ЗаказНаПроизводство,
	|	Потребность.Изделие КАК Изделие,
	|	Потребность.Подразделение КАК Подразделение,
	|	СУММА(Потребность.КоличествоУпаковокТребуется) КАК КоличествоУпаковокТребуется
	|ПОМЕСТИТЬ ВТПотребностьСгруппированная
	|ИЗ
	|	ВТПотребностьДеталей КАК Потребность
	|
	|СГРУППИРОВАТЬ ПО
	|	Потребность.Деталь,
	|	Потребность.СкладЦех,
	|	Потребность.ЗаказНаПроизводство,
	|	Потребность.Изделие,
	|	Потребность.Подразделение
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 5: Подготовка списка номенклатур для оптимизации запросов остатков
	|// Из потребности извлекаются уникальные номенклатуры деталей
	|// Этот список будет использоваться для фильтрации остатков и ожидаемого количества,
	|// чтобы не запрашивать данные по всей номенклатуре, а только по нужным деталям
	|// Результат: список уникальных номенклатур из потребности
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Потребность.Номенклатура КАК Номенклатура
	|ПОМЕСТИТЬ ВТНоменклатурыДляОстатков
	|ИЗ
	|	ВТПотребностьСгруппированная КАК Потребность
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 6: Подготовка списка складов ДК для запроса остатков
	|// Выбираются все склады с наименованием ""ДК""
	|// Эти склады будут использоваться для получения остатков деталей на центральном складе
	|// Результат: список ссылок на склады ДК
	|ВЫБРАТЬ
	|	СкладДК.Ссылка КАК Склад
	|ПОМЕСТИТЬ ВТСкладыДК
	|ИЗ
	|	Справочник.Склады КАК СкладДК
	|ГДЕ
	|	СкладДК.Наименование = &СкладДКНаименование
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 7: Получение остатков деталей на складе ДК
	|// Используется виртуальная таблица ТоварыНаСкладах.Остатки для получения актуальных остатков
	|// Фильтры:
	|// - только склады ДК (из ВТСкладыДК)
	|// - только номенклатуры из потребности (из ВТНоменклатурыДляОстатков)
	|// - назначение пустое (основные остатки, не зарезервированные)
	|// - дата остатков: конец текущего дня
	|// Отрицательные остатки обнуляются (защита от ошибок данных)
	|// Результат: остатки деталей на складе ДК, сгруппированные по номенклатуре
	|ВЫБРАТЬ
	|	ТоварыНаСкладахОстатки.Номенклатура КАК Номенклатура,
	|	СУММА(ВЫБОР
	|		КОГДА ТоварыНаСкладахОстатки.ВНаличииОстаток < 0
	|			ТОГДА 0
	|		ИНАЧЕ ТоварыНаСкладахОстатки.ВНаличииОстаток
	|	КОНЕЦ) КАК КоличествоУпаковокВНаличииДК
	|ПОМЕСТИТЬ ВТОстаткиДК
	|ИЗ
	|	РегистрНакопления.ТоварыНаСкладах.Остатки(
	|			&ДатаКон,
	|			Склад В (ВЫБРАТЬ ВТСкладыДК.Склад ИЗ ВТСкладыДК КАК ВТСкладыДК)
	|				И Номенклатура В (ВЫБРАТЬ ВТНоменклатурыДляОстатков.Номенклатура ИЗ ВТНоменклатурыДляОстатков КАК ВТНоменклатурыДляОстатков)
	|				И Назначение = ЗНАЧЕНИЕ(Справочник.Назначения.ПустаяСсылка)) КАК ТоварыНаСкладахОстатки
	|
	|СГРУППИРОВАТЬ ПО
	|	ТоварыНаСкладахОстатки.Номенклатура
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 8: Подготовка списка цеховых складов с подразделениями
	|// Выбираются все склады, помеченные как цеховые кладовые (ЦеховаяКладовая = ИСТИНА)
	|// Для каждого склада получается подразделение, которому он принадлежит
	|// Эти склады будут использоваться для получения остатков деталей в цехах
	|// Результат: список цеховых складов с привязкой к подразделениям
	|ВЫБРАТЬ
	|	СкладЦех.Ссылка КАК Склад,
	|	СкладЦех.Подразделение КАК Подразделение
	|ПОМЕСТИТЬ ВТСкладыЦех
	|ИЗ
	|	Справочник.Склады КАК СкладЦех
	|ГДЕ
	|	СкладЦех.ЦеховаяКладовая = ИСТИНА
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 9: Получение остатков деталей на цеховых складах подразделений
	|// Используется виртуальная таблица ТоварыНаСкладах.Остатки для получения актуальных остатков
	|// Фильтры:
	|// - только цеховые склады (из ВТСкладыЦех)
	|// - только номенклатуры из потребности (из ВТНоменклатурыДляОстатков)
	|// - назначение пустое (основные остатки, не зарезервированные)
	|// - дата остатков: конец текущего дня
	|// Отрицательные остатки обнуляются (защита от ошибок данных)
	|// Остатки группируются по номенклатуре, складу и подразделению,
	|// так как одна и та же деталь может быть на разных цеховых складах разных подразделений
	|// Результат: остатки деталей на цеховых складах, сгруппированные по номенклатуре, складу и подразделению
	|ВЫБРАТЬ
	|	ТоварыНаСкладахОстатки.Номенклатура КАК Номенклатура,
	|	ТоварыНаСкладахОстатки.Склад КАК Склад,
	|	ВТСкладыЦех.Подразделение КАК Подразделение,
	|	СУММА(ВЫБОР
	|		КОГДА ТоварыНаСкладахОстатки.ВНаличииОстаток < 0
	|			ТОГДА 0
	|		ИНАЧЕ ТоварыНаСкладахОстатки.ВНаличииОстаток
	|	КОНЕЦ) КАК КоличествоУпаковокВНаличииЦех
	|ПОМЕСТИТЬ ВТОстаткиЦех
	|ИЗ
	|	РегистрНакопления.ТоварыНаСкладах.Остатки(
	|			&ДатаКон,
	|			Склад В (ВЫБРАТЬ ВТСкладыЦех.Склад ИЗ ВТСкладыЦех КАК ВТСкладыЦех)
	|				И Номенклатура В (ВЫБРАТЬ ВТНоменклатурыДляОстатков.Номенклатура ИЗ ВТНоменклатурыДляОстатков КАК ВТНоменклатурыДляОстатков)
	|				И Назначение = ЗНАЧЕНИЕ(Справочник.Назначения.ПустаяСсылка)) КАК ТоварыНаСкладахОстатки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТСкладыЦех КАК ВТСкладыЦех
	|		ПО ТоварыНаСкладахОстатки.Склад = ВТСкладыЦех.Склад
	|
	|СГРУППИРОВАТЬ ПО
	|	ТоварыНаСкладахОстатки.Номенклатура,
	|	ТоварыНаСкладахОстатки.Склад,
	|	ВТСкладыЦех.Подразделение
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 10: Выбор этапов производства для расчета ожидаемого количества деталей
	|// Отбираются этапы производства, которые:
	|// - имеют статусы: Сформирован, КВыполнению, Начат
	|// - имеют остаток упаковок к выпуску > 0 (План - Факт - Отменено)
	|// - связаны с заказом на производство (Распоряжение не пустое)
	|// ОстатокКВыпуску = План - Факт - Отменено (количество, которое осталось выпустить)
	|// Результат: список этапов производства с привязкой к заказам
	|ВЫБРАТЬ
	|	Этапы.Ссылка КАК ЭтапПроизводства,
	|	Этапы.Распоряжение КАК ЗаказНаПроизводство,
	|	Этапы.КоличествоУпаковокПлан - Этапы.КоличествоУпаковокФакт - Этапы.КоличествоУпаковокОтменено КАК ОстатокКВыпуску
	|ПОМЕСТИТЬ ВТЗаказыДляОтбора
	|ИЗ
	|	Документ.ЭтапПроизводства2_2 КАК Этапы
	|ГДЕ
	|	Этапы.Статус В(&Статусы)
	|	И Этапы.Проведен
	|	И Этапы.КоличествоУпаковокПлан - Этапы.КоличествоУпаковокФакт - Этапы.КоличествоУпаковокОтменено > 0
	|	И НЕ Этапы.Распоряжение ЕСТЬ NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 11: Расчет ожидаемого количества деталей из этапов производства деталей
	|// В этапе производства всегда одна номенклатура в ВыходныеИзделия.
	|// Но может быть несколько строк с разными назначениями - группируем по (Этап, Номенклатура).
	|// Берём ОстатокКВыпуску из шапки этапа для каждой уникальной пары (Этап, Номенклатура).
	|// Фильтр по ВТНоменклатурыДляОстатков применяется во внешнем запросе для избежания дублирования.
	|// Результат: ожидаемое количество деталей по номенклатурам
	|ВЫБРАТЬ
	|	ЭтапыСНоменклатурой.Номенклатура КАК Номенклатура,
	|	СУММА(ЭтапыСНоменклатурой.ОстатокКВыпуску) КАК КоличествоУпаковокОжидается
	|ПОМЕСТИТЬ ВТЗаказыДеталей
	|ИЗ
	|	(ВЫБРАТЬ
	|		ВыходныеИзделия.Номенклатура КАК Номенклатура,
	|		ВТЗаказыДляОтбора.ЭтапПроизводства КАК ЭтапПроизводства,
	|		МАКСИМУМ(ВТЗаказыДляОтбора.ОстатокКВыпуску) КАК ОстатокКВыпуску
	|	ИЗ
	|		Документ.ЭтапПроизводства2_2.ВыходныеИзделия КАК ВыходныеИзделия
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТЗаказыДляОтбора КАК ВТЗаказыДляОтбора
	|			ПО ВыходныеИзделия.Ссылка = ВТЗаказыДляОтбора.ЭтапПроизводства
	|	ГДЕ
	|		НЕ ВыходныеИзделия.Отменено
	|	СГРУППИРОВАТЬ ПО
	|		ВыходныеИзделия.Номенклатура,
	|		ВТЗаказыДляОтбора.ЭтапПроизводства) КАК ЭтапыСНоменклатурой
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТНоменклатурыДляОстатков КАК ВТНоменклатурыДляОстатков
	|		ПО ЭтапыСНоменклатурой.Номенклатура = ВТНоменклатурыДляОстатков.Номенклатура
	|
	|СГРУППИРОВАТЬ ПО
	|	ЭтапыСНоменклатурой.Номенклатура
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 12: Определение первой записи по каждой детали
	|// Создается временная таблица с нумерацией записей по каждой детали
	|// Нумерация выполняется по комбинации ЗаказНаПроизводство + Изделие для каждой детали
	|// Это необходимо для того, чтобы остатки и ожидаемое количество учитывались только один раз
	|// (в первой записи по детали), чтобы не искажать итоги в отчете
	|// Результат: потребность с нумерацией строк по деталям
	|ВЫБРАТЬ
	|	Потребность.Номенклатура,
	|	Потребность.ЗаказНаПроизводство,
	|	Потребность.Изделие,
	|	Потребность.Подразделение,
	|	Потребность.СкладЦех,
	|	Потребность.КоличествоУпаковокТребуется,
	|	ЕСТЬNULL(Подсчет.КоличествоПредыдущих, 0) + 1 КАК НомерСтроки
	|ПОМЕСТИТЬ ВТПотребностьСНумерацией
	|ИЗ
	|	ВТПотребностьСгруппированная КАК Потребность
	|		ЛЕВОЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
	|			Потребность2.Номенклатура,
	|			Потребность2.ЗаказНаПроизводство,
	|			Потребность2.Изделие,
	|			КОЛИЧЕСТВО(Потребность3.Номенклатура) КАК КоличествоПредыдущих
	|		ИЗ
	|			ВТПотребностьСгруппированная КАК Потребность2
	|				ЛЕВОЕ СОЕДИНЕНИЕ ВТПотребностьСгруппированная КАК Потребность3
	|				ПО Потребность3.Номенклатура = Потребность2.Номенклатура
	|					И (Потребность3.ЗаказНаПроизводство < Потребность2.ЗаказНаПроизводство
	|						ИЛИ (Потребность3.ЗаказНаПроизводство = Потребность2.ЗаказНаПроизводство
	|							И Потребность3.Изделие < Потребность2.Изделие))
	|		СГРУППИРОВАТЬ ПО
	|			Потребность2.Номенклатура,
	|			Потребность2.ЗаказНаПроизводство,
	|			Потребность2.Изделие) КАК Подсчет
	|		ПО Потребность.Номенклатура = Подсчет.Номенклатура
	|			И Потребность.ЗаказНаПроизводство = Подсчет.ЗаказНаПроизводство
	|			И Потребность.Изделие = Подсчет.Изделие
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|// ШАГ 13: Финальный запрос - объединение всех данных и расчет дефицита
	|// Объединяются все собранные данные:
	|// - потребность в деталях (из ВТПотребностьСНумерацией)
	|// - остатки на складе ДК (из ВТОстаткиДК) - ЛЕВОЕ СОЕДИНЕНИЕ
	|// - остатки на цеховых складах (из ВТОстаткиЦех) - ЛЕВОЕ СОЕДИНЕНИЕ с учетом подразделения и склада
	|// - ожидаемое количество из заказов (из ВТЗаказыДеталей) - ЛЕВОЕ СОЕДИНЕНИЕ
	|// - вид номенклатуры изделия (из справочника Номенклатура) - ЛЕВОЕ СОЕДИНЕНИЕ
	|// Остатки и ожидаемое количество учитываются только для первой записи по каждой детали (НомерСтроки = 1)
	|// Для каждой детали рассчитывается дефицит:
	|// Дефицит = Требуется - ВНаличииДК - ВНаличииЦех - Ожидается (только для первой строки)
	|// Если остатков или ожидаемого количества нет, используется 0 (ЕСТЬNULL)
	|// Результат: итоговая таблица с потребностью, остатками, ожидаемым количеством и дефицитом
	|ВЫБРАТЬ
	|	Потребность.Номенклатура КАК Деталь,
	|	СУММА(Потребность.КоличествоУпаковокТребуется) КАК КоличествоУпаковокТребуется,
	|	МАКСИМУМ(ВЫБОР
	|		КОГДА Потребность.НомерСтроки = 1
	|			ТОГДА ЕСТЬNULL(ОстаткиДК.КоличествоУпаковокВНаличииДК, 0)
	|		ИНАЧЕ 0
	|	КОНЕЦ) КАК КоличествоУпаковокВНаличииДК,
	|	МАКСИМУМ(ВЫБОР
	|		КОГДА Потребность.НомерСтроки = 1
	|			ТОГДА ЕСТЬNULL(ОстаткиЦех.КоличествоУпаковокВНаличииЦех, 0)
	|		ИНАЧЕ 0
	|	КОНЕЦ) КАК КоличествоУпаковокВНаличииЦех,
	|	МАКСИМУМ(ВЫБОР
	|		КОГДА Потребность.НомерСтроки = 1
	|			ТОГДА ЕСТЬNULL(ЗаказыДетали.КоличествоУпаковокОжидается, 0)
	|		ИНАЧЕ 0
	|	КОНЕЦ) КАК КоличествоУпаковокОжидается,
	|	Потребность.ЗаказНаПроизводство КАК ЗаказНаПроизводство,
	|	Потребность.Изделие КАК Изделие,
	|	ВЫБОР
	|		КОГДА НоменклатураИзделия.ВидНоменклатуры ЕСТЬ NULL
	|		ТОГДА ЗНАЧЕНИЕ(Справочник.ВидыНоменклатуры.ПустаяСсылка)
	|		ИНАЧЕ НоменклатураИзделия.ВидНоменклатуры
	|	КОНЕЦ КАК ВидНоменклатурыИзделия,
	|	СУММА(Потребность.КоличествоУпаковокТребуется) 
	|		- МАКСИМУМ(ВЫБОР
	|			КОГДА Потребность.НомерСтроки = 1
	|				ТОГДА ЕСТЬNULL(ОстаткиДК.КоличествоУпаковокВНаличииДК, 0)
	|			ИНАЧЕ 0
	|		КОНЕЦ)
	|		- МАКСИМУМ(ВЫБОР
	|			КОГДА Потребность.НомерСтроки = 1
	|				ТОГДА ЕСТЬNULL(ОстаткиЦех.КоличествоУпаковокВНаличииЦех, 0)
	|			ИНАЧЕ 0
	|		КОНЕЦ) КАК КоличествоУпаковокДефицит
//	|		- МАКСИМУМ(ВЫБОР
//	|			КОГДА Потребность.НомерСтроки = 1
//	|				ТОГДА ЕСТЬNULL(ЗаказыДетали.КоличествоУпаковокОжидается, 0)
//	|			ИНАЧЕ 0
//	|		КОНЕЦ) КАК КоличествоУпаковокДефицит
	|ИЗ
	|	ВТПотребностьСНумерацией КАК Потребность
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК НоменклатураИзделия
	|		ПО Потребность.Изделие = НоменклатураИзделия.Ссылка
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТОстаткиДК КАК ОстаткиДК
	|		ПО Потребность.Номенклатура = ОстаткиДК.Номенклатура
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТОстаткиЦех КАК ОстаткиЦех
	|		ПО Потребность.Номенклатура = ОстаткиЦех.Номенклатура
	|			И Потребность.Подразделение = ОстаткиЦех.Подразделение
	|			И Потребность.СкладЦех = ОстаткиЦех.Склад
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТЗаказыДеталей КАК ЗаказыДетали
	|		ПО Потребность.Номенклатура = ЗаказыДетали.Номенклатура
	|
	|СГРУППИРОВАТЬ ПО
	|	Потребность.Номенклатура,
	|	Потребность.ЗаказНаПроизводство,
	|	Потребность.Изделие,
	|	НоменклатураИзделия.ВидНоменклатуры";

	// Установка параметров для основного запроса
	МассивСтатусов = Новый Массив;
	МассивСтатусов.Добавить(Перечисления.СтатусыЭтаповПроизводства2_2.Сформирован);
	МассивСтатусов.Добавить(Перечисления.СтатусыЭтаповПроизводства2_2.КВыполнению);
	МассивСтатусов.Добавить(Перечисления.СтатусыЭтаповПроизводства2_2.Начат);
	Запрос.УстановитьПараметр("Статусы", МассивСтатусов);
	Запрос.УстановитьПараметр("ДатаОкончанияПериода", ДатаОкончанияПериода);
	Запрос.УстановитьПараметр("ДатаКон", КонецДня(ДатаОкончанияПериода));
	Запрос.УстановитьПараметр("ЗаказыНаПроизводство", ЗаказыНаПроизводствоПараметр);
	Запрос.УстановитьПараметр("ВидыНоменклатуры", ВидыНоменклатурыПараметр);

	ГруппаВидовНоменклатурыДеталей = Справочники.ВидыНоменклатуры.НайтиПоНаименованию("3. Детали, сборочные единицы");
	Запрос.УстановитьПараметр("ГруппаВидовНоменклатурыДеталей", ГруппаВидовНоменклатурыДеталей);

	Запрос.УстановитьПараметр("СкладДКНаименование", "Детальная кладовая");

	МассивВариантовОбеспечения = Новый Массив;
	МассивВариантовОбеспечения.Добавить(Перечисления.ВариантыОбеспечения.КОбеспечению);
	МассивВариантовОбеспечения.Добавить(Перечисления.ВариантыОбеспечения.СоСклада);
	МассивВариантовОбеспечения.Добавить(Перечисления.ВариантыОбеспечения.РезервироватьПоМереПоступления);
	Запрос.УстановитьПараметр("ВариантыОбеспечения", МассивВариантовОбеспечения);
	
	// ЭЛЕГАНТНОЕ РЕШЕНИЕ: Сначала находим все этапы и предшественников, затем выполняем основной запрос
	// Это позволяет избежать проблем с разделением запроса и пересозданием временных таблиц
	
	// ШАГ 1: Создаем менеджер временных таблиц
	МенеджерВТ = Новый МенеджерВременныхТаблиц;
	
	// ПОДГОТОВКА: Выполняем запрос для получения начальных этапов
	// Фильтрация по виду номенклатуры изделия применяется уже на этом этапе
	ЗапросНачальныхЭтапов = Новый Запрос;
	ЗапросНачальныхЭтапов.МенеджерВременныхТаблиц = МенеджерВТ;
	ЗапросНачальныхЭтапов.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ВыходныеИзделияСГП.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ВТЭтапыДляОтбора
	|ИЗ
	|	Документ.ЭтапПроизводства2_2.ВыходныеИзделия КАК ВыходныеИзделияСГП
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Склады КАК СкладСГП
	|		ПО ВЫРАЗИТЬ(ВыходныеИзделияСГП.Получатель КАК Справочник.Склады) = СкладСГП.Ссылка
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ЭтапПроизводства2_2 КАК ЭтапПроизводства2_2
	|		ПО ВЫРАЗИТЬ(ВыходныеИзделияСГП.Ссылка КАК Документ.ЭтапПроизводства2_2) = ЭтапПроизводства2_2.Ссылка
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК СправочникНоменклатура
	|		ПО ВыходныеИзделияСГП.Номенклатура = СправочникНоменклатура.Ссылка
	|ГДЕ
	|	ЭтапПроизводства2_2.Статус В(&Статусы)
	|	И НЕ ЭтапПроизводства2_2.ПометкаУдаления
	|	И ЭтапПроизводства2_2.КоличествоУпаковокПлан - ЭтапПроизводства2_2.КоличествоУпаковокФакт - ЭтапПроизводства2_2.КоличествоУпаковокОтменено > 0
	|	И (ВЫБОР
	|			КОГДА &ПериодНачалоУказано = ИСТИНА
	|				ТОГДА ЭтапПроизводства2_2.Распоряжение.ДатаПотребности >= &ДатаНачалаПериода
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ)
	|	И (ВЫБОР
	|			КОГДА &ПериодОкончаниеУказано = ИСТИНА
	|				ТОГДА ЭтапПроизводства2_2.Распоряжение.ДатаПотребности <= &ДатаОкончанияПериода
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ)
	|	И (ВЫБОР
	|			КОГДА &ЗаказыНаПроизводствоМассив = ИСТИНА
	|				ТОГДА ЭтапПроизводства2_2.Распоряжение В(&ЗаказыНаПроизводство)
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ)
	|	И СкладСГП.Наименование = ""СГП""
	|	И (ВЫБОР
	|			КОГДА &ВидыНоменклатурыМассив = ИСТИНА
	|				ТОГДА СправочникНоменклатура.ВидНоменклатуры В(&ВидыНоменклатуры)
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ)
	|	И (ВЫБОР
	|			КОГДА &ПериодЗаказаНачалоУказано = ИСТИНА
	|				ТОГДА ЭтапПроизводства2_2.Распоряжение.Дата >= &ДатаНачалаПериодаЗаказа
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ)
	|	И (ВЫБОР
	|			КОГДА &ПериодЗаказаОкончаниеУказано = ИСТИНА
	|				ТОГДА ЭтапПроизводства2_2.Распоряжение.Дата <= &ДатаОкончанияПериодаЗаказа
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ)
	|;
	|
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ВТЭтапыДляОтбора.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ВТЭтапыДляОтбораСПредшественниками
	|ИЗ
	|	ВТЭтапыДляОтбора КАК ВТЭтапыДляОтбора
	|;";
	
	// Установка параметров для запроса начальных этапов
	ЗапросНачальныхЭтапов.УстановитьПараметр("Статусы", МассивСтатусов);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ПериодНачалоУказано", ПериодНачалоУказано);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ПериодОкончаниеУказано", ПериодОкончаниеУказано);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ДатаНачалаПериода", ДатаНачалаПериода);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ДатаОкончанияПериода", ДатаОкончанияПериода);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ЗаказыНаПроизводство", ЗаказыНаПроизводствоПараметр);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ЗаказыНаПроизводствоМассив", ЗаказыНаПроизводствоПараметрМассив);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ВидыНоменклатуры", ВидыНоменклатурыПараметр);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ВидыНоменклатурыМассив", ВидыНоменклатурыПараметрМассив);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ПериодЗаказаНачалоУказано", ПериодЗаказаНачалоУказано);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ПериодЗаказаОкончаниеУказано", ПериодЗаказаОкончаниеУказано);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ДатаНачалаПериодаЗаказа", ДатаНачалаПериодаЗаказа);
	ЗапросНачальныхЭтапов.УстановитьПараметр("ДатаОкончанияПериодаЗаказа", ДатаОкончанияПериодаЗаказа);
	ЗапросНачальныхЭтапов.Выполнить();
	
	// === ДИАГНОСТИКА: Начальные этапы (СГП) ===
	ЗапросДиагностики = Новый Запрос;
	ЗапросДиагностики.МенеджерВременныхТаблиц = МенеджерВТ;
	ЗапросДиагностики.Текст = "ВЫБРАТЬ Этапы.Ссылка.Номер КАК Номер ИЗ ВТЭтапыДляОтбора КАК Этапы";
	РезДиаг = ЗапросДиагностики.Выполнить().Выгрузить();
	СтрокаДиаг = "=== ДИАГНОСТИКА ПотребностьДеталей ===" + Символы.ПС;
	СтрокаДиаг = СтрокаДиаг + "ГруппаВидовНоменклатурыДеталей = " + ГруппаВидовНоменклатурыДеталей + Символы.ПС;
	СтрокаДиаг = СтрокаДиаг + "Шаг 1: Найдено начальных этапов (СГП): " + РезДиаг.Количество() + Символы.ПС;
	Для Каждого Стр Из РезДиаг Цикл
		СтрокаДиаг = СтрокаДиаг + "  - " + Стр.Номер + Символы.ПС;
	КонецЦикла;
	ЗаписьЖурналаРегистрации("ПотребностьДеталей.Диагностика", УровеньЖурналаРегистрации.Ошибка, , , СтрокаДиаг);
	// === КОНЕЦ ДИАГНОСТИКИ ===
	
	// ШАГ 3: Рекурсивный поиск всех предшественников отобранных этапов
	// Предшественники этапов определяются следующим образом:
	// Этап B является предшественником этапа A, если в табличной части Последователи этапа B
	// есть запись, где Этап = A (т.е. A является последователем B)
	// Выполняем итерации до тех пор, пока находятся новые предшественники
	// Важно: предшественники должны иметь те же условия, что и исходные этапы (статус, остаток к выпуску)
	ЗапросПредшественников = Новый Запрос;
	ЗапросПредшественников.МенеджерВременныхТаблиц = МенеджерВТ;
	ЗапросПредшественников.УстановитьПараметр("Статусы", МассивСтатусов);
	
	// Флаг для отслеживания, была ли создана таблица ВТНовыеПредшественники
	ТаблицаВТНовыеПредшественникиСоздана = Ложь;
	
	Пока Истина Цикл
		
		// Ищем предшественников для этапов из текущего списка
		// На первой итерации ищем для исходных этапов, на последующих - для найденных предшественников
		// Уничтожаем таблицу перед пересозданием, чтобы избежать ошибки "Временная таблица уже существует"
		// Уничтожаем только если таблица была создана на предыдущей итерации
		Если ТаблицаВТНовыеПредшественникиСоздана Тогда
			//BSLLS:MissingCodeTryCatchEx-off
			Попытка
				ЗапросУничтожения = Новый Запрос;
				ЗапросУничтожения.МенеджерВременныхТаблиц = МенеджерВТ;
				ЗапросУничтожения.Текст = "УНИЧТОЖИТЬ ВТНовыеПредшественники";
				//BSLLS:https:CreateQueryInCycle-off
				ЗапросУничтожения.Выполнить();
				//BSLLS:https:CreateQueryInCycle-on	
			Исключение
				// Игнорируем ошибку, если таблица не существует
			КонецПопытки;
			//BSLLS:MissingCodeTryCatchEx-on
		КонецЕсли;
		
		ЗапросПредшественников.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	Последователи.Ссылка КАК Ссылка
		|ПОМЕСТИТЬ ВТНовыеПредшественники
		|ИЗ
		|	Документ.ЭтапПроизводства2_2.Последователи КАК Последователи
		|ГДЕ
		|	Последователи.Этап В (ВЫБРАТЬ ВТЭтапыДляОтбораСПредшественниками.Ссылка ИЗ ВТЭтапыДляОтбораСПредшественниками КАК ВТЭтапыДляОтбораСПредшественниками)
		|	И Последователи.Ссылка.Проведен
		|	И НЕ Последователи.Ссылка.ПометкаУдаления
		|	И Последователи.Ссылка НЕ В (ВЫБРАТЬ ВТЭтапыДляОтбораСПредшественниками.Ссылка ИЗ ВТЭтапыДляОтбораСПредшественниками КАК ВТЭтапыДляОтбораСПредшественниками)
		|	И Последователи.Ссылка.Статус В(&Статусы)
		|	И Последователи.Ссылка.КоличествоУпаковокПлан - Последователи.Ссылка.КоличествоУпаковокФакт - Последователи.Ссылка.КоличествоУпаковокОтменено > 0
		|;
		|
		|ВЫБРАТЬ
		|	КОЛИЧЕСТВО(ВТНовыеПредшественники.Ссылка) КАК КоличествоНовыхПредшественников
		|ИЗ
		|	ВТНовыеПредшественники КАК ВТНовыеПредшественники";
		//BSLLS:https:CreateQueryInCycle-off
		РезультатПредшественников = ЗапросПредшественников.Выполнить();
		//BSLLS:https:CreateQueryInCycle-on
		// Отмечаем, что таблица была создана
		ТаблицаВТНовыеПредшественникиСоздана = Истина;
		
		// Проверяем, есть ли новые предшественники
		ВыборкаПредшественников = РезультатПредшественников.Выбрать();
		КоличествоНовыхПредшественников = 0;
		Если ВыборкаПредшественников.Следующий() Тогда
			КоличествоНовыхПредшественников = ВыборкаПредшественников.КоличествоНовыхПредшественников;
		КонецЕсли;
		
		// Если новых предшественников не найдено, выходим из цикла
		Если КоличествоНовыхПредшественников = 0 Тогда
			Прервать;
		КонецЕсли;
		
		// Добавляем найденных предшественников к общему списку
		// Сохраняем текущие данные во временную таблицу, уничтожаем основную, затем пересоздаем с добавлением новых
		ЗапросПредшественников.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ВТЭтапыДляОтбораСПредшественниками.Ссылка КАК Ссылка
		|ПОМЕСТИТЬ ВТЭтапыДляОтбораСПредшественникамиВременная
		|ИЗ
		|	ВТЭтапыДляОтбораСПредшественниками КАК ВТЭтапыДляОтбораСПредшественниками
		|;
		|
		|УНИЧТОЖИТЬ ВТЭтапыДляОтбораСПредшественниками;
		|
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ВТЭтапыДляОтбораСПредшественникамиВременная.Ссылка КАК Ссылка
		|ПОМЕСТИТЬ ВТЭтапыДляОтбораСПредшественниками
		|ИЗ
		|	ВТЭтапыДляОтбораСПредшественникамиВременная КАК ВТЭтапыДляОтбораСПредшественникамиВременная
		|
		|ОБЪЕДИНИТЬ
		|
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ВТНовыеПредшественники.Ссылка КАК Ссылка
		|ИЗ
		|	ВТНовыеПредшественники КАК ВТНовыеПредшественники
		|;
		|
		|УНИЧТОЖИТЬ ВТЭтапыДляОтбораСПредшественникамиВременная";
		//BSLLS:https:CreateQueryInCycle-off
		ЗапросПредшественников.Выполнить();
		//BSLLS:https:CreateQueryInCycle-on
	КонецЦикла;
	
	// === ДИАГНОСТИКА: Все этапы с предшественниками ===
	ЗапросДиагностики2 = Новый Запрос;
	ЗапросДиагностики2.МенеджерВременныхТаблиц = МенеджерВТ;
	ЗапросДиагностики2.Текст = "ВЫБРАТЬ Этапы.Ссылка.Номер КАК Номер ИЗ ВТЭтапыДляОтбораСПредшественниками КАК Этапы";
	РезДиаг2 = ЗапросДиагностики2.Выполнить().Выгрузить();
	СтрокаДиаг2 = "Шаг 2: Всего этапов (с предшественниками): " + РезДиаг2.Количество() + Символы.ПС;
	Для Каждого Стр Из РезДиаг2 Цикл
		СтрокаДиаг2 = СтрокаДиаг2 + "  - " + Стр.Номер + Символы.ПС;
	КонецЦикла;
	ЗаписьЖурналаРегистрации("ПотребностьДеталей.Диагностика", УровеньЖурналаРегистрации.Ошибка, , , СтрокаДиаг2);
	
	// Проверка: есть ли этап 108.4.1 в списке?
	ЗапросПроверки = Новый Запрос;
	ЗапросПроверки.МенеджерВременныхТаблиц = МенеджерВТ;
	ЗапросПроверки.Текст = 
	"ВЫБРАТЬ
	|	Обеспечение.Ссылка.Номер КАК НомерЭтапа,
	|	Обеспечение.Номенклатура.Наименование КАК Номенклатура,
	|	Обеспечение.ВариантОбеспечения КАК ВариантОбеспечения,
	|	Обеспечение.Отменено КАК Отменено,
	|	Обеспечение.Производится КАК Производится,
	|	Обеспечение.Номенклатура.ВидНоменклатуры КАК ВидНоменклатуры,
	|	Обеспечение.Номенклатура.ВидНоменклатуры В ИЕРАРХИИ(&ГруппаВидов) КАК ВходитВИерархию
	|ИЗ
	|	Документ.ЭтапПроизводства2_2.ОбеспечениеМатериаламиИРаботами КАК Обеспечение
	|ГДЕ
	|	Обеспечение.Ссылка В (ВЫБРАТЬ Э.Ссылка ИЗ ВТЭтапыДляОтбораСПредшественниками КАК Э)
	|	И Обеспечение.Номенклатура.Наименование ПОДОБНО ""%Сборка под покраску%""";
	ЗапросПроверки.УстановитьПараметр("ГруппаВидов", ГруппаВидовНоменклатурыДеталей);
	РезПроверки = ЗапросПроверки.Выполнить().Выгрузить();
	СтрокаДиаг3 = "Проверка 'Сборка под покраску': " + РезПроверки.Количество() + " записей" + Символы.ПС;
	Для Каждого СтрПров Из РезПроверки Цикл
		СтрокаДиаг3 = СтрокаДиаг3 + "  Этап: " + СтрПров.НомерЭтапа 
			+ " | ВариантОбесп: " + СтрПров.ВариантОбеспечения 
			+ " | Отменено: " + СтрПров.Отменено 
			+ " | Производится: " + СтрПров.Производится
			+ " | ВидНоменкл: " + СтрПров.ВидНоменклатуры
			+ " | ВходитВИерархию: " + СтрПров.ВходитВИерархию + Символы.ПС;
	КонецЦикла;
	ЗаписьЖурналаРегистрации("ПотребностьДеталей.Диагностика", УровеньЖурналаРегистрации.Ошибка, , , СтрокаДиаг3);
	// === КОНЕЦ ДИАГНОСТИКИ ===
	
	// ШАГ 4: Создание таблицы связей этапов с исходными этапами
	// Для каждого этапа (включая предшественников) определяем исходный этап, его изделие и вид номенклатуры
	// Это необходимо, чтобы для предшественников использовать изделие и вид номенклатуры исходного этапа, а не полуфабриката
	// Начинаем с исходных этапов - они сами себе исходные
	// ВАЖНО: Используем только ПЕРВОЕ выходное изделие (с минимальным НомерСтроки), чтобы избежать задвоения
	// при наличии нескольких выходных изделий у одного этапа
	ЗапросСвязей = Новый Запрос;
	ЗапросСвязей.МенеджерВременныхТаблиц = МенеджерВТ;
	ЗапросСвязей.Текст = 
	"ВЫБРАТЬ
	|	ВТЭтапыДляОтбора.Ссылка КАК Этап,
	|	ВТЭтапыДляОтбора.Ссылка КАК ИсходныйЭтап,
	|	ВЫРАЗИТЬ(ПервоеВыходноеИзделие.Номенклатура КАК Справочник.Номенклатура) КАК ИзделиеИсходногоЭтапа,
	|	СправочникНоменклатура.ВидНоменклатуры КАК ВидНоменклатурыИсходногоЭтапа
	|ПОМЕСТИТЬ ВТСвязиЭтапов
	|ИЗ
	|	ВТЭтапыДляОтбора КАК ВТЭтапыДляОтбора
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
	|			ВыходныеИзделия.Ссылка КАК Ссылка,
	|			МИНИМУМ(ВыходныеИзделия.НомерСтроки) КАК МинимальныйНомерСтроки
	|		ИЗ
	|			Документ.ЭтапПроизводства2_2.ВыходныеИзделия КАК ВыходныеИзделия
	|		ГДЕ
	|			ВыходныеИзделия.Ссылка В(ВЫБРАТЬ ВТЭтапыДляОтбора.Ссылка ИЗ ВТЭтапыДляОтбора КАК ВТЭтапыДляОтбора)
	|		СГРУППИРОВАТЬ ПО
	|			ВыходныеИзделия.Ссылка) КАК ПервыеСтрокиВыходныхИзделий
	|		ПО ВТЭтапыДляОтбора.Ссылка = ПервыеСтрокиВыходныхИзделий.Ссылка
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ЭтапПроизводства2_2.ВыходныеИзделия КАК ПервоеВыходноеИзделие
	|		ПО ПервоеВыходноеИзделие.Ссылка = ПервыеСтрокиВыходныхИзделий.Ссылка
	|			И ПервоеВыходноеИзделие.НомерСтроки = ПервыеСтрокиВыходныхИзделий.МинимальныйНомерСтроки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК СправочникНоменклатура
	|		ПО ВЫРАЗИТЬ(ПервоеВыходноеИзделие.Номенклатура КАК Справочник.Номенклатура) = СправочникНоменклатура.Ссылка
	|;";
	
	ЗапросСвязей.Выполнить();
	
	// Итеративно находим связи для предшественников
	// Предшественник связан с исходным этапом, если в его Последователи есть этап, который уже связан с исходным этапом
	ТаблицаВТСвязиЭтаповСоздана = Ложь;
	Пока Истина Цикл
		
		Если ТаблицаВТСвязиЭтаповСоздана Тогда
			//BSLLS:MissingCodeTryCatchEx-off
			Попытка
				ЗапросУничтожения = Новый Запрос;
				ЗапросУничтожения.МенеджерВременныхТаблиц = МенеджерВТ;
				ЗапросУничтожения.Текст = "УНИЧТОЖИТЬ ВТНовыеСвязиЭтапов";
				ЗапросУничтожения.Выполнить();
			Исключение
			КонецПопытки;
			//BSLLS:MissingCodeTryCatchEx-on
		КонецЕсли;
		
		ЗапросСвязей.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	Последователи.Ссылка КАК Этап,
		|	ВТСвязиЭтапов.ИсходныйЭтап КАК ИсходныйЭтап,
		|	ВТСвязиЭтапов.ИзделиеИсходногоЭтапа КАК ИзделиеИсходногоЭтапа,
		|	ВТСвязиЭтапов.ВидНоменклатурыИсходногоЭтапа КАК ВидНоменклатурыИсходногоЭтапа
		|ПОМЕСТИТЬ ВТНовыеСвязиЭтапов
		|ИЗ
		|	Документ.ЭтапПроизводства2_2.Последователи КАК Последователи
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТСвязиЭтапов КАК ВТСвязиЭтапов
		|		ПО Последователи.Этап = ВТСвязиЭтапов.Этап
		|ГДЕ
		|	Последователи.Ссылка НЕ В (ВЫБРАТЬ ВТСвязиЭтапов.Этап ИЗ ВТСвязиЭтапов КАК ВТСвязиЭтапов)
		|	И Последователи.Ссылка В (ВЫБРАТЬ ВТЭтапыДляОтбораСПредшественниками.Ссылка ИЗ ВТЭтапыДляОтбораСПредшественниками КАК ВТЭтапыДляОтбораСПредшественниками)
		|;
		|
		|ВЫБРАТЬ
		|	КОЛИЧЕСТВО(ВТНовыеСвязиЭтапов.Этап) КАК КоличествоНовыхСвязей
		|ИЗ
		|	ВТНовыеСвязиЭтапов КАК ВТНовыеСвязиЭтапов";
		
		РезультатСвязей = ЗапросСвязей.Выполнить();
		ТаблицаВТСвязиЭтаповСоздана = Истина;
		
		ВыборкаСвязей = РезультатСвязей.Выбрать();
		КоличествоНовыхСвязей = 0;
		Если ВыборкаСвязей.Следующий() Тогда
			КоличествоНовыхСвязей = ВыборкаСвязей.КоличествоНовыхСвязей;
		КонецЕсли;
		
		Если КоличествоНовыхСвязей = 0 Тогда
			Прервать;
		КонецЕсли;
		
		// Добавляем новые связи к существующим
		ЗапросСвязей.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ВТСвязиЭтапов.Этап КАК Этап,
		|	ВТСвязиЭтапов.ИсходныйЭтап КАК ИсходныйЭтап,
		|	ВТСвязиЭтапов.ИзделиеИсходногоЭтапа КАК ИзделиеИсходногоЭтапа,
		|	ВТСвязиЭтапов.ВидНоменклатурыИсходногоЭтапа КАК ВидНоменклатурыИсходногоЭтапа
		|ПОМЕСТИТЬ ВТСвязиЭтаповВременная
		|ИЗ
		|	ВТСвязиЭтапов КАК ВТСвязиЭтапов
		|;
		|
		|УНИЧТОЖИТЬ ВТСвязиЭтапов;
		|
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ВТСвязиЭтаповВременная.Этап КАК Этап,
		|	ВТСвязиЭтаповВременная.ИсходныйЭтап КАК ИсходныйЭтап,
		|	ВТСвязиЭтаповВременная.ИзделиеИсходногоЭтапа КАК ИзделиеИсходногоЭтапа,
		|	ВТСвязиЭтаповВременная.ВидНоменклатурыИсходногоЭтапа КАК ВидНоменклатурыИсходногоЭтапа
		|ПОМЕСТИТЬ ВТСвязиЭтапов
		|ИЗ
		|	ВТСвязиЭтаповВременная КАК ВТСвязиЭтаповВременная
		|
		|ОБЪЕДИНИТЬ
		|
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ВТНовыеСвязиЭтапов.Этап КАК Этап,
		|	ВТНовыеСвязиЭтапов.ИсходныйЭтап КАК ИсходныйЭтап,
		|	ВТНовыеСвязиЭтапов.ИзделиеИсходногоЭтапа КАК ИзделиеИсходногоЭтапа,
		|	ВТНовыеСвязиЭтапов.ВидНоменклатурыИсходногоЭтапа КАК ВидНоменклатурыИсходногоЭтапа
		|ИЗ
		|	ВТНовыеСвязиЭтапов КАК ВТНовыеСвязиЭтапов
		|;
		|
		|УНИЧТОЖИТЬ ВТСвязиЭтаповВременная";
		
		ЗапросСвязей.Выполнить();
		
	КонецЦикла;
	
	// ШАГ 5: Выполняем основной запрос, используя уже найденные этапы и связи
	// Основной запрос начинается с ШАГА 2, так как начальные этапы и их предшественники
	// уже найдены в предыдущих шагах и создали временные таблицы ВТЭтапыДляОтбора и ВТЭтапыДляОтбораСПредшественниками
	// Также создана таблица ВТСвязиЭтапов для определения исходного этапа и его изделия
	Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
	Результат = Запрос.Выполнить();
	
	ТаблицаРезультат = Результат.Выгрузить();
	
	// === ДИАГНОСТИКА: Найденные детали ===
	СтрокаДиаг4 = "Шаг 3: Найдено деталей в обеспечении: " + ТаблицаРезультат.Количество() + Символы.ПС;
	СчётчикДеталей = 0;
	Для Каждого СтрДеталь Из ТаблицаРезультат Цикл
		СчётчикДеталей = СчётчикДеталей + 1;
		Если СчётчикДеталей <= 20 Тогда // Показываем первые 20
			СтрокаДиаг4 = СтрокаДиаг4 + "  - " + СтрДеталь.Деталь + " | Кол: " + СтрДеталь.КоличествоУпаковокТребуется + Символы.ПС;
		КонецЕсли;
	КонецЦикла;
	Если СчётчикДеталей > 20 Тогда
		СтрокаДиаг4 = СтрокаДиаг4 + "  ... и ещё " + (СчётчикДеталей - 20) + " деталей" + Символы.ПС;
	КонецЕсли;
	СтрокаДиаг4 = СтрокаДиаг4 + "=== КОНЕЦ ДИАГНОСТИКИ ===";
	ЗаписьЖурналаРегистрации("ПотребностьДеталей.Диагностика", УровеньЖурналаРегистрации.Ошибка, , , СтрокаДиаг4);
	// === КОНЕЦ ДИАГНОСТИКИ ===
	
	// ШАГ 6: Добавление колонок для СКД
	// ВАЖНО: Колонки добавляются ВСЕГДА, даже если таблица пустая,
	// чтобы СКД могла корректно инициализироваться
	ТаблицаРезультат.Колонки.Добавить("Артикул");
	ТаблицаРезультат.Колонки.Добавить("ИПП");
	ТаблицаРезультат.Колонки.Добавить("РесурснаяСпецификация");
	ТаблицаРезультат.Колонки.Добавить("ОптимальнаяПартияВыпуска");
	ТаблицаРезультат.Колонки.Добавить("Группа");
	
	// ШАГ 7: Получение дополнительных данных (Артикул, ИПП, Спецификация, ОптимальнаяПартияВыпуска)
	// Эти данные нужны для всех случаев, не только при фильтрации по Цеху
	Если ТаблицаРезультат.Количество() > 0 Тогда
		
		// Получаем список уникальных номенклатур (деталей) из результата
		// ОПТИМИЗАЦИЯ: Используем Соответствие для уникальности вместо Массив.Найти()
		СоответствиеУникальныхНоменклатур = Новый Соответствие;
		Для Каждого СтрокаТаблицы Из ТаблицаРезультат Цикл
			СоответствиеУникальныхНоменклатур.Вставить(СтрокаТаблицы.Деталь, Истина);
		КонецЦикла;
		СписокНоменклатур = Новый Массив;
		Для Каждого КлючЗначение Из СоответствиеУникальныхНоменклатур Цикл
			СписокНоменклатур.Добавить(КлючЗначение.Ключ);
		КонецЦикла;
		
		// Получаем приоритетные спецификации для всех номенклатур на дату конца периода
		СоответствиеСпецификаций = Расш1_ОбщийМодуль1.ПриоритетныеСпецификацииДляСпискаНоменклатур(СписокНоменклатур, ДатаАктуальностиСпецификаций);
		
		// Для деталей уровня 1 группа заполняется наименованием самой детали
		СоответствиеНаименованийДеталей = Новый Соответствие;
		Если СписокНоменклатур.Количество() > 0 Тогда
			ЗапросНаименований = Новый Запрос;
			ЗапросНаименований.Текст = 
			"ВЫБРАТЬ
			|	Номенклатура.Ссылка КАК Номенклатура,
			|	Номенклатура.Наименование КАК Наименование
			|ИЗ
			|	Справочник.Номенклатура КАК Номенклатура
			|ГДЕ
			|	Номенклатура.Ссылка В(&СписокНоменклатур)";
			ЗапросНаименований.УстановитьПараметр("СписокНоменклатур", СписокНоменклатур);
			ВыборкаНаименований = ЗапросНаименований.Выполнить().Выбрать();
			Пока ВыборкаНаименований.Следующий() Цикл
				СоответствиеНаименованийДеталей.Вставить(ВыборкаНаименований.Номенклатура, ВыборкаНаименований.Наименование);
			КонецЦикла;
		КонецЕсли;
		
		Для Каждого СтрокаТаблицы Из ТаблицаРезультат Цикл
			НаименованиеДетали = СоответствиеНаименованийДеталей.Получить(СтрокаТаблицы.Деталь);
			Если НаименованиеДетали <> Неопределено Тогда
				СтрокаТаблицы.Группа = НаименованиеДетали;
			КонецЕсли;
		КонецЦикла;
		
		// РЕКУРСИВНЫЙ ПОИСК ВЛОЖЕННЫХ ДЕТАЛЕЙ
		// Защита от зацикливания: отслеживаем уже обработанные комбинации Деталь+Заказ
		// ВАЖНО: ключ включает ЗаказНаПроизводство, чтобы одна и та же деталь
		// рекурсивно раскрывалась для каждого заказа отдельно
		ОбработанныеНоменклатуры = Новый Соответствие;
		// Отдельное соответствие для сбора уникальных номенклатур (для запроса остатков)
		УникальныеНоменклатуры = Новый Соответствие;

		// ОПТИМИЗАЦИЯ: Индекс для быстрого поиска строк в ТаблицаРезультат по ключу "Деталь+Заказ+Изделие"
		// Вместо O(n) поиска в цикле используем O(1) доступ через Соответствие
		ИндексСтрокРезультата = Новый Соответствие;
		Для ИндексСтроки = 0 По ТаблицаРезультат.Количество() - 1 Цикл
			СтрокаТаблицы = ТаблицаРезультат[ИндексСтроки];
			КлючСтроки = Строка(СтрокаТаблицы.Деталь.УникальныйИдентификатор())
				+ "|" + Строка(СтрокаТаблицы.ЗаказНаПроизводство.УникальныйИдентификатор())
				+ "|" + Строка(СтрокаТаблицы.Изделие.УникальныйИдентификатор());
			ИндексСтрокРезультата.Вставить(КлючСтроки, ИндексСтроки);
			КлючОбработанной = Строка(СтрокаТаблицы.Деталь.УникальныйИдентификатор())
				+ "|" + Строка(СтрокаТаблицы.ЗаказНаПроизводство.УникальныйИдентификатор());
			ОбработанныеНоменклатуры.Вставить(КлючОбработанной, Истина);
			УникальныеНоменклатуры.Вставить(СтрокаТаблицы.Деталь, Истина);
		КонецЦикла;
		
		// Таблица для текущего уровня деталей (начинаем с уровня 1)
		// Примечание: СкладЦех и Подразделение не используются в финальном выводе,
		// поэтому для вложенных деталей передаем пустые значения
		ТаблицаТекущегоУровня = Новый ТаблицаЗначений;
		ТаблицаТекущегоУровня.Колонки.Добавить("Деталь", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		ТаблицаТекущегоУровня.Колонки.Добавить("КоличествоУпаковокТребуется", Новый ОписаниеТипов("Число"));
		ТаблицаТекущегоУровня.Колонки.Добавить("ЗаказНаПроизводство", Новый ОписаниеТипов("ДокументСсылка.ЗаказНаПроизводство2_2"));
		ТаблицаТекущегоУровня.Колонки.Добавить("Изделие", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		ТаблицаТекущегоУровня.Колонки.Добавить("ВидНоменклатурыИзделия", Новый ОписаниеТипов("СправочникСсылка.ВидыНоменклатуры"));
		ТаблицаТекущегоУровня.Колонки.Добавить("Группа", Новый ОписаниеТипов("Строка"));
		
		// Копируем детали уровня 1 в таблицу текущего уровня
		Для Каждого СтрокаТаблицы Из ТаблицаРезультат Цикл
			НоваяСтрока = ТаблицаТекущегоУровня.Добавить();
			НоваяСтрока.Деталь = СтрокаТаблицы.Деталь;
			НоваяСтрока.КоличествоУпаковокТребуется = СтрокаТаблицы.КоличествоУпаковокТребуется;
			НоваяСтрока.ЗаказНаПроизводство = СтрокаТаблицы.ЗаказНаПроизводство;
			НоваяСтрока.Изделие = СтрокаТаблицы.Изделие;
			НоваяСтрока.ВидНоменклатурыИзделия = СтрокаТаблицы.ВидНоменклатурыИзделия;
			НоваяСтрока.Группа = СтрокаТаблицы.Группа;
		КонецЦикла;
		
		// Цикл рекурсивного поиска
		Пока ТаблицаТекущегоУровня.Количество() > 0 Цикл
			
			// Получаем вложенные детали из спецификаций текущего уровня
			ТаблицаВложенныхДеталей = ПолучитьВложенныеДеталиИзСпецификаций(ТаблицаТекущегоУровня, СоответствиеСпецификаций, ДатаАктуальностиСпецификаций, ГруппаВидовНоменклатурыДеталей);
			
			// Фильтруем уже обработанные номенклатуры (защита от зацикливания)
			ТаблицаНовыхДеталей = Новый ТаблицаЗначений;
			ТаблицаНовыхДеталей.Колонки.Добавить("Деталь", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
			ТаблицаНовыхДеталей.Колонки.Добавить("КоличествоУпаковокТребуется", Новый ОписаниеТипов("Число"));
			ТаблицаНовыхДеталей.Колонки.Добавить("ЗаказНаПроизводство", Новый ОписаниеТипов("ДокументСсылка.ЗаказНаПроизводство2_2"));
			ТаблицаНовыхДеталей.Колонки.Добавить("Изделие", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
			ТаблицаНовыхДеталей.Колонки.Добавить("ВидНоменклатурыИзделия", Новый ОписаниеТипов("СправочникСсылка.ВидыНоменклатуры"));
			ТаблицаНовыхДеталей.Колонки.Добавить("Группа", Новый ОписаниеТипов("Строка"));
			
			// ОПТИМИЗАЦИЯ: Соответствие для уникальных номенклатур вместо Массив.Найти()
			СоответствиеНовыхНоменклатур = Новый Соответствие;
			
			Для Каждого СтрокаВложенной Из ТаблицаВложенныхДеталей Цикл
				
				// Формируем ключ для быстрого поиска
				КлючВложенной = Строка(СтрокаВложенной.Деталь.УникальныйИдентификатор()) 
					+ "|" + Строка(СтрокаВложенной.ЗаказНаПроизводство.УникальныйИдентификатор())
					+ "|" + Строка(СтрокаВложенной.Изделие.УникальныйИдентификатор());
				
				// Проверяем, есть ли уже такая строка в результате (O(1) вместо O(n))
				ИндексСуществующей = ИндексСтрокРезультата.Получить(КлючВложенной);
				
				Если ИндексСуществующей <> Неопределено Тогда
					// Строка уже существует - суммируем количество
					СтрокаРезультата = ТаблицаРезультат[ИндексСуществующей];
					СтрокаРезультата.КоличествоУпаковокТребуется = СтрокаРезультата.КоличествоУпаковокТребуется + СтрокаВложенной.КоличествоУпаковокТребуется;
					// Пересчитываем дефицит
					СтрокаРезультата.КоличествоУпаковокДефицит = СтрокаРезультата.КоличествоУпаковокТребуется 
						- СтрокаРезультата.КоличествоУпаковокВНаличииДК 
						- СтрокаРезультата.КоличествоУпаковокВНаличииЦех;
				Иначе
					// Новая деталь - добавляем в результат
					НоваяСтрокаРезультата = ТаблицаРезультат.Добавить();
					НоваяСтрокаРезультата.Деталь = СтрокаВложенной.Деталь;
					НоваяСтрокаРезультата.КоличествоУпаковокТребуется = СтрокаВложенной.КоличествоУпаковокТребуется;
					НоваяСтрокаРезультата.ЗаказНаПроизводство = СтрокаВложенной.ЗаказНаПроизводство;
					НоваяСтрокаРезультата.Изделие = СтрокаВложенной.Изделие;
					НоваяСтрокаРезультата.ВидНоменклатурыИзделия = СтрокаВложенной.ВидНоменклатурыИзделия;
					НоваяСтрокаРезультата.Группа = СтрокаВложенной.Группа;
					// Для вложенных деталей остатки и ожидаемые не рассчитываются - устанавливаем в 0
					НоваяСтрокаРезультата.КоличествоУпаковокВНаличииДК = 0;
					НоваяСтрокаРезультата.КоличествоУпаковокВНаличииЦех = 0;
					НоваяСтрокаРезультата.КоличествоУпаковокОжидается = 0;
					НоваяСтрокаРезультата.КоличествоУпаковокДефицит = СтрокаВложенной.КоличествоУпаковокТребуется;
					
					// Добавляем в индекс
					ИндексСтрокРезультата.Вставить(КлючВложенной, ТаблицаРезультат.Количество() - 1);
					
					// Если комбинация Деталь+Заказ ещё не обработана - добавляем для следующей итерации
					// ИСПРАВЛЕНИЕ: ключ включает ЗаказНаПроизводство, чтобы одна и та же деталь
					// раскрывалась рекурсивно для каждого заказа отдельно
					КлючОбработанной = Строка(СтрокаВложенной.Деталь.УникальныйИдентификатор())
						+ "|" + Строка(СтрокаВложенной.ЗаказНаПроизводство.УникальныйИдентификатор());
					Если ОбработанныеНоменклатуры.Получить(КлючОбработанной) = Неопределено Тогда
						НоваяСтрокаНовых = ТаблицаНовыхДеталей.Добавить();
						НоваяСтрокаНовых.Деталь = СтрокаВложенной.Деталь;
						НоваяСтрокаНовых.КоличествоУпаковокТребуется = СтрокаВложенной.КоличествоУпаковокТребуется;
						НоваяСтрокаНовых.ЗаказНаПроизводство = СтрокаВложенной.ЗаказНаПроизводство;
						НоваяСтрокаНовых.Изделие = СтрокаВложенной.Изделие;
						НоваяСтрокаНовых.ВидНоменклатурыИзделия = СтрокаВложенной.ВидНоменклатурыИзделия;
						НоваяСтрокаНовых.Группа = СтрокаВложенной.Группа;

						ОбработанныеНоменклатуры.Вставить(КлючОбработанной, Истина);
						УникальныеНоменклатуры.Вставить(СтрокаВложенной.Деталь, Истина);
						СоответствиеНовыхНоменклатур.Вставить(СтрокаВложенной.Деталь, Истина);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			// Получаем спецификации для новых деталей
			Если СоответствиеНовыхНоменклатур.Количество() > 0 Тогда
				СписокНовыхНоменклатур = Новый Массив;
				Для Каждого КлючЗначение Из СоответствиеНовыхНоменклатур Цикл
					СписокНовыхНоменклатур.Добавить(КлючЗначение.Ключ);
				КонецЦикла;
				
				СоответствиеНовыхСпецификаций = Расш1_ОбщийМодуль1.ПриоритетныеСпецификацииДляСпискаНоменклатур(СписокНовыхНоменклатур, ДатаАктуальностиСпецификаций);
				// Объединяем с существующим соответствием
				Для Каждого КлючЗначение Из СоответствиеНовыхСпецификаций Цикл
					СоответствиеСпецификаций.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
				КонецЦикла;
			КонецЕсли;
			
			// Переходим к следующему уровню
			ТаблицаТекущегоУровня = ТаблицаНовыхДеталей;
			
		КонецЦикла;
		
		// Список уникальных номенклатур собран в УникальныеНоменклатуры - используем его
		СписокНоменклатур = Новый Массив;
		Для Каждого КлючЗначение Из УникальныеНоменклатуры Цикл
			СписокНоменклатур.Добавить(КлючЗначение.Ключ);
		КонецЦикла;
		
		// РАСЧЁТ ОСТАТКОВ ДЛЯ ВСЕХ ДЕТАЛЕЙ (включая вложенные)
		// Получаем остатки на складе ДК для всех номенклатур
		Если СписокНоменклатур.Количество() > 0 Тогда
			ЗапросОстатковДК = Новый Запрос;
			ЗапросОстатковДК.Текст = 
			"ВЫБРАТЬ
			|	ТоварыНаСкладахОстатки.Номенклатура КАК Номенклатура,
			|	СУММА(ВЫБОР
			|		КОГДА ТоварыНаСкладахОстатки.ВНаличииОстаток < 0
			|			ТОГДА 0
			|		ИНАЧЕ ТоварыНаСкладахОстатки.ВНаличииОстаток
			|	КОНЕЦ) КАК КоличествоУпаковокВНаличииДК
			|ИЗ
			|	РегистрНакопления.ТоварыНаСкладах.Остатки(
			|			&ДатаКон,
			|			Склад.Наименование = ""Детальная кладовая""
			|				И Номенклатура В (&СписокНоменклатур)
			|				И Назначение = ЗНАЧЕНИЕ(Справочник.Назначения.ПустаяСсылка)) КАК ТоварыНаСкладахОстатки
			|СГРУППИРОВАТЬ ПО
			|	ТоварыНаСкладахОстатки.Номенклатура";
			ЗапросОстатковДК.УстановитьПараметр("ДатаКон", КонецДня(ДатаОкончанияПериода));
			ЗапросОстатковДК.УстановитьПараметр("СписокНоменклатур", СписокНоменклатур);
			
			СоответствиеОстатковДК = Новый Соответствие;
			ВыборкаОстатковДК = ЗапросОстатковДК.Выполнить().Выбрать();
			Пока ВыборкаОстатковДК.Следующий() Цикл
				СоответствиеОстатковДК.Вставить(ВыборкаОстатковДК.Номенклатура, ВыборкаОстатковДК.КоличествоУпаковокВНаличииДК);
			КонецЦикла;
			
			// Получаем остатки в цеховых кладовых для всех номенклатур
			ЗапросОстатковЦех = Новый Запрос;
			ЗапросОстатковЦех.Текст = 
			"ВЫБРАТЬ
			|	ТоварыНаСкладахОстатки.Номенклатура КАК Номенклатура,
			|	СУММА(ВЫБОР
			|		КОГДА ТоварыНаСкладахОстатки.ВНаличииОстаток < 0
			|			ТОГДА 0
			|		ИНАЧЕ ТоварыНаСкладахОстатки.ВНаличииОстаток
			|	КОНЕЦ) КАК КоличествоУпаковокВНаличииЦех
			|ИЗ
			|	РегистрНакопления.ТоварыНаСкладах.Остатки(
			|			&ДатаКон,
			|			Склад.ЦеховаяКладовая = ИСТИНА
			|				И Номенклатура В (&СписокНоменклатур)
			|				И Назначение = ЗНАЧЕНИЕ(Справочник.Назначения.ПустаяСсылка)) КАК ТоварыНаСкладахОстатки
			|СГРУППИРОВАТЬ ПО
			|	ТоварыНаСкладахОстатки.Номенклатура";
			ЗапросОстатковЦех.УстановитьПараметр("ДатаКон", КонецДня(ДатаОкончанияПериода));
			ЗапросОстатковЦех.УстановитьПараметр("СписокНоменклатур", СписокНоменклатур);
			
			СоответствиеОстатковЦех = Новый Соответствие;
			ВыборкаОстатковЦех = ЗапросОстатковЦех.Выполнить().Выбрать();
			Пока ВыборкаОстатковЦех.Следующий() Цикл
				СоответствиеОстатковЦех.Вставить(ВыборкаОстатковЦех.Номенклатура, ВыборкаОстатковЦех.КоличествоУпаковокВНаличииЦех);
			КонецЦикла;
			
			// Получаем ожидаемое количество из заказов на производство деталей
			ЗапросОжидаемого = Новый Запрос;
			ЗапросОжидаемого.Текст = 
			"ВЫБРАТЬ
			|	ЭтапыСНоменклатурой.Номенклатура КАК Номенклатура,
			|	СУММА(ЭтапыСНоменклатурой.ОстатокКВыпуску) КАК КоличествоУпаковокОжидается
			|ИЗ
			|	(ВЫБРАТЬ
			|		ВыходныеИзделияЭтапа.Номенклатура КАК Номенклатура,
			|		Этапы.Ссылка КАК ЭтапПроизводства,
			|		МАКСИМУМ(Этапы.КоличествоУпаковокПлан - Этапы.КоличествоУпаковокФакт - Этапы.КоличествоУпаковокОтменено) КАК ОстатокКВыпуску
			|	ИЗ
			|		Документ.ЭтапПроизводства2_2.ВыходныеИзделия КАК ВыходныеИзделияЭтапа
			|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ЭтапПроизводства2_2 КАК Этапы
			|			ПО ВыходныеИзделияЭтапа.Ссылка = Этапы.Ссылка
			|	ГДЕ
			|		Этапы.Статус В (&Статусы)
			|		И Этапы.Проведен
			|		И Этапы.КоличествоУпаковокПлан - Этапы.КоличествоУпаковокФакт - Этапы.КоличествоУпаковокОтменено > 0
			|		И НЕ ВыходныеИзделияЭтапа.Отменено
			|		И ВыходныеИзделияЭтапа.Номенклатура В (&СписокНоменклатур)
			|	СГРУППИРОВАТЬ ПО
			|		ВыходныеИзделияЭтапа.Номенклатура,
			|		Этапы.Ссылка) КАК ЭтапыСНоменклатурой
			|СГРУППИРОВАТЬ ПО
			|	ЭтапыСНоменклатурой.Номенклатура";
			
			МассивСтатусовДляОжидаемого = Новый Массив;
			МассивСтатусовДляОжидаемого.Добавить(Перечисления.СтатусыЭтаповПроизводства2_2.Сформирован);
			МассивСтатусовДляОжидаемого.Добавить(Перечисления.СтатусыЭтаповПроизводства2_2.КВыполнению);
			МассивСтатусовДляОжидаемого.Добавить(Перечисления.СтатусыЭтаповПроизводства2_2.Начат);
			ЗапросОжидаемого.УстановитьПараметр("Статусы", МассивСтатусовДляОжидаемого);
			ЗапросОжидаемого.УстановитьПараметр("СписокНоменклатур", СписокНоменклатур);
			
			СоответствиеОжидаемого = Новый Соответствие;
			ВыборкаОжидаемого = ЗапросОжидаемого.Выполнить().Выбрать();
			Пока ВыборкаОжидаемого.Следующий() Цикл
				СоответствиеОжидаемого.Вставить(ВыборкаОжидаемого.Номенклатура, ВыборкаОжидаемого.КоличествоУпаковокОжидается);
			КонецЦикла;
			
			// Обновляем остатки в таблице результата
			// Для каждой уникальной детали остатки показываются только один раз (в первой строке)
			ОбработанныеДеталиДляОстатков = Новый Соответствие;
			Для Каждого СтрокаТаблицы Из ТаблицаРезультат Цикл
				Деталь = СтрокаТаблицы.Деталь;
				
				// Остатки показываем только для первой строки каждой детали
				Если ОбработанныеДеталиДляОстатков.Получить(Деталь) = Неопределено Тогда
					ОстатокДК = СоответствиеОстатковДК.Получить(Деталь);
					ОстатокЦех = СоответствиеОстатковЦех.Получить(Деталь);
					Ожидается = СоответствиеОжидаемого.Получить(Деталь);
					
					СтрокаТаблицы.КоличествоУпаковокВНаличииДК = ?(ОстатокДК <> Неопределено, ОстатокДК, 0);
					СтрокаТаблицы.КоличествоУпаковокВНаличииЦех = ?(ОстатокЦех <> Неопределено, ОстатокЦех, 0);
					СтрокаТаблицы.КоличествоУпаковокОжидается = ?(Ожидается <> Неопределено, Ожидается, 0);
					
					ОбработанныеДеталиДляОстатков.Вставить(Деталь, Истина);
				Иначе
					// Для повторных строк той же детали - обнуляем остатки
					СтрокаТаблицы.КоличествоУпаковокВНаличииДК = 0;
					СтрокаТаблицы.КоличествоУпаковокВНаличииЦех = 0;
					СтрокаТаблицы.КоличествоУпаковокОжидается = 0;
				КонецЕсли;
				
				// Пересчитываем дефицит
				СтрокаТаблицы.КоличествоУпаковокДефицит = СтрокаТаблицы.КоличествоУпаковокТребуется 
					- СтрокаТаблицы.КоличествоУпаковокВНаличииДК 
					- СтрокаТаблицы.КоличествоУпаковокВНаличииЦех;
			КонецЦикла;
		КонецЕсли;
		
		// Получаем Артикул и ИПП для всех номенклатур одним запросом
		ЗапросДопДанных = Новый Запрос;
		ЗапросДопДанных.Текст = 
		"ВЫБРАТЬ
		|	ВыбраннаяНоменклатура.Ссылка КАК Номенклатура,
		|	ВыбраннаяНоменклатура.Артикул КАК Артикул,
		|	ЕСТЬNULL(ДополнительныеСведенияИПП.Значение, """") КАК ИПП
		|ИЗ
		|	Справочник.Номенклатура КАК ВыбраннаяНоменклатура
		|		ЛЕВОЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
		|			ВЫРАЗИТЬ(ДополнительныеСведения.Объект КАК Справочник.Номенклатура) КАК НоменклатураИПП,
		|			ВЫРАЗИТЬ(ДополнительныеСведения.Значение КАК СТРОКА(250)) КАК Значение
		|		ИЗ
		|			РегистрСведений.ДополнительныеСведения КАК ДополнительныеСведения
		|				ВНУТРЕННЕЕ СОЕДИНЕНИЕ ПланВидовХарактеристик.ДополнительныеРеквизитыИСведения КАК СвойствоИПП
		|				ПО ДополнительныеСведения.Свойство = СвойствоИПП.Ссылка
		|		ГДЕ
		|			СвойствоИПП.Наименование = ""ИПП""
		|			И ТИПЗНАЧЕНИЯ(ДополнительныеСведения.Объект) = ТИП(Справочник.Номенклатура)) КАК ДополнительныеСведенияИПП
		|		ПО ВыбраннаяНоменклатура.Ссылка = ДополнительныеСведенияИПП.НоменклатураИПП
		|ГДЕ
		|	ВыбраннаяНоменклатура.Ссылка В(&СписокНоменклатур)";
		ЗапросДопДанных.УстановитьПараметр("СписокНоменклатур", СписокНоменклатур);
		РезультатДопДанных = ЗапросДопДанных.Выполнить();
		
		// Формируем соответствия для быстрого доступа
		СоответствиеАртикулов = Новый Соответствие;
		СоответствиеИПП = Новый Соответствие;
		ВыборкаДопДанных = РезультатДопДанных.Выбрать();
		Пока ВыборкаДопДанных.Следующий() Цикл
			СоответствиеАртикулов.Вставить(ВыборкаДопДанных.Номенклатура, ВыборкаДопДанных.Артикул);
			СоответствиеИПП.Вставить(ВыборкаДопДанных.Номенклатура, ВыборкаДопДанных.ИПП);
		КонецЦикла;
		
		// Получаем список уникальных спецификаций для запроса ОптимальнойПартииВыпуска и подразделений
		// ОПТИМИЗАЦИЯ: Соответствие для уникальности вместо Массив.Найти()
		СоответствиеУникальныхСпецификаций = Новый Соответствие;
		Для Каждого КлючЗначение Из СоответствиеСпецификаций Цикл
			Если КлючЗначение.Значение <> Неопределено Тогда
				СоответствиеУникальныхСпецификаций.Вставить(КлючЗначение.Значение, Истина);
			КонецЕсли;
		КонецЦикла;
		СписокСпецификаций = Новый Массив;
		Для Каждого КлючЗначение Из СоответствиеУникальныхСпецификаций Цикл
			СписокСпецификаций.Добавить(КлючЗначение.Ключ);
		КонецЦикла;
		
		// Получаем ОптимальнаяПартияВыпуска для всех спецификаций
		СоответствиеОптимальныхПартий = Новый Соответствие;
		Если СписокСпецификаций.Количество() > 0 Тогда
			ЗапросСпецификаций = Новый Запрос;
			ЗапросСпецификаций.Текст = 
			"ВЫБРАТЬ
			|	РесурсныеСпецификации.Ссылка КАК Спецификация,
			|	РесурсныеСпецификации.ОптимальнаяПартияВыпуска КАК ОптимальнаяПартияВыпуска
			|ИЗ
			|	Справочник.РесурсныеСпецификации КАК РесурсныеСпецификации
			|ГДЕ
			|	РесурсныеСпецификации.Ссылка В(&СписокСпецификаций)";
			ЗапросСпецификаций.УстановитьПараметр("СписокСпецификаций", СписокСпецификаций);
			РезультатСпецификаций = ЗапросСпецификаций.Выполнить();
			ВыборкаСпецификаций = РезультатСпецификаций.Выбрать();
			Пока ВыборкаСпецификаций.Следующий() Цикл
				СоответствиеОптимальныхПартий.Вставить(ВыборкаСпецификаций.Спецификация, ВыборкаСпецификаций.ОптимальнаяПартияВыпуска);
			КонецЦикла;
		КонецЕсли;
		
		// Заполняем новые колонки в таблице результата
		Для Каждого СтрокаТаблицы Из ТаблицаРезультат Цикл
			Деталь = СтрокаТаблицы.Деталь;
			
			// Артикул - проверяем на Неопределено, т.к. нельзя присвоить Неопределено в строковую колонку
			АртикулЗначение = СоответствиеАртикулов.Получить(Деталь);
			Если АртикулЗначение <> Неопределено Тогда
				СтрокаТаблицы.Артикул = АртикулЗначение;
			КонецЕсли;
			
			// ИПП - аналогично
			ИППЗначение = СоответствиеИПП.Получить(Деталь);
			Если ИППЗначение <> Неопределено Тогда
				СтрокаТаблицы.ИПП = ИППЗначение;
			КонецЕсли;
			
			// Спецификация и ОптимальнаяПартияВыпуска
			Спецификация = СоответствиеСпецификаций.Получить(Деталь);
			Если Спецификация <> Неопределено Тогда
				СтрокаТаблицы.РесурснаяСпецификация = Спецификация;
				ОптимальнаяПартия = СоответствиеОптимальныхПартий.Получить(Спецификация);
				Если ОптимальнаяПартия <> Неопределено Тогда
					СтрокаТаблицы.ОптимальнаяПартияВыпуска = ОптимальнаяПартия;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		// ШАГ 7: Фильтрация по Цеху (если указан)
		// Для каждой детали получаем подразделение-исполнитель первого этапа спецификации
		// и сравниваем с указанным Цехом. Если не совпадает - не включаем в результат.
		Если ЗначениеЗаполнено(Цех) Тогда
			
			// Получаем подразделения первого этапа для всех спецификаций
			СоответствиеПодразделений = Расш1_ОбщийМодуль1.ПодразделенияПервогоЭтапаДляСпискаСпецификаций(СписокСпецификаций);
			
			// Формируем соответствие Номенклатура -> Подразделение первого этапа
			СоответствиеНоменклатураПодразделение = Новый Соответствие;
			Для Каждого КлючЗначение Из СоответствиеСпецификаций Цикл
				Номенклатура = КлючЗначение.Ключ;
				Спецификация = КлючЗначение.Значение;
				Если Спецификация <> Неопределено Тогда
					Подразделение = СоответствиеПодразделений.Получить(Спецификация);
					СоответствиеНоменклатураПодразделение.Вставить(Номенклатура, Подразделение);
				КонецЕсли;
			КонецЦикла;
			
			// ОПТИМИЗАЦИЯ: Вместо удаления строк (O(n²)) копируем нужные в новую таблицу (O(n))
			ТаблицаОтфильтрованная = ТаблицаРезультат.СкопироватьКолонки();
			Для Каждого СтрокаТаблицы Из ТаблицаРезультат Цикл
				ПодразделениеДетали = СоответствиеНоменклатураПодразделение.Получить(СтрокаТаблицы.Деталь);
				// Оставляем только строки с совпадающим Цехом
				Если ПодразделениеДетали <> Неопределено И ПодразделениеДетали = Цех Тогда
					ЗаполнитьЗначенияСвойств(ТаблицаОтфильтрованная.Добавить(), СтрокаТаблицы);
				КонецЕсли;
			КонецЦикла;
			ТаблицаРезультат = ТаблицаОтфильтрованная;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ТаблицаРезультат;
	
КонецФункции 

