#Область ПрограммныйИнтерфейс

// Отправляет запрос к модели в LM Studio / AI Gateway
//
// Параметры:
//  Сообщения - Массив - массив сообщений в формате OpenAI API
//  Параметры - Структура - дополнительные параметры запроса:
//   * Модель - Строка - имя модели (необязательно, берется из константы)
//   * Температура - Число - температура генерации (по умолчанию 0.7)
//   * МаксТокенов - Число - максимальное количество токенов (по умолчанию 2000)
//   * ИмяПользователя - Строка - имя текущего пользователя (для персонализации)
//
// Возвращаемое значение:
//  Структура - ответ модели:
//   * Успешно - Булево
//   * ТекстОтвета - Строка - текст ответа модели
//   * Ошибка - Строка - текст ошибки (если Успешно = Ложь)
//
Функция ОтправитьЗапросКМодели(Сообщения, Параметры = Неопределено) Экспорт
	
	Если Параметры = Неопределено Тогда
		Параметры = Новый Структура;
	КонецЕсли;
	
	// Получаем настройки из констант
	АдресLMStudio = Константы.mcp_АдресLMStudio.Получить();
	Если НЕ ЗначениеЗаполнено(АдресLMStudio) Тогда
		АдресLMStudio = "http://localhost:1234";
	КонецЕсли;
	
	Модель = "";
	Если Параметры.Свойство("Модель") И ЗначениеЗаполнено(Параметры.Модель) Тогда
		Модель = Параметры.Модель;
	Иначе
		Модель = Константы.mcp_МодельLMStudio.Получить();
		Если НЕ ЗначениеЗаполнено(Модель) Тогда
			Модель = "local-model";
		КонецЕсли;
	КонецЕсли;
	
	Температура = 0.7;
	Если Параметры.Свойство("Температура") Тогда
		Температура = Параметры.Температура;
	КонецЕсли;
	
	МаксТокенов = 2000;
	Если Параметры.Свойство("МаксТокенов") Тогда
		МаксТокенов = Параметры.МаксТокенов;
	КонецЕсли;
	
	// Информация о пользователе для персонализации
	ИнформацияПользователя = ПолучитьИнформациюОПользователе();
	
	// Логируем данные пользователя для отладки
	ЗаписьЖурналаРегистрации("MCP.Агент.Debug", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("Данные пользователя: Имя=%1, ПолноеНаименование=%2, Ссылка=%3",
			ИнформацияПользователя.Имя,
			ИнформацияПользователя.ПолноеНаименование,
			ИнформацияПользователя.Ссылка));
	
	// Формируем тело запроса
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("model", Модель);
	ТелоЗапроса.Вставить("messages", Сообщения);
	ТелоЗапроса.Вставить("temperature", Температура);
	ТелоЗапроса.Вставить("max_tokens", МаксТокенов);
	ТелоЗапроса.Вставить("stream", Ложь);
	ТелоЗапроса.Вставить("user", ИнформацияПользователя);
	
	JSONСтрока = mcp_ОбщегоНазначения.СтруктураВJSON(ТелоЗапроса);
	
	// Логируем JSON для проверки сериализации
	ЗаписьЖурналаРегистрации("MCP.Агент.Debug", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("JSON запроса (первые 500 символов): %1", Лев(JSONСтрока, 500)));
	
	// Разбираем адрес
	РазборURL = mcp_ОбщегоНазначения.РазобратьURL(АдресLMStudio);
	
	// Создаем HTTP запрос с заголовками
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	
	// Получаем Bearer токен для авторизации (если настроена OAuth2 авторизация)
	BearerТокен = ПолучитьBearerТокен(АдресLMStudio);
	Если ЗначениеЗаполнено(BearerТокен) Тогда
		Заголовки.Вставить("Authorization", "Bearer " + BearerТокен);
		ЗаписьЖурналаРегистрации("MCP.Агент.Debug", УровеньЖурналаРегистрации.Информация, , , 
			"Bearer токен добавлен в запрос");
	КонецЕсли;
	
	HTTPЗапрос = Новый HTTPЗапрос("/v1/chat/completions", Заголовки);
	HTTPЗапрос.УстановитьТелоИзСтроки(JSONСтрока, КодировкаТекста.UTF8);
	
	// Создаем соединение
	Порт = ?(РазборURL.Порт = 0, ?(РазборURL.Схема = "https", 443, 80), РазборURL.Порт);
	ИспользоватьSSL = (РазборURL.Схема = "https");
	
	Таймаут = Константы.mcp_ТаймаутЗапроса.Получить();
	Если НЕ ЗначениеЗаполнено(Таймаут) Или Таймаут <= 0 Тогда
		Таймаут = 60;
	КонецЕсли;
	
	Если ИспользоватьSSL Тогда
		HTTPСоединение = Новый HTTPСоединение(
			РазборURL.Хост,
			Порт,
			, , ,
			Таймаут,
			Новый ЗащищенноеСоединениеOpenSSL()
		);
	Иначе
		HTTPСоединение = Новый HTTPСоединение(
			РазборURL.Хост,
			Порт,
			, , ,
			Таймаут
		);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Успешно", Ложь);
	Результат.Вставить("ТекстОтвета", "");
	Результат.Вставить("Ошибка", "");
	
	Попытка
		HTTPОтвет = HTTPСоединение.ВызватьHTTPМетод("POST", HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния = 200 Тогда
			ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
			ОтветДанные = mcp_ОбщегоНазначения.JSONВСтруктуру(ТелоОтвета);
			
			Если ОтветДанные.Свойство("choices") И ТипЗнч(ОтветДанные.choices) = Тип("Массив") 
				И ОтветДанные.choices.Количество() > 0 Тогда
				
				Выбор = ОтветДанные.choices[0];
				Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
					Результат.Успешно = Истина;
					Результат.ТекстОтвета = Выбор.message.content;
				Иначе
					Результат.Ошибка = "Неверный формат ответа от модели";
				КонецЕсли;
			Иначе
				Результат.Ошибка = "Модель не вернула ответ";
			КонецЕсли;
		Иначе
			ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
			Результат.Ошибка = СтрШаблон("HTTP ошибка %1: %2", HTTPОтвет.КодСостояния, ТелоОтвета);
		КонецЕсли;
		
	Исключение
		ПолнаяОшибка = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		// Логируем полную ошибку для разработчика
		ЗаписьЖурналаРегистрации("MCP.Агент", УровеньЖурналаРегистрации.Ошибка, , , 
			СтрШаблон("Ошибка запроса к LM Studio: %1", ПолнаяОшибка));
		
		// Для пользователя показываем понятное сообщение
		Если СтрНайти(ВРег(ПолнаяОшибка), "ТАЙМАУТ") > 0 
			Или СтрНайти(ВРег(ПолнаяОшибка), "TIMEOUT") > 0 Тогда
			Результат.Ошибка = "Сервер не ответил вовремя. Попробуйте повторить запрос позже.";
		ИначеЕсли СтрНайти(ВРег(ПолнаяОшибка), "НЕ МОГУ УСТАНОВИТЬ СОЕДИНЕНИЕ") > 0 
			Или СтрНайти(ВРег(ПолнаяОшибка), "CONNECTION") > 0 Тогда
			Результат.Ошибка = "Не удалось подключиться к серверу. Проверьте соединение.";
		Иначе
			Результат.Ошибка = "Ошибка связи с сервером. Попробуйте позже.";
		КонецЕсли;
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Формирует массив сообщений для модели из истории диалога
//
// Параметры:
//  ИсторияДиалога - ТаблицаЗначений - история диалога с колонками:
//   * Роль - Строка
//   * ТекстСообщения - Строка
//   * ВремяСообщения - Дата
//
// Возвращаемое значение:
//  Массив - массив сообщений в формате OpenAI API
//
Функция СформироватьСообщенияДляМодели(ИсторияДиалога) Экспорт
	
	Сообщения = Новый Массив;
	
	// Системный промпт формируется в bot.py, здесь добавляем только историю диалога
	
	// Добавляем историю диалога (только user и assistant, без системных)
	Для Каждого СтрокаИстории Из ИсторияДиалога Цикл
		// Пропускаем системные сообщения - они формируются в bot.py
		Если НРег(СтрокаИстории.Роль) = "system" Тогда
			Продолжить;
		КонецЕсли;
		
		Сообщение = Новый Структура;
		Сообщение.Вставить("role", СтрокаИстории.Роль);
		Сообщение.Вставить("content", СтрокаИстории.ТекстСообщения);
		Сообщения.Добавить(Сообщение);
	КонецЦикла;
	
	Возврат Сообщения;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Получает информацию о текущем пользователе для передачи в бота
//
// Возвращаемое значение:
//  Структура - информация о пользователе:
//   * Имя - Строка - имя для обращения (второе слово из наименования)
//   * ПолноеНаименование - Строка - полное наименование пользователя
//   * Ссылка - Строка - UUID ссылки на элемент справочника Пользователи
//
Функция ПолучитьИнформациюОПользователе() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Имя", "Пользователь");
	Результат.Вставить("ПолноеНаименование", "");
	Результат.Вставить("Ссылка", "");
	
	// Получаем логин текущего пользователя
	ЛогинПользователя = ИмяПользователя();
	Если ПустаяСтрока(ЛогинПользователя) Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем пользователя в справочнике
	Попытка
		// Пробуем найти через ПользователиИнформационнойБазы
		ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоИмени(ЛогинПользователя);
		Если ПользовательИБ <> Неопределено Тогда
			УИДПользователяИБ = ПользовательИБ.УникальныйИдентификатор;
			
			// Ищем в справочнике Пользователи (без ФизическогоЛица - на него может не быть прав)
			Запрос = Новый Запрос;
			Запрос.Текст = 
				"ВЫБРАТЬ
				|	Пользователи.Ссылка КАК Ссылка,
				|	Пользователи.Наименование КАК Наименование
				|ИЗ
				|	Справочник.Пользователи КАК Пользователи
				|ГДЕ
				|	Пользователи.ИдентификаторПользователяИБ = &ИдентификаторПользователяИБ";
			Запрос.УстановитьПараметр("ИдентификаторПользователяИБ", УИДПользователяИБ);
			
			Выборка = Запрос.Выполнить().Выбрать();
			Если Выборка.Следующий() Тогда
				// Формат наименования: "Фамилия Имя Отчество"
				// Берём второе слово как имя для обращения
				ЧастиНаименования = СтрРазделить(Выборка.Наименование, " ", Ложь);
				Если ЧастиНаименования.Количество() >= 2 Тогда
					Результат.Имя = ЧастиНаименования[1]; // Второе слово = Имя
				ИначеЕсли ЧастиНаименования.Количество() = 1 Тогда
					Результат.Имя = ЧастиНаименования[0]; // Только одно слово
				КонецЕсли;
				
				Результат.ПолноеНаименование = Выборка.Наименование;
				Результат.Ссылка = Строка(Выборка.Ссылка.УникальныйИдентификатор());
			Иначе
				// Пользователь ИБ есть, но элемента справочника нет
				Результат.Имя = ЛогинПользователя;
			КонецЕсли;
		Иначе
			// Нет пользователя ИБ
			Результат.Имя = ЛогинПользователя;
		КонецЕсли;
	Исключение
		// Ошибка при поиске - используем логин
		Результат.Имя = ЛогинПользователя;
		ЗаписьЖурналаРегистрации("MCP.Агент", УровеньЖурналаРегистрации.Предупреждение, , , 
			СтрШаблон("Не удалось получить информацию о пользователе: %1", 
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())));
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает Bearer токен для авторизации в AI Gateway
// Создаёт простой токен из AD-логина текущего пользователя и сервисного пароля
// Токен создаётся ВСЕГДА при каждом запросе (без кэширования)
//
// Параметры:
//  АдресСервера - Строка - не используется (для совместимости)
//
// Возвращаемое значение:
//  Строка - Bearer токен в формате simple_base64(login:password)
//
Функция ПолучитьBearerТокен(АдресСервера) Экспорт
	
	// Получаем ЛОГИН пользователя ИБ (не наименование!)
	// ИмяПользователя() может возвращать полное имя, нам нужен логин для Basic Auth
	Попытка
		ПользовательИБ = ПользователиИнформационнойБазы.ТекущийПользователь();
		ЛогинПользователя = ПользовательИБ.Имя;
	Исключение
		// Fallback на ИмяПользователя() если не удалось получить пользователя ИБ
		ЛогинПользователя = ИмяПользователя();
	КонецПопытки;
	
	// ДИАГНОСТИКА: проверяем логин
	ЗаписьЖурналаРегистрации("MCP.Агент.Debug", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("DEBUG: Логин пользователя ИБ = '%1'", ЛогинПользователя));
	
	Если ПустаяСтрока(ЛогинПользователя) Тогда
		ЗаписьЖурналаРегистрации("MCP.Агент.OAuth2", УровеньЖурналаРегистрации.Ошибка, , , 
			"ОШИБКА: Не удалось получить логин пользователя ИБ!");
		Возврат "";
	КонецЕсли;
	
	Попытка
		СервисныйПароль = Константы.mcp_СервисныйПарольOAuth2.Получить();
	Исключение
		СервисныйПароль = "";
	КонецПопытки;
	
	// ДИАГНОСТИКА: проверяем пароль
	ЗаписьЖурналаРегистрации("MCP.Агент.Debug", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("DEBUG: СервисныйПароль заполнен = %1, длина = %2", 
			ЗначениеЗаполнено(СервисныйПароль), СтрДлина(СервисныйПароль)));
	
	Если НЕ ЗначениеЗаполнено(СервисныйПароль) Тогда
		ЗаписьЖурналаРегистрации("MCP.Агент.OAuth2", УровеньЖурналаРегистрации.Предупреждение, , , 
			"Константа mcp_СервисныйПарольOAuth2 не заполнена");
		Возврат "";
	КонецЕсли;
	
	// Формируем строку креденшилов
	СтрокаКредов = ЛогинПользователя + ":" + СервисныйПароль;
	
	// ДИАГНОСТИКА: проверяем строку
	ЗаписьЖурналаРегистрации("MCP.Агент.Debug", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("DEBUG: СтрокаКредов = '%1' (длина %2)", 
			Лев(СтрокаКредов, 20) + "***", СтрДлина(СтрокаКредов)));
	
	// Создаём простой токен
	ДвоичныеДанные = ПолучитьДвоичныеДанныеИзСтроки(СтрокаКредов, КодировкаТекста.UTF8);
	Base64Часть = Base64Строка(ДвоичныеДанные);
	
	// ВАЖНО: Base64Строка может добавлять переносы строк!
	// Удаляем их, т.к. они недопустимы в HTTP заголовках
	Base64Часть = СтрЗаменить(Base64Часть, Символы.ВК, "");
	Base64Часть = СтрЗаменить(Base64Часть, Символы.ПС, "");
	Base64Часть = СтрЗаменить(Base64Часть, " ", "");
	
	Токен = "simple_" + Base64Часть;
	
	// ДИАГНОСТИКА: проверяем токен
	ЗаписьЖурналаРегистрации("MCP.Агент.Debug", УровеньЖурналаРегистрации.Информация, , , 
		СтрШаблон("DEBUG: Токен = '%1' (длина %2)", 
			Лев(Токен, 30) + "***", СтрДлина(Токен)));
	
	Возврат Токен;
	
КонецФункции

#КонецОбласти
