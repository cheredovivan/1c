---
description: Правила для работы с кодом 1С:Предприятие и расширениями
alwaysApply: true
---

Ты — Codex-агент, работающий с кодом 1С:Предприятие и его расширениями.
Твоя основная задача — помогать в написании и проверке кода 1С (BSL),
используя метаданные и данные MCP-сервера, а также анализ существующего кода в проекте.

ОБЩИЕ ПРАВИЛА

0. Рассуждения, размышления выводи обязательно только на русском языке. Если размышления (thinking) выводишь не на русском - это ошибка!

1. После изменения кода юзер должен обновить конфигурацию, только после этого новый код будет работать.
	Поэтому закончив изменения, останавливайся и сообщай пользователю, что закончил и ждешь обновления.

2. Всегда исходи из реальной конфигурации.
   - Не придумывай объекты метаданных (справочники, документы, регистры, планы видов, реквизиты и т.п.).
   - Любое неизвестное имя объекта или реквизита сначала проверяй через MCP.

3. Перед каждым ответом по коду:
   - Определи контекст: модуль объекта, общих модулей, запрос, форма, объект метаданных или внешний файл.
   - Если нужно, уточни, к какому объекту метаданных относится код (документ, регистр, справочник и т.д.).

4. Источники правды для конфигурации:
   - Для структуры метаданных используй MCP-инструменты:
     • `list_metadata_objects` — получить список объектов и их точные имена.
     • `get_metadata_structure` — получить структуру объекта: реквизиты, табличные части, измерения, ресурсы и пр.
   - Для примеров реальных данных и проверки логики используй:
     • `read_object_data` — чтение данных объектов базы (элементы справочников, документы, табличные части, срезы регистров).

ИСПОЛЬЗОВАНИЕ MCP-ИНСТРУМЕНТОВ

Перед использованием инструментов обязательно вызови и прочти data_tools_guide

4.1. ОБРАБОТКА ОШИБОК MCP:
   - Если MCP-инструмент вернул ошибку соединения или "Tool not found" — повтори вызов ещё раз.
   - Временные сбои соединения случаются, и повторный вызов обычно срабатывает.
   - Только после 2-3 неудачных попыток переходи к альтернативным способам (grep, поиск в коде).

5. `list_metadata_objects`:
   - Применяй, когда нужно понять, как именно называется объект (Catalogs.Номенклатура, Documents.ЗаказПокупателя и т.п.).
   - Запрашивай по нужному `metaType` (Catalogs, Documents, InformationRegisters, AccumulationRegisters,
     AccountingRegisters, CalculationRegisters), чтобы не перебирать всё подряд.

6. `get_metadata_structure`:
   - Используй перед написанием запросов и при работе с реквизитами/табличными частями.
   - Проверяй:
     • названия реквизитов, измерений, ресурсов, табличных частей;
     • типы полей и ссылки на другие объекты;
     • ключевые поля для отбора и группировок.
   - Если структура отличается от твоих предположений — адаптируй код под реальную схему, а не наоборот.

6.1. ПРАВИЛА НАПИСАНИЯ ЗАПРОСОВ:
   - НЕДОПУСТИМО использовать неоднозначные имена полей в запросах.
   - Если алиас основной таблицы совпадает с именем поля в подзапросе или соединении — это вызовет ошибку "Неоднозначное поле".
   - Решение: использовать уникальные алиасы для таблиц, которые не пересекаются с именами полей в подзапросах.

   - Пример 1 (справочник):
     * Ошибка: `Справочник.Номенклатура КАК Номенклатура` + подзапрос с полем `... КАК Номенклатура`
     * Исправление: переименовать алиас на `ВыбраннаяНоменклатура`

   - Пример 2 (табличные части документов):
     * Ошибка: `Документ.ЭтапПроизводства2_2.ВыходныеИзделия КАК ВыходныеИзделия`
       Алиас `ВыходныеИзделия` совпадает с именем табличной части — неоднозначность при обращении.
     * Исправление: использовать алиас `ВыходныеИзделияЭтапа` или `ВыходныеИзделияТЧ`
     * Аналогично для `ПобочныеИзделия` → `ПобочныеИзделияЭтапа`

7. `read_object_data` (НОВЫЙ ИНСТРУМЕНТ):
   - Назначение: читать реальные данные из 1С для:
     • проверки гипотез по логике;
     • подбора корректных отборов и условий в запросах;
     • поиска типичных/граничных примеров для тестов.
   - Обязательные параметры:
     • `metaType` — тип объекта (Catalogs, Documents, InformationRegisters, AccumulationRegisters,
       AccountingRegisters, CalculationRegisters).
     • `name` — точное имя объекта метаданных (без учёта регистра).
     • `mode` — режим чтения:
       - `catalog_item` — элементы справочника;
       - `document_header` — шапка документа;
       - `document_table_part` — строки табличной части документа;
       - `register_slice` — выборка/срез регистра.
   - Дополнительные параметры:
     • `selector`:
       - для справочников/документов — ссылка (строка UUID) или код/номер (строка);
       - для регистров — структура с измерениями и условиями отбора;
     • `tablePart` — имя табличной части (обязательно при `mode='document_table_part'`);
     • `fields` — список полей; если не задан, возвращаются все;
     • `maxRows` — по умолчанию запрашивай небольшие выборки (например, 50–200 строк),
       увеличивай только при явной необходимости;
     • `format`:
       - по умолчанию используй `'json'` для последующей программной обработки;
       - используй `'markdown'`, когда нужно показать человеку удобочитаемую таблицу в ответе.
   - Не используй `read_object_data` для массовых выгрузок и сложной аналитики — для этого пиши запросы в BSL.
     Инструмент нужен для быстрых точечных проверок и получения реальных примеров данных.

РАБОТА С ПРОЕКТОМ

8. Структура файлов:
   - `src_Extension` — основное расширение. ВСЕ изменения кода вноси только сюда.
   - `src_MCP` — MCP-расширение (только для чтения и поиска примеров, если не указано иное).
   - При поиске примеров:
     • сначала смотри в `src_Extension`, чтобы сохранить единообразие стиля;
     • затем в `src_MCP`, если в расширении примеров нет.

9. Анализ существующего кода:
   - Перед написанием новой логики ищи похожие решения в проекте.
   - Ориентируйся на уже используемые:
     • общие модули и их экспортные процедуры;
     • подходы к обработке ошибок;
     • шаблоны работы с регистрами и документами.
   - Если есть сомнения в синтаксисе или подходе:
     • сначала ищи примеры в коде проекта;
     • затем опирайся на свои знания BSL.

10. Проверка синтаксиса:
   - Для синтаксиса и базовых ошибок полагайся на `bsl-language-server`, настроенный в проекте.
   - При предложении изменений учитывай включённые диагностические правила,
     не предлагай конструкции, которые гарантированно будут ругаться линтером.

ДИРЕКТИВЫ ПРЕПРОЦЕССОРА В РАСШИРЕНИЯХ

11. Аннотация `&ИзменениеИКонтроль`:
    - Используется для переопределения/расширения методов основной конфигурации.
    - Метод расширения должен ТОЧНО соответствовать оригиналу по форматированию (пробелы, табуляция, переносы).
    - Имя метода в расширении: `Расш1_ИмяОригинальногоМетода`.

12. Директивы `#Удаление` и `#Вставка`:
    - `#Удаление` / `#КонецУдаления` — исключает обрамлённый код из компиляции (удаляет оригинальный код).
    - `#Вставка` / `#КонецВставки` — добавляет новый код в метод.
    - ЭТО НЕ КОММЕНТАРИИ! Директивы НЕ должны начинаться с `//`.
    - Директивы работают только внутри методов с аннотацией `&ИзменениеИКонтроль`.

    Пример правильного использования:
    ```bsl
    &ИзменениеИКонтроль("ОригинальныйМетод")
    Процедура Расш1_ОригинальныйМетод(Параметр)

        // Оригинальный код...
        #Удаление
        СтароеЗначение = ПолучитьСтароеЗначение();
        #КонецУдаления
        #Вставка
        СтароеЗначение = ПолучитьНовоеЗначение();
        #КонецВставки
        // Продолжение оригинального кода...

        #Вставка
        // Полностью новый код
        ДополнительнаяОбработка();
        #КонецВставки

    КонецПроцедуры
    ```

ОБНОВЛЕНИЕ РАСШИРЕНИЯ ПРИ ИЗМЕНЕНИИ ОСНОВНОЙ КОНФИГУРАЦИИ

13. Ошибка "Текст метода не соответствует методу конфигурации":
    - Возникает, когда оригинальный метод в основной конфигурации изменился.
    - Даже минимальные различия (пробелы, регистр, форматирование) вызывают ошибку.

14. Алгоритм исправления:
    1. Найти оригинальный метод в основной конфигурации.
    2. Найти метод расширения в `src_Extension/`.
    3. Выявить кастомную логику в расширении (блоки `#Удаление`/`#Вставка`).
    4. ПОЛНОСТЬЮ переписать метод расширения:
       - Скопировать актуальный код из основной конфигурации.
       - Заменить имя функции на `Расш1_...`.
       - Добавить аннотацию `&ИзменениеИКонтроль("ОригинальноеИмя")`.
       - Вставить сохранённую кастомную логику через `#Удаление`/`#Вставка`.
    5. Проверить lint-ошибки.

15. Типичные кастомные изменения в печатных формах:
    - Замена макета: `УправлениеПечатью.МакетПечатнойФормы("...Расш1_КастомныйМакет")`.
    - Получение ячеек из `РегистрСведений.РазмещениеНоменклатурыПоСкладскимЯчейкам`.
    - Получение остатков из `РегистрНакопления.ТоварыНаСкладах.Остатки`.

ОГРАНИЧЕНИЯ ПО ТИПАМ

16. В этой конфигурации НЕДОСТУПНЫ типы `Множество` и `МножествоЗначений`.
    - Не предлагай решения, основанные на этих типах.
    - Вместо этого используй:
      • массивы;
      • соответствия;
      • временные таблицы запросов;
      • структуры или другие доступные коллекции.

РЕФАКТОРИНГ И ФИНАЛЬНАЯ ПРОВЕРКА

17. После каждого рефакторинга или внесения изменений выполняй финальную проверку на наличие «хвостов»:

    17.1. ДУБЛИРОВАНИЕ:
      - Ищи повторяющуюся логику обработки параметров.
      - Объединяй дублирующиеся блоки кода.
      - Общую логику выноси в начало функции/процедуры или в отдельную вспомогательную процедуру.

    17.2. НЕИСПОЛЬЗУЕМЫЙ КОД:
      - Удаляй переменные, которые больше не используются.
      - Удаляй временные таблицы, которые создаются, но не участвуют в итоговом запросе/результате.
      - Удаляй закомментированный код, если он не нужен для понимания и истории.

    17.3. УСТАРЕВШИЕ КОММЕНТАРИИ:
      - Обновляй комментарии, если логика изменилась.
      - Удаляй комментарии, описывающие уже удалённый или радикально переписанный код.

    17.4. ИЗБЫТОЧНЫЙ КОД:
      - Удаляй промежуточные шаги, которые стали ненужными после оптимизации.
      - Упрощай условия, циклы и ветвления, если их можно сделать короче без потери читаемости.

18. Перед завершением любой задачи по коду всегда задавай себе вопросы:
    - «Можно ли упростить этот код ещё сильнее, не жертвуя понятностью и безопасностью?»
    - «Нет ли здесь лишних сущностей, временных таблиц, переменных или комментариев?»

ОТОБРАЖЕНИЕ ИЗМЕНЕНИЙ КОДА

19. При каждом изменении кода показывай diff в формате unified diff:
    - Используй блок ```diff для наглядности.
    - Строки с `-` — удалённый код, `+` — добавленный.
    - Включай 2-3 строки контекста вокруг изменения.
    - Указывай имя файла перед блоком.

    Пример:
    **src_Extension/CommonModules/МойМодуль/Ext/Module.bsl**
    ```diff
     Процедура ОбработатьДанные(Параметры)
    -    Результат = СтароеЗначение();
    +    Результат = НовоеЗначение();
         Возврат Результат;
     КонецПроцедуры
    ```

БЫСТРАЯ ЗАЛИВКА НА GITHUB

20. АВТОМАТИЧЕСКАЯ ЗАЛИВКА ПОСЛЕ ИЗМЕНЕНИЙ:
    - После завершения внесения изменений в код ВСЕГДА автоматически заливай на GitHub.
    - Не жди просьбы юзера — сразу коммить и пуши после успешных правок.
    - Это касается любых изменений: фиксов, новых функций, рефакторинга.

21. Процедура заливки на GitHub:
    1. `git add <конкретные файлы>` — добавлять только изменённые файлы, НЕ использовать `git add -A`.
       Если кириллица в пути вызывает ошибки — использовать glob-паттерн.
    2. Сообщение коммита — ПОДРОБНОЕ, на русском, в стиле conventional commits:
       - Первая строка: тип и краткое описание (feat/fix/refactor/docs и т.д.)
       - Пустая строка
       - Описание проблемы
       - Описание решения (по пунктам)
       - Список затронутых файлов/процедур
    3. Если сообщение длинное — использовать файл: создать `commit_msg.txt`, выполнить `git commit -F commit_msg.txt`, удалить файл.
    4. `git push`
    - В PowerShell НЕ использовать heredoc, НЕ использовать `&&` (использовать `;`).
    - Не спрашивать подтверждение — сразу коммитить и пушить.
